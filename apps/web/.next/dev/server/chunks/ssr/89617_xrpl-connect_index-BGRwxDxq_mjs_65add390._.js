module.exports = [
"[project]/node_modules/.pnpm/xrpl-connect@0.4.0/node_modules/xrpl-connect/index-BGRwxDxq.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "A",
    ()=>w$,
    "B",
    ()=>F0,
    "C",
    ()=>ds,
    "D",
    ()=>NR,
    "E",
    ()=>UP,
    "F",
    ()=>Mt,
    "G",
    ()=>KM,
    "H",
    ()=>jo,
    "I",
    ()=>Ah,
    "J",
    ()=>Lb,
    "K",
    ()=>TR,
    "L",
    ()=>yR,
    "M",
    ()=>ol,
    "N",
    ()=>vs,
    "O",
    ()=>_r,
    "Q",
    ()=>gt,
    "R",
    ()=>X1,
    "S",
    ()=>Hr,
    "T",
    ()=>y$,
    "W",
    ()=>rU,
    "X",
    ()=>Mv,
    "Z",
    ()=>So,
    "a",
    ()=>o0,
    "b",
    ()=>g$,
    "c",
    ()=>$t,
    "d",
    ()=>xv,
    "e",
    ()=>ER,
    "f",
    ()=>Gt,
    "g",
    ()=>Ut,
    "h",
    ()=>ge,
    "i",
    ()=>bR,
    "j",
    ()=>vR,
    "k",
    ()=>Mb,
    "l",
    ()=>vb,
    "m",
    ()=>Eb,
    "n",
    ()=>R0,
    "o",
    ()=>rc,
    "p",
    ()=>Nb,
    "q",
    ()=>Sh,
    "r",
    ()=>Oe,
    "s",
    ()=>Er,
    "t",
    ()=>nn,
    "u",
    ()=>pi,
    "v",
    ()=>Oo,
    "w",
    ()=>xR,
    "x",
    ()=>Cb,
    "y",
    ()=>IR,
    "z",
    ()=>_h
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xrpl$40$3$2e$1$2e$0$2f$node_modules$2f$xrpl$2f$dist$2f$npm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xrpl@3.1.0/node_modules/xrpl/dist/npm/index.js [app-ssr] (ecmascript)");
var fb = Object.defineProperty;
var xh = (r)=>{
    throw TypeError(r);
};
var pb = (r, e, t)=>e in r ? fb(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t;
var S = (r, e, t)=>pb(r, typeof e != "symbol" ? e + "" : e, t), gb = (r, e, t)=>e.has(r) || xh("Cannot " + t);
var bs = (r, e, t)=>(gb(r, e, "read from private field"), t ? t.call(r) : e.get(r)), Ao = (r, e, t)=>e.has(r) ? xh("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t);
;
var $ = typeof globalThis < "u" ? globalThis : ("TURBOPACK compile-time value", "undefined") < "u" ? window : ("TURBOPACK compile-time value", "object") < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.g : typeof self < "u" ? self : {};
function Di(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function P0(r) {
    if (r.__esModule) return r;
    var e = r.default;
    if (typeof e == "function") {
        var t = function n() {
            return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
        };
        t.prototype = e.prototype;
    } else t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }), Object.keys(r).forEach(function(n) {
        var s = Object.getOwnPropertyDescriptor(r, n);
        Object.defineProperty(t, n, s.get ? s : {
            enumerable: !0,
            get: function() {
                return r[n];
            }
        });
    }), t;
}
var U0 = {
    exports: {}
};
(function(r) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function n() {}
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (t = !1));
    function s(u, c, l) {
        this.fn = u, this.context = c, this.once = l || !1;
    }
    function i(u, c, l, d, h) {
        if (typeof l != "function") throw new TypeError("The listener must be a function");
        var f = new s(l, d || u, h), g = t ? t + c : c;
        return u._events[g] ? u._events[g].fn ? u._events[g] = [
            u._events[g],
            f
        ] : u._events[g].push(f) : (u._events[g] = f, u._eventsCount++), u;
    }
    function o(u, c) {
        --u._eventsCount === 0 ? u._events = new n() : delete u._events[c];
    }
    function a() {
        this._events = new n(), this._eventsCount = 0;
    }
    a.prototype.eventNames = function() {
        var c = [], l, d;
        if (this._eventsCount === 0) return c;
        for(d in l = this._events)e.call(l, d) && c.push(t ? d.slice(1) : d);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(l)) : c;
    }, a.prototype.listeners = function(c) {
        var l = t ? t + c : c, d = this._events[l];
        if (!d) return [];
        if (d.fn) return [
            d.fn
        ];
        for(var h = 0, f = d.length, g = new Array(f); h < f; h++)g[h] = d[h].fn;
        return g;
    }, a.prototype.listenerCount = function(c) {
        var l = t ? t + c : c, d = this._events[l];
        return d ? d.fn ? 1 : d.length : 0;
    }, a.prototype.emit = function(c, l, d, h, f, g) {
        var p = t ? t + c : c;
        if (!this._events[p]) return !1;
        var m = this._events[p], x = arguments.length, _, v;
        if (m.fn) {
            switch(m.once && this.removeListener(c, m.fn, void 0, !0), x){
                case 1:
                    return m.fn.call(m.context), !0;
                case 2:
                    return m.fn.call(m.context, l), !0;
                case 3:
                    return m.fn.call(m.context, l, d), !0;
                case 4:
                    return m.fn.call(m.context, l, d, h), !0;
                case 5:
                    return m.fn.call(m.context, l, d, h, f), !0;
                case 6:
                    return m.fn.call(m.context, l, d, h, f, g), !0;
            }
            for(v = 1, _ = new Array(x - 1); v < x; v++)_[v - 1] = arguments[v];
            m.fn.apply(m.context, _);
        } else {
            var N = m.length, O;
            for(v = 0; v < N; v++)switch(m[v].once && this.removeListener(c, m[v].fn, void 0, !0), x){
                case 1:
                    m[v].fn.call(m[v].context);
                    break;
                case 2:
                    m[v].fn.call(m[v].context, l);
                    break;
                case 3:
                    m[v].fn.call(m[v].context, l, d);
                    break;
                case 4:
                    m[v].fn.call(m[v].context, l, d, h);
                    break;
                default:
                    if (!_) for(O = 1, _ = new Array(x - 1); O < x; O++)_[O - 1] = arguments[O];
                    m[v].fn.apply(m[v].context, _);
            }
        }
        return !0;
    }, a.prototype.on = function(c, l, d) {
        return i(this, c, l, d, !1);
    }, a.prototype.once = function(c, l, d) {
        return i(this, c, l, d, !0);
    }, a.prototype.removeListener = function(c, l, d, h) {
        var f = t ? t + c : c;
        if (!this._events[f]) return this;
        if (!l) return o(this, f), this;
        var g = this._events[f];
        if (g.fn) g.fn === l && (!h || g.once) && (!d || g.context === d) && o(this, f);
        else {
            for(var p = 0, m = [], x = g.length; p < x; p++)(g[p].fn !== l || h && !g[p].once || d && g[p].context !== d) && m.push(g[p]);
            m.length ? this._events[f] = m.length === 1 ? m[0] : m : o(this, f);
        }
        return this;
    }, a.prototype.removeAllListeners = function(c) {
        var l;
        return c ? (l = t ? t + c : c, this._events[l] && o(this, l)) : (this._events = new n(), this._eventsCount = 0), this;
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, r.exports = a;
})(U0);
var wb = U0.exports;
const mb = /* @__PURE__ */ Di(wb), Hr = {
    mainnet: {
        id: "mainnet",
        name: "Mainnet",
        wss: "wss://xrplcluster.com",
        rpc: "https://xrplcluster.com",
        walletConnectId: "xrpl:0"
    },
    testnet: {
        id: "testnet",
        name: "Testnet",
        wss: "wss://s.altnet.rippletest.net:51233/",
        rpc: "https://testnet.xrpl-labs.com",
        walletConnectId: "xrpl:1"
    },
    devnet: {
        id: "devnet",
        name: "Devnet",
        wss: "wss://s.devnet.rippletest.net:51233/",
        rpc: "https://s.devnet.rippletest.net:51234/",
        walletConnectId: "xrpl:2"
    }
};
var Gt = /* @__PURE__ */ ((r)=>(r.WALLET_NOT_FOUND = "WALLET_NOT_FOUND", r.WALLET_NOT_INSTALLED = "WALLET_NOT_INSTALLED", r.WALLET_NOT_AVAILABLE = "WALLET_NOT_AVAILABLE", r.CONNECTION_FAILED = "CONNECTION_FAILED", r.CONNECTION_REJECTED = "CONNECTION_REJECTED", r.SIGN_FAILED = "SIGN_FAILED", r.SIGN_REJECTED = "SIGN_REJECTED", r.NETWORK_NOT_SUPPORTED = "NETWORK_NOT_SUPPORTED", r.NETWORK_MISMATCH = "NETWORK_MISMATCH", r.NOT_CONNECTED = "NOT_CONNECTED", r.ALREADY_CONNECTED = "ALREADY_CONNECTED", r.UNSUPPORTED_METHOD = "UNSUPPORTED_METHOD", r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r))(Gt || {});
class Ut extends Error {
    constructor(e, t, n){
        super(t), this.name = "WalletError", this.code = e, this.originalError = n, Error.captureStackTrace && Error.captureStackTrace(this, Ut);
    }
    /**
   * Convert to JSON representation
   */ toJSON() {
        return {
            name: this.name,
            code: this.code,
            message: this.message,
            stack: this.stack,
            originalError: this.originalError ? {
                name: this.originalError.name,
                message: this.originalError.message,
                stack: this.originalError.stack
            } : void 0
        };
    }
}
const ge = {
    notFound: (r)=>new Ut(Gt.WALLET_NOT_FOUND, `Wallet with id "${r}" was not found. Make sure the adapter is registered.`),
    notInstalled: (r)=>new Ut(Gt.WALLET_NOT_INSTALLED, `${r} is not installed. Please install the wallet extension or app.`),
    notAvailable: (r)=>new Ut(Gt.WALLET_NOT_AVAILABLE, `${r} is not currently available.`),
    connectionFailed: (r, e)=>new Ut(Gt.CONNECTION_FAILED, `Failed to connect to ${r}. ${(e == null ? void 0 : e.message) || ""}`, e),
    connectionRejected: (r)=>new Ut(Gt.CONNECTION_REJECTED, `Connection to ${r} was rejected by the user.`),
    signFailed: (r)=>new Ut(Gt.SIGN_FAILED, `Failed to sign transaction. ${(r == null ? void 0 : r.message) || ""}`, r),
    signRejected: ()=>new Ut(Gt.SIGN_REJECTED, "Transaction signing was rejected by the user."),
    networkNotSupported: (r, e)=>new Ut(Gt.NETWORK_NOT_SUPPORTED, `Network "${r}" is not supported by ${e}.`),
    networkMismatch: (r, e)=>new Ut(Gt.NETWORK_MISMATCH, `Network mismatch. Expected "${r}" but wallet is connected to "${e}".`),
    notConnected: ()=>new Ut(Gt.NOT_CONNECTED, "No wallet is currently connected. Please connect a wallet first."),
    alreadyConnected: (r)=>new Ut(Gt.ALREADY_CONNECTED, `${r} is already connected. Disconnect first before connecting to another wallet.`),
    unsupportedMethod: (r)=>new Ut(Gt.UNSUPPORTED_METHOD, r),
    unknown: (r, e)=>new Ut(Gt.UNKNOWN_ERROR, r, e)
};
function bR(r) {
    return r instanceof Ut;
}
function vR(r) {
    return r instanceof Error ? r.message : String(r);
}
const Th = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
    none: 4
};
function bb() {
    var r;
    return typeof process < "u" && (r = process.env) != null && r.NODE_ENV ? ("TURBOPACK compile-time value", "development") === "development" : ("TURBOPACK compile-time value", "undefined") < "u" ? window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname.includes("dev") : !1;
}
class R0 {
    constructor(e = {}){
        this.level = e.level || (bb() ? "debug" : "warn"), this.prefix = e.prefix || "[xrpl-connect]";
    }
    /**
   * Check if a log level should be output
   */ shouldLog(e) {
        return Th[e] >= Th[this.level];
    }
    /**
   * Format log message with prefix
   */ formatMessage(e, t) {
        const n = /* @__PURE__ */ new Date().toISOString();
        return `${this.prefix} [${e.toUpperCase()}] ${n} - ${t}`;
    }
    /**
   * Log debug message
   */ debug(e, ...t) {
        this.shouldLog("debug") && console.debug(this.formatMessage("debug", e), ...t);
    }
    /**
   * Log info message
   */ info(e, ...t) {
        this.shouldLog("info") && console.info(this.formatMessage("info", e), ...t);
    }
    /**
   * Log warning message
   */ warn(e, ...t) {
        this.shouldLog("warn") && console.warn(this.formatMessage("warn", e), ...t);
    }
    /**
   * Log error message
   */ error(e, ...t) {
        this.shouldLog("error") && console.error(this.formatMessage("error", e), ...t);
    }
    /**
   * Update log level
   */ setLevel(e) {
        this.level = e;
    }
    /**
   * Get current log level
   */ getLevel() {
        return this.level;
    }
}
function rc(r, e) {
    return new R0({
        prefix: r,
        level: e
    });
}
const Qn = rc("[Storage]");
class vb {
    constructor(){
        this.prefix = "xrpl-connect:";
    }
    async get(e) {
        try {
            return ("TURBOPACK compile-time value", "undefined") > "u" || !window.localStorage ? null : window.localStorage.getItem(this.prefix + e);
        } catch (t) {
            return Qn.warn("Failed to read from localStorage:", t), null;
        }
    }
    async set(e, t) {
        try {
            if (("TURBOPACK compile-time value", "undefined") > "u" || !window.localStorage) return;
            window.localStorage.setItem(this.prefix + e, t);
        } catch (n) {
            Qn.warn("Failed to write to localStorage:", n);
        }
    }
    async remove(e) {
        try {
            if (("TURBOPACK compile-time value", "undefined") > "u" || !window.localStorage) return;
            window.localStorage.removeItem(this.prefix + e);
        } catch (t) {
            Qn.warn("Failed to remove from localStorage:", t);
        }
    }
    async clear() {
        try {
            if (("TURBOPACK compile-time value", "undefined") > "u" || !window.localStorage) return;
            const e = [];
            for(let t = 0; t < window.localStorage.length; t++){
                const n = window.localStorage.key(t);
                n != null && n.startsWith(this.prefix) && e.push(n);
            }
            e.forEach((t)=>window.localStorage.removeItem(t));
        } catch (e) {
            Qn.warn("Failed to clear localStorage:", e);
        }
    }
}
class Eb {
    constructor(){
        this.storage = /* @__PURE__ */ new Map();
    }
    async get(e) {
        return this.storage.get(e) || null;
    }
    async set(e, t) {
        this.storage.set(e, t);
    }
    async remove(e) {
        this.storage.delete(e);
    }
    async clear() {
        this.storage.clear();
    }
}
var fn;
let Mb = (fn = class {
    constructor(e){
        this.adapter = e || (("TURBOPACK compile-time value", "undefined") < "u" && window.localStorage ? new vb() : new Eb());
    }
    /**
   * Save wallet connection state
   */ async saveState(e) {
        try {
            const t = JSON.stringify(e);
            await this.adapter.set(fn.STATE_KEY, t);
        } catch (t) {
            Qn.warn("Failed to save state:", t);
        }
    }
    /**
   * Load wallet connection state
   */ async loadState() {
        try {
            const e = await this.adapter.get(fn.STATE_KEY);
            return e ? JSON.parse(e) : null;
        } catch (e) {
            return Qn.warn("Failed to load state:", e), null;
        }
    }
    /**
   * Clear wallet connection state
   */ async clearState() {
        try {
            await this.adapter.remove(fn.STATE_KEY);
        } catch (e) {
            Qn.warn("Failed to clear state:", e);
        }
    }
    /**
   * Clear all storage
   */ async clear() {
        try {
            await this.adapter.clear();
        } catch (e) {
            Qn.warn("Failed to clear storage:", e);
        }
    }
}, fn.STATE_KEY = "wallet-state", fn);
const Nb = {
    /** Maximum age for stored wallet state before it's considered stale (7 days) */ STATE_MAX_AGE: 7 * 24 * 60 * 60 * 1e3
};
class ER extends mb {
    constructor(e){
        super(), this.adapters = /* @__PURE__ */ new Map(), this.currentAdapter = null, this.currentAccount = null, this.options = e, this.logger = new R0(e.logger), this.storage = new Mb(e.storage), e.adapters.forEach((t)=>{
            this.adapters.set(t.id, t), this.logger.debug(`Registered adapter: ${t.name} (${t.id})`);
        }), e.autoConnect && this.autoConnect();
    }
    /**
   * Attempt to auto-connect from stored state
   */ async autoConnect() {
        try {
            const e = await this.storage.loadState();
            e && this.isStateValid(e) && (this.logger.debug("Attempting auto-reconnect", e), await this.reconnect());
        } catch (e) {
            this.logger.warn("Auto-connect failed:", e);
        }
    }
    /**
   * Check if stored state is still valid (not too old)
   */ isStateValid(e) {
        return Date.now() - e.timestamp < Nb.STATE_MAX_AGE;
    }
    /**
   * Connect to a wallet
   */ async connect(e, t) {
        this.logger.info(`Connecting to wallet: ${e}`);
        const n = this.adapters.get(e);
        if (!n) throw ge.notFound(e);
        if (this.currentAdapter && this.currentAdapter.id !== e) throw ge.alreadyConnected(this.currentAdapter.name);
        try {
            if (!await n.isAvailable()) throw ge.notAvailable(n.name);
            const i = {
                ...t,
                network: (t == null ? void 0 : t.network) || this.options.network
            }, o = await n.connect(i);
            this.currentAdapter = n, this.currentAccount = o;
            const a = {
                walletId: n.id,
                account: o,
                network: o.network,
                timestamp: Date.now()
            };
            return await this.storage.saveState(a), n.on && (n.on("disconnect", ()=>this.handleAdapterDisconnect()), n.on("accountChanged", (u)=>this.handleAccountChanged(u)), n.on("networkChanged", (u)=>this.handleNetworkChanged(u))), this.logger.info(`Connected to ${n.name}`, o), this.emit("connect", o), o;
        } catch (s) {
            throw this.logger.error(`Failed to connect to ${n.name}:`, s), ge.connectionFailed(n.name, s);
        }
    }
    /**
   * Disconnect from current wallet
   */ async disconnect() {
        if (!this.currentAdapter) {
            this.logger.warn("No wallet connected");
            return;
        }
        const e = this.currentAdapter.name;
        this.logger.info(`Disconnecting from ${e}`);
        try {
            await this.currentAdapter.disconnect(), await this.cleanup(), this.logger.info(`Disconnected from ${e}`), this.emit("disconnect");
        } catch (t) {
            throw this.logger.error(`Failed to disconnect from ${e}:`, t), t;
        }
    }
    /**
   * Reconnect to previously connected wallet
   */ async reconnect() {
        const e = await this.storage.loadState();
        if (!e) return this.logger.debug("No stored state found for reconnection"), null;
        try {
            return await this.connect(e.walletId);
        } catch (t) {
            return this.logger.warn("Reconnection failed:", t), await this.storage.clearState(), null;
        }
    }
    /**
   * Sign and optionally submit a transaction to the ledger
   * This unified method works consistently across all wallets
   * @param transaction - The transaction to sign
   * @param submit - Whether to submit the transaction to the ledger (default: true)
   * @returns SubmittedTransaction with hash and optional submission details
   */ async signAndSubmit(e, t = !0) {
        if (!this.currentAdapter) throw ge.notConnected();
        this.logger.debug(`${t ? "Signing and submitting" : "Signing"} transaction`, e);
        try {
            const n = await this.currentAdapter.signAndSubmit(e, t);
            return this.logger.info(`Transaction ${t ? "submitted" : "signed"}`, n.hash || n.id), n;
        } catch (n) {
            throw this.logger.error(`Failed to ${t ? "submit" : "sign"} transaction:`, n), ge.signFailed(n);
        }
    }
    /**
   * Sign a message
   */ async signMessage(e) {
        if (!this.currentAdapter) throw ge.notConnected();
        this.logger.debug("Signing message");
        try {
            const t = await this.currentAdapter.signMessage(e);
            return this.logger.info("Message signed"), t;
        } catch (t) {
            throw this.logger.error("Failed to sign message:", t), ge.signFailed(t);
        }
    }
    /**
   * Get list of available wallets (installed/accessible)
   */ async getAvailableWallets() {
        const e = [];
        for (const t of this.adapters.values())try {
            await t.isAvailable() && e.push(t);
        } catch (n) {
            this.logger.warn(`Failed to check availability for ${t.name}:`, n);
        }
        return e;
    }
    /**
   * Get current connection state
   */ get connected() {
        return this.currentAdapter !== null && this.currentAccount !== null;
    }
    /**
   * Get current account
   */ get account() {
        return this.currentAccount;
    }
    /**
   * Get current wallet adapter
   */ get wallet() {
        return this.currentAdapter;
    }
    /**
   * Get all registered adapters
   */ get wallets() {
        return Array.from(this.adapters.values());
    }
    /**
   * Handle adapter disconnect event
   */ async handleAdapterDisconnect() {
        this.logger.info("Wallet disconnected (adapter event)"), await this.cleanup(), this.emit("disconnect");
    }
    /**
   * Handle account changed event
   */ handleAccountChanged(e) {
        this.logger.info("Account changed", e), this.currentAccount = e, this.emit("accountChanged", e);
    }
    /**
   * Handle network changed event
   */ handleNetworkChanged(e) {
        this.logger.info("Network changed", e), this.currentAccount && (this.currentAccount.network = e), this.emit("networkChanged", e);
    }
    /**
   * Cleanup connection state
   */ async cleanup() {
        this.currentAdapter = null, this.currentAccount = null, await this.storage.clearState();
    }
}
var ye = {}, nc = {};
nc.byteLength = Tb;
nc.toByteArray = _b;
nc.fromByteArray = Ob;
var Vr = [], pr = [], xb = typeof Uint8Array < "u" ? Uint8Array : Array, ru = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var Pi = 0, Ib = ru.length; Pi < Ib; ++Pi)Vr[Pi] = ru[Pi], pr[ru.charCodeAt(Pi)] = Pi;
pr[45] = 62;
pr[95] = 63;
function $0(r) {
    var e = r.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var t = r.indexOf("=");
    t === -1 && (t = e);
    var n = t === e ? 0 : 4 - t % 4;
    return [
        t,
        n
    ];
}
function Tb(r) {
    var e = $0(r), t = e[0], n = e[1];
    return (t + n) * 3 / 4 - n;
}
function Db(r, e, t) {
    return (e + t) * 3 / 4 - t;
}
function _b(r) {
    var e, t = $0(r), n = t[0], s = t[1], i = new xb(Db(r, n, s)), o = 0, a = s > 0 ? n - 4 : n, u;
    for(u = 0; u < a; u += 4)e = pr[r.charCodeAt(u)] << 18 | pr[r.charCodeAt(u + 1)] << 12 | pr[r.charCodeAt(u + 2)] << 6 | pr[r.charCodeAt(u + 3)], i[o++] = e >> 16 & 255, i[o++] = e >> 8 & 255, i[o++] = e & 255;
    return s === 2 && (e = pr[r.charCodeAt(u)] << 2 | pr[r.charCodeAt(u + 1)] >> 4, i[o++] = e & 255), s === 1 && (e = pr[r.charCodeAt(u)] << 10 | pr[r.charCodeAt(u + 1)] << 4 | pr[r.charCodeAt(u + 2)] >> 2, i[o++] = e >> 8 & 255, i[o++] = e & 255), i;
}
function Ab(r) {
    return Vr[r >> 18 & 63] + Vr[r >> 12 & 63] + Vr[r >> 6 & 63] + Vr[r & 63];
}
function Sb(r, e, t) {
    for(var n, s = [], i = e; i < t; i += 3)n = (r[i] << 16 & 16711680) + (r[i + 1] << 8 & 65280) + (r[i + 2] & 255), s.push(Ab(n));
    return s.join("");
}
function Ob(r) {
    for(var e, t = r.length, n = t % 3, s = [], i = 16383, o = 0, a = t - n; o < a; o += i)s.push(Sb(r, o, o + i > a ? a : o + i));
    return n === 1 ? (e = r[t - 1], s.push(Vr[e >> 2] + Vr[e << 4 & 63] + "==")) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], s.push(Vr[e >> 10] + Vr[e >> 4 & 63] + Vr[e << 2 & 63] + "=")), s.join("");
}
var bd = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ bd.read = function(r, e, t, n, s) {
    var i, o, a = s * 8 - n - 1, u = (1 << a) - 1, c = u >> 1, l = -7, d = t ? s - 1 : 0, h = t ? -1 : 1, f = r[e + d];
    for(d += h, i = f & (1 << -l) - 1, f >>= -l, l += a; l > 0; i = i * 256 + r[e + d], d += h, l -= 8);
    for(o = i & (1 << -l) - 1, i >>= -l, l += n; l > 0; o = o * 256 + r[e + d], d += h, l -= 8);
    if (i === 0) i = 1 - c;
    else {
        if (i === u) return o ? NaN : (f ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, n), i = i - c;
    }
    return (f ? -1 : 1) * o * Math.pow(2, i - n);
};
bd.write = function(r, e, t, n, s, i) {
    var o, a, u, c = i * 8 - s - 1, l = (1 << c) - 1, d = l >> 1, h = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : i - 1, g = n ? 1 : -1, p = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for(e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = l) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), o + d >= 1 ? e += h / u : e += h * Math.pow(2, 1 - d), e * u >= 2 && (o++, u /= 2), o + d >= l ? (a = 0, o = l) : o + d >= 1 ? (a = (e * u - 1) * Math.pow(2, s), o = o + d) : (a = e * Math.pow(2, d - 1) * Math.pow(2, s), o = 0)); s >= 8; r[t + f] = a & 255, f += g, a /= 256, s -= 8);
    for(o = o << s | a, c += s; c > 0; r[t + f] = o & 255, f += g, o /= 256, c -= 8);
    r[t + f - g] |= p * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function(r) {
    const e = nc, t = bd, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    r.Buffer = a, r.SlowBuffer = _, r.INSPECT_MAX_BYTES = 50;
    const s = 2147483647;
    r.kMaxLength = s, a.TYPED_ARRAY_SUPPORT = i(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function i() {
        try {
            const j = new Uint8Array(1), b = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(b, Uint8Array.prototype), Object.setPrototypeOf(j, b), j.foo() === 42;
        } catch  {
            return !1;
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this)) return this.buffer;
        }
    }), Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this)) return this.byteOffset;
        }
    });
    function o(j) {
        if (j > s) throw new RangeError('The value "' + j + '" is invalid for option "size"');
        const b = new Uint8Array(j);
        return Object.setPrototypeOf(b, a.prototype), b;
    }
    function a(j, b, E) {
        if (typeof j == "number") {
            if (typeof b == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return d(j);
        }
        return u(j, b, E);
    }
    a.poolSize = 8192;
    function u(j, b, E) {
        if (typeof j == "string") return h(j, b);
        if (ArrayBuffer.isView(j)) return g(j);
        if (j == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof j);
        if (xe(j, ArrayBuffer) || j && xe(j.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (xe(j, SharedArrayBuffer) || j && xe(j.buffer, SharedArrayBuffer))) return p(j, b, E);
        if (typeof j == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const k = j.valueOf && j.valueOf();
        if (k != null && k !== j) return a.from(k, b, E);
        const q = m(j);
        if (q) return q;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof j[Symbol.toPrimitive] == "function") return a.from(j[Symbol.toPrimitive]("string"), b, E);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof j);
    }
    a.from = function(j, b, E) {
        return u(j, b, E);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function c(j) {
        if (typeof j != "number") throw new TypeError('"size" argument must be of type number');
        if (j < 0) throw new RangeError('The value "' + j + '" is invalid for option "size"');
    }
    function l(j, b, E) {
        return c(j), j <= 0 ? o(j) : b !== void 0 ? typeof E == "string" ? o(j).fill(b, E) : o(j).fill(b) : o(j);
    }
    a.alloc = function(j, b, E) {
        return l(j, b, E);
    };
    function d(j) {
        return c(j), o(j < 0 ? 0 : x(j) | 0);
    }
    a.allocUnsafe = function(j) {
        return d(j);
    }, a.allocUnsafeSlow = function(j) {
        return d(j);
    };
    function h(j, b) {
        if ((typeof b != "string" || b === "") && (b = "utf8"), !a.isEncoding(b)) throw new TypeError("Unknown encoding: " + b);
        const E = v(j, b) | 0;
        let k = o(E);
        const q = k.write(j, b);
        return q !== E && (k = k.slice(0, q)), k;
    }
    function f(j) {
        const b = j.length < 0 ? 0 : x(j.length) | 0, E = o(b);
        for(let k = 0; k < b; k += 1)E[k] = j[k] & 255;
        return E;
    }
    function g(j) {
        if (xe(j, Uint8Array)) {
            const b = new Uint8Array(j);
            return p(b.buffer, b.byteOffset, b.byteLength);
        }
        return f(j);
    }
    function p(j, b, E) {
        if (b < 0 || j.byteLength < b) throw new RangeError('"offset" is outside of buffer bounds');
        if (j.byteLength < b + (E || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let k;
        return b === void 0 && E === void 0 ? k = new Uint8Array(j) : E === void 0 ? k = new Uint8Array(j, b) : k = new Uint8Array(j, b, E), Object.setPrototypeOf(k, a.prototype), k;
    }
    function m(j) {
        if (a.isBuffer(j)) {
            const b = x(j.length) | 0, E = o(b);
            return E.length === 0 || j.copy(E, 0, 0, b), E;
        }
        if (j.length !== void 0) return typeof j.length != "number" || He(j.length) ? o(0) : f(j);
        if (j.type === "Buffer" && Array.isArray(j.data)) return f(j.data);
    }
    function x(j) {
        if (j >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
        return j | 0;
    }
    function _(j) {
        return +j != j && (j = 0), a.alloc(+j);
    }
    a.isBuffer = function(b) {
        return b != null && b._isBuffer === !0 && b !== a.prototype;
    }, a.compare = function(b, E) {
        if (xe(b, Uint8Array) && (b = a.from(b, b.offset, b.byteLength)), xe(E, Uint8Array) && (E = a.from(E, E.offset, E.byteLength)), !a.isBuffer(b) || !a.isBuffer(E)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (b === E) return 0;
        let k = b.length, q = E.length;
        for(let X = 0, re = Math.min(k, q); X < re; ++X)if (b[X] !== E[X]) {
            k = b[X], q = E[X];
            break;
        }
        return k < q ? -1 : q < k ? 1 : 0;
    }, a.isEncoding = function(b) {
        switch(String(b).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, a.concat = function(b, E) {
        if (!Array.isArray(b)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (b.length === 0) return a.alloc(0);
        let k;
        if (E === void 0) for(E = 0, k = 0; k < b.length; ++k)E += b[k].length;
        const q = a.allocUnsafe(E);
        let X = 0;
        for(k = 0; k < b.length; ++k){
            let re = b[k];
            if (xe(re, Uint8Array)) X + re.length > q.length ? (a.isBuffer(re) || (re = a.from(re)), re.copy(q, X)) : Uint8Array.prototype.set.call(q, re, X);
            else if (a.isBuffer(re)) re.copy(q, X);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            X += re.length;
        }
        return q;
    };
    function v(j, b) {
        if (a.isBuffer(j)) return j.length;
        if (ArrayBuffer.isView(j) || xe(j, ArrayBuffer)) return j.byteLength;
        if (typeof j != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof j);
        const E = j.length, k = arguments.length > 2 && arguments[2] === !0;
        if (!k && E === 0) return 0;
        let q = !1;
        for(;;)switch(b){
            case "ascii":
            case "latin1":
            case "binary":
                return E;
            case "utf8":
            case "utf-8":
                return pe(j).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return E * 2;
            case "hex":
                return E >>> 1;
            case "base64":
                return _e(j).length;
            default:
                if (q) return k ? -1 : pe(j).length;
                b = ("" + b).toLowerCase(), q = !0;
        }
    }
    a.byteLength = v;
    function N(j, b, E) {
        let k = !1;
        if ((b === void 0 || b < 0) && (b = 0), b > this.length || ((E === void 0 || E > this.length) && (E = this.length), E <= 0) || (E >>>= 0, b >>>= 0, E <= b)) return "";
        for(j || (j = "utf8");;)switch(j){
            case "hex":
                return M(this, b, E);
            case "utf8":
            case "utf-8":
                return C(this, b, E);
            case "ascii":
                return y(this, b, E);
            case "latin1":
            case "binary":
                return w(this, b, E);
            case "base64":
                return B(this, b, E);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return D(this, b, E);
            default:
                if (k) throw new TypeError("Unknown encoding: " + j);
                j = (j + "").toLowerCase(), k = !0;
        }
    }
    a.prototype._isBuffer = !0;
    function O(j, b, E) {
        const k = j[b];
        j[b] = j[E], j[E] = k;
    }
    a.prototype.swap16 = function() {
        const b = this.length;
        if (b % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let E = 0; E < b; E += 2)O(this, E, E + 1);
        return this;
    }, a.prototype.swap32 = function() {
        const b = this.length;
        if (b % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let E = 0; E < b; E += 4)O(this, E, E + 3), O(this, E + 1, E + 2);
        return this;
    }, a.prototype.swap64 = function() {
        const b = this.length;
        if (b % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let E = 0; E < b; E += 8)O(this, E, E + 7), O(this, E + 1, E + 6), O(this, E + 2, E + 5), O(this, E + 3, E + 4);
        return this;
    }, a.prototype.toString = function() {
        const b = this.length;
        return b === 0 ? "" : arguments.length === 0 ? C(this, 0, b) : N.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(b) {
        if (!a.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        return this === b ? !0 : a.compare(this, b) === 0;
    }, a.prototype.inspect = function() {
        let b = "";
        const E = r.INSPECT_MAX_BYTES;
        return b = this.toString("hex", 0, E).replace(/(.{2})/g, "$1 ").trim(), this.length > E && (b += " ... "), "<Buffer " + b + ">";
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(b, E, k, q, X) {
        if (xe(b, Uint8Array) && (b = a.from(b, b.offset, b.byteLength)), !a.isBuffer(b)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof b);
        if (E === void 0 && (E = 0), k === void 0 && (k = b ? b.length : 0), q === void 0 && (q = 0), X === void 0 && (X = this.length), E < 0 || k > b.length || q < 0 || X > this.length) throw new RangeError("out of range index");
        if (q >= X && E >= k) return 0;
        if (q >= X) return -1;
        if (E >= k) return 1;
        if (E >>>= 0, k >>>= 0, q >>>= 0, X >>>= 0, this === b) return 0;
        let re = X - q, Ee = k - E;
        const Re = Math.min(re, Ee), Se = this.slice(q, X), et = b.slice(E, k);
        for(let Fe = 0; Fe < Re; ++Fe)if (Se[Fe] !== et[Fe]) {
            re = Se[Fe], Ee = et[Fe];
            break;
        }
        return re < Ee ? -1 : Ee < re ? 1 : 0;
    };
    function z(j, b, E, k, q) {
        if (j.length === 0) return -1;
        if (typeof E == "string" ? (k = E, E = 0) : E > 2147483647 ? E = 2147483647 : E < -2147483648 && (E = -2147483648), E = +E, He(E) && (E = q ? 0 : j.length - 1), E < 0 && (E = j.length + E), E >= j.length) {
            if (q) return -1;
            E = j.length - 1;
        } else if (E < 0) if (q) E = 0;
        else return -1;
        if (typeof b == "string" && (b = a.from(b, k)), a.isBuffer(b)) return b.length === 0 ? -1 : P(j, b, E, k, q);
        if (typeof b == "number") return b = b & 255, typeof Uint8Array.prototype.indexOf == "function" ? q ? Uint8Array.prototype.indexOf.call(j, b, E) : Uint8Array.prototype.lastIndexOf.call(j, b, E) : P(j, [
            b
        ], E, k, q);
        throw new TypeError("val must be string, number or Buffer");
    }
    function P(j, b, E, k, q) {
        let X = 1, re = j.length, Ee = b.length;
        if (k !== void 0 && (k = String(k).toLowerCase(), k === "ucs2" || k === "ucs-2" || k === "utf16le" || k === "utf-16le")) {
            if (j.length < 2 || b.length < 2) return -1;
            X = 2, re /= 2, Ee /= 2, E /= 2;
        }
        function Re(et, Fe) {
            return X === 1 ? et[Fe] : et.readUInt16BE(Fe * X);
        }
        let Se;
        if (q) {
            let et = -1;
            for(Se = E; Se < re; Se++)if (Re(j, Se) === Re(b, et === -1 ? 0 : Se - et)) {
                if (et === -1 && (et = Se), Se - et + 1 === Ee) return et * X;
            } else et !== -1 && (Se -= Se - et), et = -1;
        } else for(E + Ee > re && (E = re - Ee), Se = E; Se >= 0; Se--){
            let et = !0;
            for(let Fe = 0; Fe < Ee; Fe++)if (Re(j, Se + Fe) !== Re(b, Fe)) {
                et = !1;
                break;
            }
            if (et) return Se;
        }
        return -1;
    }
    a.prototype.includes = function(b, E, k) {
        return this.indexOf(b, E, k) !== -1;
    }, a.prototype.indexOf = function(b, E, k) {
        return z(this, b, E, k, !0);
    }, a.prototype.lastIndexOf = function(b, E, k) {
        return z(this, b, E, k, !1);
    };
    function U(j, b, E, k) {
        E = Number(E) || 0;
        const q = j.length - E;
        k ? (k = Number(k), k > q && (k = q)) : k = q;
        const X = b.length;
        k > X / 2 && (k = X / 2);
        let re;
        for(re = 0; re < k; ++re){
            const Ee = parseInt(b.substr(re * 2, 2), 16);
            if (He(Ee)) return re;
            j[E + re] = Ee;
        }
        return re;
    }
    function R(j, b, E, k) {
        return Ie(pe(b, j.length - E), j, E, k);
    }
    function G(j, b, E, k) {
        return Ie(be(b), j, E, k);
    }
    function F(j, b, E, k) {
        return Ie(_e(b), j, E, k);
    }
    function H(j, b, E, k) {
        return Ie(ve(b, j.length - E), j, E, k);
    }
    a.prototype.write = function(b, E, k, q) {
        if (E === void 0) q = "utf8", k = this.length, E = 0;
        else if (k === void 0 && typeof E == "string") q = E, k = this.length, E = 0;
        else if (isFinite(E)) E = E >>> 0, isFinite(k) ? (k = k >>> 0, q === void 0 && (q = "utf8")) : (q = k, k = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const X = this.length - E;
        if ((k === void 0 || k > X) && (k = X), b.length > 0 && (k < 0 || E < 0) || E > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        q || (q = "utf8");
        let re = !1;
        for(;;)switch(q){
            case "hex":
                return U(this, b, E, k);
            case "utf8":
            case "utf-8":
                return R(this, b, E, k);
            case "ascii":
            case "latin1":
            case "binary":
                return G(this, b, E, k);
            case "base64":
                return F(this, b, E, k);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return H(this, b, E, k);
            default:
                if (re) throw new TypeError("Unknown encoding: " + q);
                q = ("" + q).toLowerCase(), re = !0;
        }
    }, a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function B(j, b, E) {
        return b === 0 && E === j.length ? e.fromByteArray(j) : e.fromByteArray(j.slice(b, E));
    }
    function C(j, b, E) {
        E = Math.min(j.length, E);
        const k = [];
        let q = b;
        for(; q < E;){
            const X = j[q];
            let re = null, Ee = X > 239 ? 4 : X > 223 ? 3 : X > 191 ? 2 : 1;
            if (q + Ee <= E) {
                let Re, Se, et, Fe;
                switch(Ee){
                    case 1:
                        X < 128 && (re = X);
                        break;
                    case 2:
                        Re = j[q + 1], (Re & 192) === 128 && (Fe = (X & 31) << 6 | Re & 63, Fe > 127 && (re = Fe));
                        break;
                    case 3:
                        Re = j[q + 1], Se = j[q + 2], (Re & 192) === 128 && (Se & 192) === 128 && (Fe = (X & 15) << 12 | (Re & 63) << 6 | Se & 63, Fe > 2047 && (Fe < 55296 || Fe > 57343) && (re = Fe));
                        break;
                    case 4:
                        Re = j[q + 1], Se = j[q + 2], et = j[q + 3], (Re & 192) === 128 && (Se & 192) === 128 && (et & 192) === 128 && (Fe = (X & 15) << 18 | (Re & 63) << 12 | (Se & 63) << 6 | et & 63, Fe > 65535 && Fe < 1114112 && (re = Fe));
                }
            }
            re === null ? (re = 65533, Ee = 1) : re > 65535 && (re -= 65536, k.push(re >>> 10 & 1023 | 55296), re = 56320 | re & 1023), k.push(re), q += Ee;
        }
        return I(k);
    }
    const T = 4096;
    function I(j) {
        const b = j.length;
        if (b <= T) return String.fromCharCode.apply(String, j);
        let E = "", k = 0;
        for(; k < b;)E += String.fromCharCode.apply(String, j.slice(k, k += T));
        return E;
    }
    function y(j, b, E) {
        let k = "";
        E = Math.min(j.length, E);
        for(let q = b; q < E; ++q)k += String.fromCharCode(j[q] & 127);
        return k;
    }
    function w(j, b, E) {
        let k = "";
        E = Math.min(j.length, E);
        for(let q = b; q < E; ++q)k += String.fromCharCode(j[q]);
        return k;
    }
    function M(j, b, E) {
        const k = j.length;
        (!b || b < 0) && (b = 0), (!E || E < 0 || E > k) && (E = k);
        let q = "";
        for(let X = b; X < E; ++X)q += Qe[j[X]];
        return q;
    }
    function D(j, b, E) {
        const k = j.slice(b, E);
        let q = "";
        for(let X = 0; X < k.length - 1; X += 2)q += String.fromCharCode(k[X] + k[X + 1] * 256);
        return q;
    }
    a.prototype.slice = function(b, E) {
        const k = this.length;
        b = ~~b, E = E === void 0 ? k : ~~E, b < 0 ? (b += k, b < 0 && (b = 0)) : b > k && (b = k), E < 0 ? (E += k, E < 0 && (E = 0)) : E > k && (E = k), E < b && (E = b);
        const q = this.subarray(b, E);
        return Object.setPrototypeOf(q, a.prototype), q;
    };
    function A(j, b, E) {
        if (j % 1 !== 0 || j < 0) throw new RangeError("offset is not uint");
        if (j + b > E) throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(b, E, k) {
        b = b >>> 0, E = E >>> 0, k || A(b, E, this.length);
        let q = this[b], X = 1, re = 0;
        for(; ++re < E && (X *= 256);)q += this[b + re] * X;
        return q;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(b, E, k) {
        b = b >>> 0, E = E >>> 0, k || A(b, E, this.length);
        let q = this[b + --E], X = 1;
        for(; E > 0 && (X *= 256);)q += this[b + --E] * X;
        return q;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(b, E) {
        return b = b >>> 0, E || A(b, 1, this.length), this[b];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(b, E) {
        return b = b >>> 0, E || A(b, 2, this.length), this[b] | this[b + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(b, E) {
        return b = b >>> 0, E || A(b, 2, this.length), this[b] << 8 | this[b + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(b, E) {
        return b = b >>> 0, E || A(b, 4, this.length), (this[b] | this[b + 1] << 8 | this[b + 2] << 16) + this[b + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(b, E) {
        return b = b >>> 0, E || A(b, 4, this.length), this[b] * 16777216 + (this[b + 1] << 16 | this[b + 2] << 8 | this[b + 3]);
    }, a.prototype.readBigUInt64LE = De(function(b) {
        b = b >>> 0, Z(b, "offset");
        const E = this[b], k = this[b + 7];
        (E === void 0 || k === void 0) && W(b, this.length - 8);
        const q = E + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + this[++b] * 2 ** 24, X = this[++b] + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + k * 2 ** 24;
        return BigInt(q) + (BigInt(X) << BigInt(32));
    }), a.prototype.readBigUInt64BE = De(function(b) {
        b = b >>> 0, Z(b, "offset");
        const E = this[b], k = this[b + 7];
        (E === void 0 || k === void 0) && W(b, this.length - 8);
        const q = E * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + this[++b], X = this[++b] * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + k;
        return (BigInt(q) << BigInt(32)) + BigInt(X);
    }), a.prototype.readIntLE = function(b, E, k) {
        b = b >>> 0, E = E >>> 0, k || A(b, E, this.length);
        let q = this[b], X = 1, re = 0;
        for(; ++re < E && (X *= 256);)q += this[b + re] * X;
        return X *= 128, q >= X && (q -= Math.pow(2, 8 * E)), q;
    }, a.prototype.readIntBE = function(b, E, k) {
        b = b >>> 0, E = E >>> 0, k || A(b, E, this.length);
        let q = E, X = 1, re = this[b + --q];
        for(; q > 0 && (X *= 256);)re += this[b + --q] * X;
        return X *= 128, re >= X && (re -= Math.pow(2, 8 * E)), re;
    }, a.prototype.readInt8 = function(b, E) {
        return b = b >>> 0, E || A(b, 1, this.length), this[b] & 128 ? (255 - this[b] + 1) * -1 : this[b];
    }, a.prototype.readInt16LE = function(b, E) {
        b = b >>> 0, E || A(b, 2, this.length);
        const k = this[b] | this[b + 1] << 8;
        return k & 32768 ? k | 4294901760 : k;
    }, a.prototype.readInt16BE = function(b, E) {
        b = b >>> 0, E || A(b, 2, this.length);
        const k = this[b + 1] | this[b] << 8;
        return k & 32768 ? k | 4294901760 : k;
    }, a.prototype.readInt32LE = function(b, E) {
        return b = b >>> 0, E || A(b, 4, this.length), this[b] | this[b + 1] << 8 | this[b + 2] << 16 | this[b + 3] << 24;
    }, a.prototype.readInt32BE = function(b, E) {
        return b = b >>> 0, E || A(b, 4, this.length), this[b] << 24 | this[b + 1] << 16 | this[b + 2] << 8 | this[b + 3];
    }, a.prototype.readBigInt64LE = De(function(b) {
        b = b >>> 0, Z(b, "offset");
        const E = this[b], k = this[b + 7];
        (E === void 0 || k === void 0) && W(b, this.length - 8);
        const q = this[b + 4] + this[b + 5] * 2 ** 8 + this[b + 6] * 2 ** 16 + (k << 24);
        return (BigInt(q) << BigInt(32)) + BigInt(E + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + this[++b] * 2 ** 24);
    }), a.prototype.readBigInt64BE = De(function(b) {
        b = b >>> 0, Z(b, "offset");
        const E = this[b], k = this[b + 7];
        (E === void 0 || k === void 0) && W(b, this.length - 8);
        const q = (E << 24) + // Overflow
        this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + this[++b];
        return (BigInt(q) << BigInt(32)) + BigInt(this[++b] * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + k);
    }), a.prototype.readFloatLE = function(b, E) {
        return b = b >>> 0, E || A(b, 4, this.length), t.read(this, b, !0, 23, 4);
    }, a.prototype.readFloatBE = function(b, E) {
        return b = b >>> 0, E || A(b, 4, this.length), t.read(this, b, !1, 23, 4);
    }, a.prototype.readDoubleLE = function(b, E) {
        return b = b >>> 0, E || A(b, 8, this.length), t.read(this, b, !0, 52, 8);
    }, a.prototype.readDoubleBE = function(b, E) {
        return b = b >>> 0, E || A(b, 8, this.length), t.read(this, b, !1, 52, 8);
    };
    function L(j, b, E, k, q, X) {
        if (!a.isBuffer(j)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (b > q || b < X) throw new RangeError('"value" argument is out of bounds');
        if (E + k > j.length) throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(b, E, k, q) {
        if (b = +b, E = E >>> 0, k = k >>> 0, !q) {
            const Ee = Math.pow(2, 8 * k) - 1;
            L(this, b, E, k, Ee, 0);
        }
        let X = 1, re = 0;
        for(this[E] = b & 255; ++re < k && (X *= 256);)this[E + re] = b / X & 255;
        return E + k;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(b, E, k, q) {
        if (b = +b, E = E >>> 0, k = k >>> 0, !q) {
            const Ee = Math.pow(2, 8 * k) - 1;
            L(this, b, E, k, Ee, 0);
        }
        let X = k - 1, re = 1;
        for(this[E + X] = b & 255; --X >= 0 && (re *= 256);)this[E + X] = b / re & 255;
        return E + k;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 1, 255, 0), this[E] = b & 255, E + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 2, 65535, 0), this[E] = b & 255, this[E + 1] = b >>> 8, E + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 2, 65535, 0), this[E] = b >>> 8, this[E + 1] = b & 255, E + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 4, 4294967295, 0), this[E + 3] = b >>> 24, this[E + 2] = b >>> 16, this[E + 1] = b >>> 8, this[E] = b & 255, E + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 4, 4294967295, 0), this[E] = b >>> 24, this[E + 1] = b >>> 16, this[E + 2] = b >>> 8, this[E + 3] = b & 255, E + 4;
    };
    function V(j, b, E, k, q) {
        Q(b, k, q, j, E, 7);
        let X = Number(b & BigInt(4294967295));
        j[E++] = X, X = X >> 8, j[E++] = X, X = X >> 8, j[E++] = X, X = X >> 8, j[E++] = X;
        let re = Number(b >> BigInt(32) & BigInt(4294967295));
        return j[E++] = re, re = re >> 8, j[E++] = re, re = re >> 8, j[E++] = re, re = re >> 8, j[E++] = re, E;
    }
    function Y(j, b, E, k, q) {
        Q(b, k, q, j, E, 7);
        let X = Number(b & BigInt(4294967295));
        j[E + 7] = X, X = X >> 8, j[E + 6] = X, X = X >> 8, j[E + 5] = X, X = X >> 8, j[E + 4] = X;
        let re = Number(b >> BigInt(32) & BigInt(4294967295));
        return j[E + 3] = re, re = re >> 8, j[E + 2] = re, re = re >> 8, j[E + 1] = re, re = re >> 8, j[E] = re, E + 8;
    }
    a.prototype.writeBigUInt64LE = De(function(b, E = 0) {
        return V(this, b, E, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeBigUInt64BE = De(function(b, E = 0) {
        return Y(this, b, E, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeIntLE = function(b, E, k, q) {
        if (b = +b, E = E >>> 0, !q) {
            const Re = Math.pow(2, 8 * k - 1);
            L(this, b, E, k, Re - 1, -Re);
        }
        let X = 0, re = 1, Ee = 0;
        for(this[E] = b & 255; ++X < k && (re *= 256);)b < 0 && Ee === 0 && this[E + X - 1] !== 0 && (Ee = 1), this[E + X] = (b / re >> 0) - Ee & 255;
        return E + k;
    }, a.prototype.writeIntBE = function(b, E, k, q) {
        if (b = +b, E = E >>> 0, !q) {
            const Re = Math.pow(2, 8 * k - 1);
            L(this, b, E, k, Re - 1, -Re);
        }
        let X = k - 1, re = 1, Ee = 0;
        for(this[E + X] = b & 255; --X >= 0 && (re *= 256);)b < 0 && Ee === 0 && this[E + X + 1] !== 0 && (Ee = 1), this[E + X] = (b / re >> 0) - Ee & 255;
        return E + k;
    }, a.prototype.writeInt8 = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 1, 127, -128), b < 0 && (b = 255 + b + 1), this[E] = b & 255, E + 1;
    }, a.prototype.writeInt16LE = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 2, 32767, -32768), this[E] = b & 255, this[E + 1] = b >>> 8, E + 2;
    }, a.prototype.writeInt16BE = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 2, 32767, -32768), this[E] = b >>> 8, this[E + 1] = b & 255, E + 2;
    }, a.prototype.writeInt32LE = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 4, 2147483647, -2147483648), this[E] = b & 255, this[E + 1] = b >>> 8, this[E + 2] = b >>> 16, this[E + 3] = b >>> 24, E + 4;
    }, a.prototype.writeInt32BE = function(b, E, k) {
        return b = +b, E = E >>> 0, k || L(this, b, E, 4, 2147483647, -2147483648), b < 0 && (b = 4294967295 + b + 1), this[E] = b >>> 24, this[E + 1] = b >>> 16, this[E + 2] = b >>> 8, this[E + 3] = b & 255, E + 4;
    }, a.prototype.writeBigInt64LE = De(function(b, E = 0) {
        return V(this, b, E, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), a.prototype.writeBigInt64BE = De(function(b, E = 0) {
        return Y(this, b, E, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function K(j, b, E, k, q, X) {
        if (E + k > j.length) throw new RangeError("Index out of range");
        if (E < 0) throw new RangeError("Index out of range");
    }
    function J(j, b, E, k, q) {
        return b = +b, E = E >>> 0, q || K(j, b, E, 4), t.write(j, b, E, k, 23, 4), E + 4;
    }
    a.prototype.writeFloatLE = function(b, E, k) {
        return J(this, b, E, !0, k);
    }, a.prototype.writeFloatBE = function(b, E, k) {
        return J(this, b, E, !1, k);
    };
    function ne(j, b, E, k, q) {
        return b = +b, E = E >>> 0, q || K(j, b, E, 8), t.write(j, b, E, k, 52, 8), E + 8;
    }
    a.prototype.writeDoubleLE = function(b, E, k) {
        return ne(this, b, E, !0, k);
    }, a.prototype.writeDoubleBE = function(b, E, k) {
        return ne(this, b, E, !1, k);
    }, a.prototype.copy = function(b, E, k, q) {
        if (!a.isBuffer(b)) throw new TypeError("argument should be a Buffer");
        if (k || (k = 0), !q && q !== 0 && (q = this.length), E >= b.length && (E = b.length), E || (E = 0), q > 0 && q < k && (q = k), q === k || b.length === 0 || this.length === 0) return 0;
        if (E < 0) throw new RangeError("targetStart out of bounds");
        if (k < 0 || k >= this.length) throw new RangeError("Index out of range");
        if (q < 0) throw new RangeError("sourceEnd out of bounds");
        q > this.length && (q = this.length), b.length - E < q - k && (q = b.length - E + k);
        const X = q - k;
        return this === b && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(E, k, q) : Uint8Array.prototype.set.call(b, this.subarray(k, q), E), X;
    }, a.prototype.fill = function(b, E, k, q) {
        if (typeof b == "string") {
            if (typeof E == "string" ? (q = E, E = 0, k = this.length) : typeof k == "string" && (q = k, k = this.length), q !== void 0 && typeof q != "string") throw new TypeError("encoding must be a string");
            if (typeof q == "string" && !a.isEncoding(q)) throw new TypeError("Unknown encoding: " + q);
            if (b.length === 1) {
                const re = b.charCodeAt(0);
                (q === "utf8" && re < 128 || q === "latin1") && (b = re);
            }
        } else typeof b == "number" ? b = b & 255 : typeof b == "boolean" && (b = Number(b));
        if (E < 0 || this.length < E || this.length < k) throw new RangeError("Out of range index");
        if (k <= E) return this;
        E = E >>> 0, k = k === void 0 ? this.length : k >>> 0, b || (b = 0);
        let X;
        if (typeof b == "number") for(X = E; X < k; ++X)this[X] = b;
        else {
            const re = a.isBuffer(b) ? b : a.from(b, q), Ee = re.length;
            if (Ee === 0) throw new TypeError('The value "' + b + '" is invalid for argument "value"');
            for(X = 0; X < k - E; ++X)this[X + E] = re[X % Ee];
        }
        return this;
    };
    const ie = {};
    function oe(j, b, E) {
        ie[j] = class extends E {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: b.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${j}]`, this.stack, delete this.name;
            }
            get code() {
                return j;
            }
            set code(q) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: q,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${j}]: ${this.message}`;
            }
        };
    }
    oe("ERR_BUFFER_OUT_OF_BOUNDS", function(j) {
        return j ? `${j} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), oe("ERR_INVALID_ARG_TYPE", function(j, b) {
        return `The "${j}" argument must be of type number. Received type ${typeof b}`;
    }, TypeError), oe("ERR_OUT_OF_RANGE", function(j, b, E) {
        let k = `The value of "${j}" is out of range.`, q = E;
        return Number.isInteger(E) && Math.abs(E) > 2 ** 32 ? q = le(String(E)) : typeof E == "bigint" && (q = String(E), (E > BigInt(2) ** BigInt(32) || E < -(BigInt(2) ** BigInt(32))) && (q = le(q)), q += "n"), k += ` It must be ${b}. Received ${q}`, k;
    }, RangeError);
    function le(j) {
        let b = "", E = j.length;
        const k = j[0] === "-" ? 1 : 0;
        for(; E >= k + 4; E -= 3)b = `_${j.slice(E - 3, E)}${b}`;
        return `${j.slice(0, E)}${b}`;
    }
    function fe(j, b, E) {
        Z(b, "offset"), (j[b] === void 0 || j[b + E] === void 0) && W(b, j.length - (E + 1));
    }
    function Q(j, b, E, k, q, X) {
        if (j > E || j < b) {
            const re = typeof b == "bigint" ? "n" : "";
            let Ee;
            throw b === 0 || b === BigInt(0) ? Ee = `>= 0${re} and < 2${re} ** ${(X + 1) * 8}${re}` : Ee = `>= -(2${re} ** ${(X + 1) * 8 - 1}${re}) and < 2 ** ${(X + 1) * 8 - 1}${re}`, new ie.ERR_OUT_OF_RANGE("value", Ee, j);
        }
        fe(k, q, X);
    }
    function Z(j, b) {
        if (typeof j != "number") throw new ie.ERR_INVALID_ARG_TYPE(b, "number", j);
    }
    function W(j, b, E) {
        throw Math.floor(j) !== j ? (Z(j, E), new ie.ERR_OUT_OF_RANGE("offset", "an integer", j)) : b < 0 ? new ie.ERR_BUFFER_OUT_OF_BOUNDS() : new ie.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${b}`, j);
    }
    const ee = /[^+/0-9A-Za-z-_]/g;
    function se(j) {
        if (j = j.split("=")[0], j = j.trim().replace(ee, ""), j.length < 2) return "";
        for(; j.length % 4 !== 0;)j = j + "=";
        return j;
    }
    function pe(j, b) {
        b = b || 1 / 0;
        let E;
        const k = j.length;
        let q = null;
        const X = [];
        for(let re = 0; re < k; ++re){
            if (E = j.charCodeAt(re), E > 55295 && E < 57344) {
                if (!q) {
                    if (E > 56319) {
                        (b -= 3) > -1 && X.push(239, 191, 189);
                        continue;
                    } else if (re + 1 === k) {
                        (b -= 3) > -1 && X.push(239, 191, 189);
                        continue;
                    }
                    q = E;
                    continue;
                }
                if (E < 56320) {
                    (b -= 3) > -1 && X.push(239, 191, 189), q = E;
                    continue;
                }
                E = (q - 55296 << 10 | E - 56320) + 65536;
            } else q && (b -= 3) > -1 && X.push(239, 191, 189);
            if (q = null, E < 128) {
                if ((b -= 1) < 0) break;
                X.push(E);
            } else if (E < 2048) {
                if ((b -= 2) < 0) break;
                X.push(E >> 6 | 192, E & 63 | 128);
            } else if (E < 65536) {
                if ((b -= 3) < 0) break;
                X.push(E >> 12 | 224, E >> 6 & 63 | 128, E & 63 | 128);
            } else if (E < 1114112) {
                if ((b -= 4) < 0) break;
                X.push(E >> 18 | 240, E >> 12 & 63 | 128, E >> 6 & 63 | 128, E & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return X;
    }
    function be(j) {
        const b = [];
        for(let E = 0; E < j.length; ++E)b.push(j.charCodeAt(E) & 255);
        return b;
    }
    function ve(j, b) {
        let E, k, q;
        const X = [];
        for(let re = 0; re < j.length && !((b -= 2) < 0); ++re)E = j.charCodeAt(re), k = E >> 8, q = E % 256, X.push(q), X.push(k);
        return X;
    }
    function _e(j) {
        return e.toByteArray(se(j));
    }
    function Ie(j, b, E, k) {
        let q;
        for(q = 0; q < k && !(q + E >= b.length || q >= j.length); ++q)b[q + E] = j[q];
        return q;
    }
    function xe(j, b) {
        return j instanceof b || j != null && j.constructor != null && j.constructor.name != null && j.constructor.name === b.name;
    }
    function He(j) {
        return j !== j;
    }
    const Qe = function() {
        const j = "0123456789abcdef", b = new Array(256);
        for(let E = 0; E < 16; ++E){
            const k = E * 16;
            for(let q = 0; q < 16; ++q)b[k + q] = j[E] + j[q];
        }
        return b;
    }();
    function De(j) {
        return typeof BigInt > "u" ? Ae : j;
    }
    function Ae() {
        throw new Error("BigInt not supported");
    }
})(ye);
var B0 = {
    exports: {}
};
(function(r, e) {
    (function(t, n) {
        r.exports = n();
    })($, ()=>(()=>{
            var t = {
                873: (o, a)=>{
                    var u, c, l = function() {
                        var d = function(C, T) {
                            var I = C, y = x[T], w = null, M = 0, D = null, A = [], L = {}, V = function(Q, Z) {
                                w = function(W) {
                                    for(var ee = new Array(W), se = 0; se < W; se += 1){
                                        ee[se] = new Array(W);
                                        for(var pe = 0; pe < W; pe += 1)ee[se][pe] = null;
                                    }
                                    return ee;
                                }(M = 4 * I + 17), Y(0, 0), Y(M - 7, 0), Y(0, M - 7), J(), K(), ie(Q, Z), I >= 7 && ne(Q), D == null && (D = le(I, y, A)), oe(D, Z);
                            }, Y = function(Q, Z) {
                                for(var W = -1; W <= 7; W += 1)if (!(Q + W <= -1 || M <= Q + W)) for(var ee = -1; ee <= 7; ee += 1)Z + ee <= -1 || M <= Z + ee || (w[Q + W][Z + ee] = 0 <= W && W <= 6 && (ee == 0 || ee == 6) || 0 <= ee && ee <= 6 && (W == 0 || W == 6) || 2 <= W && W <= 4 && 2 <= ee && ee <= 4);
                            }, K = function() {
                                for(var Q = 8; Q < M - 8; Q += 1)w[Q][6] == null && (w[Q][6] = Q % 2 == 0);
                                for(var Z = 8; Z < M - 8; Z += 1)w[6][Z] == null && (w[6][Z] = Z % 2 == 0);
                            }, J = function() {
                                for(var Q = _.getPatternPosition(I), Z = 0; Z < Q.length; Z += 1)for(var W = 0; W < Q.length; W += 1){
                                    var ee = Q[Z], se = Q[W];
                                    if (w[ee][se] == null) for(var pe = -2; pe <= 2; pe += 1)for(var be = -2; be <= 2; be += 1)w[ee + pe][se + be] = pe == -2 || pe == 2 || be == -2 || be == 2 || pe == 0 && be == 0;
                                }
                            }, ne = function(Q) {
                                for(var Z = _.getBCHTypeNumber(I), W = 0; W < 18; W += 1){
                                    var ee = !Q && (Z >> W & 1) == 1;
                                    w[Math.floor(W / 3)][W % 3 + M - 8 - 3] = ee;
                                }
                                for(W = 0; W < 18; W += 1)ee = !Q && (Z >> W & 1) == 1, w[W % 3 + M - 8 - 3][Math.floor(W / 3)] = ee;
                            }, ie = function(Q, Z) {
                                for(var W = y << 3 | Z, ee = _.getBCHTypeInfo(W), se = 0; se < 15; se += 1){
                                    var pe = !Q && (ee >> se & 1) == 1;
                                    se < 6 ? w[se][8] = pe : se < 8 ? w[se + 1][8] = pe : w[M - 15 + se][8] = pe;
                                }
                                for(se = 0; se < 15; se += 1)pe = !Q && (ee >> se & 1) == 1, se < 8 ? w[8][M - se - 1] = pe : se < 9 ? w[8][15 - se - 1 + 1] = pe : w[8][15 - se - 1] = pe;
                                w[M - 8][8] = !Q;
                            }, oe = function(Q, Z) {
                                for(var W = -1, ee = M - 1, se = 7, pe = 0, be = _.getMaskFunction(Z), ve = M - 1; ve > 0; ve -= 2)for(ve == 6 && (ve -= 1);;){
                                    for(var _e = 0; _e < 2; _e += 1)if (w[ee][ve - _e] == null) {
                                        var Ie = !1;
                                        pe < Q.length && (Ie = (Q[pe] >>> se & 1) == 1), be(ee, ve - _e) && (Ie = !Ie), w[ee][ve - _e] = Ie, (se -= 1) == -1 && (pe += 1, se = 7);
                                    }
                                    if ((ee += W) < 0 || M <= ee) {
                                        ee -= W, W = -W;
                                        break;
                                    }
                                }
                            }, le = function(Q, Z, W) {
                                for(var ee = O.getRSBlocks(Q, Z), se = z(), pe = 0; pe < W.length; pe += 1){
                                    var be = W[pe];
                                    se.put(be.getMode(), 4), se.put(be.getLength(), _.getLengthInBits(be.getMode(), Q)), be.write(se);
                                }
                                var ve = 0;
                                for(pe = 0; pe < ee.length; pe += 1)ve += ee[pe].dataCount;
                                if (se.getLengthInBits() > 8 * ve) throw "code length overflow. (" + se.getLengthInBits() + ">" + 8 * ve + ")";
                                for(se.getLengthInBits() + 4 <= 8 * ve && se.put(0, 4); se.getLengthInBits() % 8 != 0;)se.putBit(!1);
                                for(; !(se.getLengthInBits() >= 8 * ve || (se.put(236, 8), se.getLengthInBits() >= 8 * ve));)se.put(17, 8);
                                return function(_e, Ie) {
                                    for(var xe = 0, He = 0, Qe = 0, De = new Array(Ie.length), Ae = new Array(Ie.length), j = 0; j < Ie.length; j += 1){
                                        var b = Ie[j].dataCount, E = Ie[j].totalCount - b;
                                        He = Math.max(He, b), Qe = Math.max(Qe, E), De[j] = new Array(b);
                                        for(var k = 0; k < De[j].length; k += 1)De[j][k] = 255 & _e.getBuffer()[k + xe];
                                        xe += b;
                                        var q = _.getErrorCorrectPolynomial(E), X = N(De[j], q.getLength() - 1).mod(q);
                                        for(Ae[j] = new Array(q.getLength() - 1), k = 0; k < Ae[j].length; k += 1){
                                            var re = k + X.getLength() - Ae[j].length;
                                            Ae[j][k] = re >= 0 ? X.getAt(re) : 0;
                                        }
                                    }
                                    var Ee = 0;
                                    for(k = 0; k < Ie.length; k += 1)Ee += Ie[k].totalCount;
                                    var Re = new Array(Ee), Se = 0;
                                    for(k = 0; k < He; k += 1)for(j = 0; j < Ie.length; j += 1)k < De[j].length && (Re[Se] = De[j][k], Se += 1);
                                    for(k = 0; k < Qe; k += 1)for(j = 0; j < Ie.length; j += 1)k < Ae[j].length && (Re[Se] = Ae[j][k], Se += 1);
                                    return Re;
                                }(se, ee);
                            };
                            L.addData = function(Q, Z) {
                                var W = null;
                                switch(Z = Z || "Byte"){
                                    case "Numeric":
                                        W = P(Q);
                                        break;
                                    case "Alphanumeric":
                                        W = U(Q);
                                        break;
                                    case "Byte":
                                        W = R(Q);
                                        break;
                                    case "Kanji":
                                        W = G(Q);
                                        break;
                                    default:
                                        throw "mode:" + Z;
                                }
                                A.push(W), D = null;
                            }, L.isDark = function(Q, Z) {
                                if (Q < 0 || M <= Q || Z < 0 || M <= Z) throw Q + "," + Z;
                                return w[Q][Z];
                            }, L.getModuleCount = function() {
                                return M;
                            }, L.make = function() {
                                if (I < 1) {
                                    for(var Q = 1; Q < 40; Q++){
                                        for(var Z = O.getRSBlocks(Q, y), W = z(), ee = 0; ee < A.length; ee++){
                                            var se = A[ee];
                                            W.put(se.getMode(), 4), W.put(se.getLength(), _.getLengthInBits(se.getMode(), Q)), se.write(W);
                                        }
                                        var pe = 0;
                                        for(ee = 0; ee < Z.length; ee++)pe += Z[ee].dataCount;
                                        if (W.getLengthInBits() <= 8 * pe) break;
                                    }
                                    I = Q;
                                }
                                V(!1, function() {
                                    for(var be = 0, ve = 0, _e = 0; _e < 8; _e += 1){
                                        V(!0, _e);
                                        var Ie = _.getLostPoint(L);
                                        (_e == 0 || be > Ie) && (be = Ie, ve = _e);
                                    }
                                    return ve;
                                }());
                            }, L.createTableTag = function(Q, Z) {
                                Q = Q || 2;
                                var W = "";
                                W += '<table style="', W += " border-width: 0px; border-style: none;", W += " border-collapse: collapse;", W += " padding: 0px; margin: " + (Z = Z === void 0 ? 4 * Q : Z) + "px;", W += '">', W += "<tbody>";
                                for(var ee = 0; ee < L.getModuleCount(); ee += 1){
                                    W += "<tr>";
                                    for(var se = 0; se < L.getModuleCount(); se += 1)W += '<td style="', W += " border-width: 0px; border-style: none;", W += " border-collapse: collapse;", W += " padding: 0px; margin: 0px;", W += " width: " + Q + "px;", W += " height: " + Q + "px;", W += " background-color: ", W += L.isDark(ee, se) ? "#000000" : "#ffffff", W += ";", W += '"/>';
                                    W += "</tr>";
                                }
                                return (W += "</tbody>") + "</table>";
                            }, L.createSvgTag = function(Q, Z, W, ee) {
                                var se = {};
                                typeof arguments[0] == "object" && (Q = (se = arguments[0]).cellSize, Z = se.margin, W = se.alt, ee = se.title), Q = Q || 2, Z = Z === void 0 ? 4 * Q : Z, (W = typeof W == "string" ? {
                                    text: W
                                } : W || {}).text = W.text || null, W.id = W.text ? W.id || "qrcode-description" : null, (ee = typeof ee == "string" ? {
                                    text: ee
                                } : ee || {}).text = ee.text || null, ee.id = ee.text ? ee.id || "qrcode-title" : null;
                                var pe, be, ve, _e, Ie = L.getModuleCount() * Q + 2 * Z, xe = "";
                                for(_e = "l" + Q + ",0 0," + Q + " -" + Q + ",0 0,-" + Q + "z ", xe += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', xe += se.scalable ? "" : ' width="' + Ie + 'px" height="' + Ie + 'px"', xe += ' viewBox="0 0 ' + Ie + " " + Ie + '" ', xe += ' preserveAspectRatio="xMinYMin meet"', xe += ee.text || W.text ? ' role="img" aria-labelledby="' + fe([
                                    ee.id,
                                    W.id
                                ].join(" ").trim()) + '"' : "", xe += ">", xe += ee.text ? '<title id="' + fe(ee.id) + '">' + fe(ee.text) + "</title>" : "", xe += W.text ? '<description id="' + fe(W.id) + '">' + fe(W.text) + "</description>" : "", xe += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', xe += '<path d="', be = 0; be < L.getModuleCount(); be += 1)for(ve = be * Q + Z, pe = 0; pe < L.getModuleCount(); pe += 1)L.isDark(be, pe) && (xe += "M" + (pe * Q + Z) + "," + ve + _e);
                                return (xe += '" stroke="transparent" fill="black"/>') + "</svg>";
                            }, L.createDataURL = function(Q, Z) {
                                Q = Q || 2, Z = Z === void 0 ? 4 * Q : Z;
                                var W = L.getModuleCount() * Q + 2 * Z, ee = Z, se = W - Z;
                                return B(W, W, function(pe, be) {
                                    if (ee <= pe && pe < se && ee <= be && be < se) {
                                        var ve = Math.floor((pe - ee) / Q), _e = Math.floor((be - ee) / Q);
                                        return L.isDark(_e, ve) ? 0 : 1;
                                    }
                                    return 1;
                                });
                            }, L.createImgTag = function(Q, Z, W) {
                                Q = Q || 2, Z = Z === void 0 ? 4 * Q : Z;
                                var ee = L.getModuleCount() * Q + 2 * Z, se = "";
                                return se += "<img", se += ' src="', se += L.createDataURL(Q, Z), se += '"', se += ' width="', se += ee, se += '"', se += ' height="', se += ee, se += '"', W && (se += ' alt="', se += fe(W), se += '"'), se + "/>";
                            };
                            var fe = function(Q) {
                                for(var Z = "", W = 0; W < Q.length; W += 1){
                                    var ee = Q.charAt(W);
                                    switch(ee){
                                        case "<":
                                            Z += "&lt;";
                                            break;
                                        case ">":
                                            Z += "&gt;";
                                            break;
                                        case "&":
                                            Z += "&amp;";
                                            break;
                                        case '"':
                                            Z += "&quot;";
                                            break;
                                        default:
                                            Z += ee;
                                    }
                                }
                                return Z;
                            };
                            return L.createASCII = function(Q, Z) {
                                if ((Q = Q || 1) < 2) return function(De) {
                                    De = De === void 0 ? 2 : De;
                                    var Ae, j, b, E, k, q = 1 * L.getModuleCount() + 2 * De, X = De, re = q - De, Ee = {
                                        "": "",
                                        " ": "",
                                        " ": "",
                                        "  ": " "
                                    }, Re = {
                                        "": "",
                                        " ": "",
                                        " ": " ",
                                        "  ": " "
                                    }, Se = "";
                                    for(Ae = 0; Ae < q; Ae += 2){
                                        for(b = Math.floor((Ae - X) / 1), E = Math.floor((Ae + 1 - X) / 1), j = 0; j < q; j += 1)k = "", X <= j && j < re && X <= Ae && Ae < re && L.isDark(b, Math.floor((j - X) / 1)) && (k = " "), X <= j && j < re && X <= Ae + 1 && Ae + 1 < re && L.isDark(E, Math.floor((j - X) / 1)) ? k += " " : k += "", Se += De < 1 && Ae + 1 >= re ? Re[k] : Ee[k];
                                        Se += `
`;
                                    }
                                    return q % 2 && De > 0 ? Se.substring(0, Se.length - q - 1) + Array(q + 1).join("") : Se.substring(0, Se.length - 1);
                                }(Z);
                                Q -= 1, Z = Z === void 0 ? 2 * Q : Z;
                                var W, ee, se, pe, be = L.getModuleCount() * Q + 2 * Z, ve = Z, _e = be - Z, Ie = Array(Q + 1).join(""), xe = Array(Q + 1).join("  "), He = "", Qe = "";
                                for(W = 0; W < be; W += 1){
                                    for(se = Math.floor((W - ve) / Q), Qe = "", ee = 0; ee < be; ee += 1)pe = 1, ve <= ee && ee < _e && ve <= W && W < _e && L.isDark(se, Math.floor((ee - ve) / Q)) && (pe = 0), Qe += pe ? Ie : xe;
                                    for(se = 0; se < Q; se += 1)He += Qe + `
`;
                                }
                                return He.substring(0, He.length - 1);
                            }, L.renderTo2dContext = function(Q, Z) {
                                Z = Z || 2;
                                for(var W = L.getModuleCount(), ee = 0; ee < W; ee++)for(var se = 0; se < W; se++)Q.fillStyle = L.isDark(ee, se) ? "black" : "white", Q.fillRect(ee * Z, se * Z, Z, Z);
                            }, L;
                        };
                        d.stringToBytes = (d.stringToBytesFuncs = {
                            default: function(C) {
                                for(var T = [], I = 0; I < C.length; I += 1){
                                    var y = C.charCodeAt(I);
                                    T.push(255 & y);
                                }
                                return T;
                            }
                        }).default, d.createStringToBytes = function(C, T) {
                            var I = function() {
                                for(var w = H(C), M = function() {
                                    var K = w.read();
                                    if (K == -1) throw "eof";
                                    return K;
                                }, D = 0, A = {};;){
                                    var L = w.read();
                                    if (L == -1) break;
                                    var V = M(), Y = M() << 8 | M();
                                    A[String.fromCharCode(L << 8 | V)] = Y, D += 1;
                                }
                                if (D != T) throw D + " != " + T;
                                return A;
                            }(), y = 63;
                            return function(w) {
                                for(var M = [], D = 0; D < w.length; D += 1){
                                    var A = w.charCodeAt(D);
                                    if (A < 128) M.push(A);
                                    else {
                                        var L = I[w.charAt(D)];
                                        typeof L == "number" ? (255 & L) == L ? M.push(L) : (M.push(L >>> 8), M.push(255 & L)) : M.push(y);
                                    }
                                }
                                return M;
                            };
                        };
                        var h, f, g, p, m, x = {
                            L: 1,
                            M: 0,
                            Q: 3,
                            H: 2
                        }, _ = (h = [
                            [],
                            [
                                6,
                                18
                            ],
                            [
                                6,
                                22
                            ],
                            [
                                6,
                                26
                            ],
                            [
                                6,
                                30
                            ],
                            [
                                6,
                                34
                            ],
                            [
                                6,
                                22,
                                38
                            ],
                            [
                                6,
                                24,
                                42
                            ],
                            [
                                6,
                                26,
                                46
                            ],
                            [
                                6,
                                28,
                                50
                            ],
                            [
                                6,
                                30,
                                54
                            ],
                            [
                                6,
                                32,
                                58
                            ],
                            [
                                6,
                                34,
                                62
                            ],
                            [
                                6,
                                26,
                                46,
                                66
                            ],
                            [
                                6,
                                26,
                                48,
                                70
                            ],
                            [
                                6,
                                26,
                                50,
                                74
                            ],
                            [
                                6,
                                30,
                                54,
                                78
                            ],
                            [
                                6,
                                30,
                                56,
                                82
                            ],
                            [
                                6,
                                30,
                                58,
                                86
                            ],
                            [
                                6,
                                34,
                                62,
                                90
                            ],
                            [
                                6,
                                28,
                                50,
                                72,
                                94
                            ],
                            [
                                6,
                                26,
                                50,
                                74,
                                98
                            ],
                            [
                                6,
                                30,
                                54,
                                78,
                                102
                            ],
                            [
                                6,
                                28,
                                54,
                                80,
                                106
                            ],
                            [
                                6,
                                32,
                                58,
                                84,
                                110
                            ],
                            [
                                6,
                                30,
                                58,
                                86,
                                114
                            ],
                            [
                                6,
                                34,
                                62,
                                90,
                                118
                            ],
                            [
                                6,
                                26,
                                50,
                                74,
                                98,
                                122
                            ],
                            [
                                6,
                                30,
                                54,
                                78,
                                102,
                                126
                            ],
                            [
                                6,
                                26,
                                52,
                                78,
                                104,
                                130
                            ],
                            [
                                6,
                                30,
                                56,
                                82,
                                108,
                                134
                            ],
                            [
                                6,
                                34,
                                60,
                                86,
                                112,
                                138
                            ],
                            [
                                6,
                                30,
                                58,
                                86,
                                114,
                                142
                            ],
                            [
                                6,
                                34,
                                62,
                                90,
                                118,
                                146
                            ],
                            [
                                6,
                                30,
                                54,
                                78,
                                102,
                                126,
                                150
                            ],
                            [
                                6,
                                24,
                                50,
                                76,
                                102,
                                128,
                                154
                            ],
                            [
                                6,
                                28,
                                54,
                                80,
                                106,
                                132,
                                158
                            ],
                            [
                                6,
                                32,
                                58,
                                84,
                                110,
                                136,
                                162
                            ],
                            [
                                6,
                                26,
                                54,
                                82,
                                110,
                                138,
                                166
                            ],
                            [
                                6,
                                30,
                                58,
                                86,
                                114,
                                142,
                                170
                            ]
                        ], f = 1335, g = 7973, m = function(C) {
                            for(var T = 0; C != 0;)T += 1, C >>>= 1;
                            return T;
                        }, (p = {}).getBCHTypeInfo = function(C) {
                            for(var T = C << 10; m(T) - m(f) >= 0;)T ^= f << m(T) - m(f);
                            return 21522 ^ (C << 10 | T);
                        }, p.getBCHTypeNumber = function(C) {
                            for(var T = C << 12; m(T) - m(g) >= 0;)T ^= g << m(T) - m(g);
                            return C << 12 | T;
                        }, p.getPatternPosition = function(C) {
                            return h[C - 1];
                        }, p.getMaskFunction = function(C) {
                            switch(C){
                                case 0:
                                    return function(T, I) {
                                        return (T + I) % 2 == 0;
                                    };
                                case 1:
                                    return function(T, I) {
                                        return T % 2 == 0;
                                    };
                                case 2:
                                    return function(T, I) {
                                        return I % 3 == 0;
                                    };
                                case 3:
                                    return function(T, I) {
                                        return (T + I) % 3 == 0;
                                    };
                                case 4:
                                    return function(T, I) {
                                        return (Math.floor(T / 2) + Math.floor(I / 3)) % 2 == 0;
                                    };
                                case 5:
                                    return function(T, I) {
                                        return T * I % 2 + T * I % 3 == 0;
                                    };
                                case 6:
                                    return function(T, I) {
                                        return (T * I % 2 + T * I % 3) % 2 == 0;
                                    };
                                case 7:
                                    return function(T, I) {
                                        return (T * I % 3 + (T + I) % 2) % 2 == 0;
                                    };
                                default:
                                    throw "bad maskPattern:" + C;
                            }
                        }, p.getErrorCorrectPolynomial = function(C) {
                            for(var T = N([
                                1
                            ], 0), I = 0; I < C; I += 1)T = T.multiply(N([
                                1,
                                v.gexp(I)
                            ], 0));
                            return T;
                        }, p.getLengthInBits = function(C, T) {
                            if (1 <= T && T < 10) switch(C){
                                case 1:
                                    return 10;
                                case 2:
                                    return 9;
                                case 4:
                                case 8:
                                    return 8;
                                default:
                                    throw "mode:" + C;
                            }
                            else if (T < 27) switch(C){
                                case 1:
                                    return 12;
                                case 2:
                                    return 11;
                                case 4:
                                    return 16;
                                case 8:
                                    return 10;
                                default:
                                    throw "mode:" + C;
                            }
                            else {
                                if (!(T < 41)) throw "type:" + T;
                                switch(C){
                                    case 1:
                                        return 14;
                                    case 2:
                                        return 13;
                                    case 4:
                                        return 16;
                                    case 8:
                                        return 12;
                                    default:
                                        throw "mode:" + C;
                                }
                            }
                        }, p.getLostPoint = function(C) {
                            for(var T = C.getModuleCount(), I = 0, y = 0; y < T; y += 1)for(var w = 0; w < T; w += 1){
                                for(var M = 0, D = C.isDark(y, w), A = -1; A <= 1; A += 1)if (!(y + A < 0 || T <= y + A)) for(var L = -1; L <= 1; L += 1)w + L < 0 || T <= w + L || A == 0 && L == 0 || D == C.isDark(y + A, w + L) && (M += 1);
                                M > 5 && (I += 3 + M - 5);
                            }
                            for(y = 0; y < T - 1; y += 1)for(w = 0; w < T - 1; w += 1){
                                var V = 0;
                                C.isDark(y, w) && (V += 1), C.isDark(y + 1, w) && (V += 1), C.isDark(y, w + 1) && (V += 1), C.isDark(y + 1, w + 1) && (V += 1), V != 0 && V != 4 || (I += 3);
                            }
                            for(y = 0; y < T; y += 1)for(w = 0; w < T - 6; w += 1)C.isDark(y, w) && !C.isDark(y, w + 1) && C.isDark(y, w + 2) && C.isDark(y, w + 3) && C.isDark(y, w + 4) && !C.isDark(y, w + 5) && C.isDark(y, w + 6) && (I += 40);
                            for(w = 0; w < T; w += 1)for(y = 0; y < T - 6; y += 1)C.isDark(y, w) && !C.isDark(y + 1, w) && C.isDark(y + 2, w) && C.isDark(y + 3, w) && C.isDark(y + 4, w) && !C.isDark(y + 5, w) && C.isDark(y + 6, w) && (I += 40);
                            var Y = 0;
                            for(w = 0; w < T; w += 1)for(y = 0; y < T; y += 1)C.isDark(y, w) && (Y += 1);
                            return I + Math.abs(100 * Y / T / T - 50) / 5 * 10;
                        }, p), v = function() {
                            for(var C = new Array(256), T = new Array(256), I = 0; I < 8; I += 1)C[I] = 1 << I;
                            for(I = 8; I < 256; I += 1)C[I] = C[I - 4] ^ C[I - 5] ^ C[I - 6] ^ C[I - 8];
                            for(I = 0; I < 255; I += 1)T[C[I]] = I;
                            return {
                                glog: function(y) {
                                    if (y < 1) throw "glog(" + y + ")";
                                    return T[y];
                                },
                                gexp: function(y) {
                                    for(; y < 0;)y += 255;
                                    for(; y >= 256;)y -= 255;
                                    return C[y];
                                }
                            };
                        }();
                        function N(C, T) {
                            if (C.length === void 0) throw C.length + "/" + T;
                            var I = function() {
                                for(var w = 0; w < C.length && C[w] == 0;)w += 1;
                                for(var M = new Array(C.length - w + T), D = 0; D < C.length - w; D += 1)M[D] = C[D + w];
                                return M;
                            }(), y = {
                                getAt: function(w) {
                                    return I[w];
                                },
                                getLength: function() {
                                    return I.length;
                                },
                                multiply: function(w) {
                                    for(var M = new Array(y.getLength() + w.getLength() - 1), D = 0; D < y.getLength(); D += 1)for(var A = 0; A < w.getLength(); A += 1)M[D + A] ^= v.gexp(v.glog(y.getAt(D)) + v.glog(w.getAt(A)));
                                    return N(M, 0);
                                },
                                mod: function(w) {
                                    if (y.getLength() - w.getLength() < 0) return y;
                                    for(var M = v.glog(y.getAt(0)) - v.glog(w.getAt(0)), D = new Array(y.getLength()), A = 0; A < y.getLength(); A += 1)D[A] = y.getAt(A);
                                    for(A = 0; A < w.getLength(); A += 1)D[A] ^= v.gexp(v.glog(w.getAt(A)) + M);
                                    return N(D, 0).mod(w);
                                }
                            };
                            return y;
                        }
                        var O = /* @__PURE__ */ function() {
                            var C = [
                                [
                                    1,
                                    26,
                                    19
                                ],
                                [
                                    1,
                                    26,
                                    16
                                ],
                                [
                                    1,
                                    26,
                                    13
                                ],
                                [
                                    1,
                                    26,
                                    9
                                ],
                                [
                                    1,
                                    44,
                                    34
                                ],
                                [
                                    1,
                                    44,
                                    28
                                ],
                                [
                                    1,
                                    44,
                                    22
                                ],
                                [
                                    1,
                                    44,
                                    16
                                ],
                                [
                                    1,
                                    70,
                                    55
                                ],
                                [
                                    1,
                                    70,
                                    44
                                ],
                                [
                                    2,
                                    35,
                                    17
                                ],
                                [
                                    2,
                                    35,
                                    13
                                ],
                                [
                                    1,
                                    100,
                                    80
                                ],
                                [
                                    2,
                                    50,
                                    32
                                ],
                                [
                                    2,
                                    50,
                                    24
                                ],
                                [
                                    4,
                                    25,
                                    9
                                ],
                                [
                                    1,
                                    134,
                                    108
                                ],
                                [
                                    2,
                                    67,
                                    43
                                ],
                                [
                                    2,
                                    33,
                                    15,
                                    2,
                                    34,
                                    16
                                ],
                                [
                                    2,
                                    33,
                                    11,
                                    2,
                                    34,
                                    12
                                ],
                                [
                                    2,
                                    86,
                                    68
                                ],
                                [
                                    4,
                                    43,
                                    27
                                ],
                                [
                                    4,
                                    43,
                                    19
                                ],
                                [
                                    4,
                                    43,
                                    15
                                ],
                                [
                                    2,
                                    98,
                                    78
                                ],
                                [
                                    4,
                                    49,
                                    31
                                ],
                                [
                                    2,
                                    32,
                                    14,
                                    4,
                                    33,
                                    15
                                ],
                                [
                                    4,
                                    39,
                                    13,
                                    1,
                                    40,
                                    14
                                ],
                                [
                                    2,
                                    121,
                                    97
                                ],
                                [
                                    2,
                                    60,
                                    38,
                                    2,
                                    61,
                                    39
                                ],
                                [
                                    4,
                                    40,
                                    18,
                                    2,
                                    41,
                                    19
                                ],
                                [
                                    4,
                                    40,
                                    14,
                                    2,
                                    41,
                                    15
                                ],
                                [
                                    2,
                                    146,
                                    116
                                ],
                                [
                                    3,
                                    58,
                                    36,
                                    2,
                                    59,
                                    37
                                ],
                                [
                                    4,
                                    36,
                                    16,
                                    4,
                                    37,
                                    17
                                ],
                                [
                                    4,
                                    36,
                                    12,
                                    4,
                                    37,
                                    13
                                ],
                                [
                                    2,
                                    86,
                                    68,
                                    2,
                                    87,
                                    69
                                ],
                                [
                                    4,
                                    69,
                                    43,
                                    1,
                                    70,
                                    44
                                ],
                                [
                                    6,
                                    43,
                                    19,
                                    2,
                                    44,
                                    20
                                ],
                                [
                                    6,
                                    43,
                                    15,
                                    2,
                                    44,
                                    16
                                ],
                                [
                                    4,
                                    101,
                                    81
                                ],
                                [
                                    1,
                                    80,
                                    50,
                                    4,
                                    81,
                                    51
                                ],
                                [
                                    4,
                                    50,
                                    22,
                                    4,
                                    51,
                                    23
                                ],
                                [
                                    3,
                                    36,
                                    12,
                                    8,
                                    37,
                                    13
                                ],
                                [
                                    2,
                                    116,
                                    92,
                                    2,
                                    117,
                                    93
                                ],
                                [
                                    6,
                                    58,
                                    36,
                                    2,
                                    59,
                                    37
                                ],
                                [
                                    4,
                                    46,
                                    20,
                                    6,
                                    47,
                                    21
                                ],
                                [
                                    7,
                                    42,
                                    14,
                                    4,
                                    43,
                                    15
                                ],
                                [
                                    4,
                                    133,
                                    107
                                ],
                                [
                                    8,
                                    59,
                                    37,
                                    1,
                                    60,
                                    38
                                ],
                                [
                                    8,
                                    44,
                                    20,
                                    4,
                                    45,
                                    21
                                ],
                                [
                                    12,
                                    33,
                                    11,
                                    4,
                                    34,
                                    12
                                ],
                                [
                                    3,
                                    145,
                                    115,
                                    1,
                                    146,
                                    116
                                ],
                                [
                                    4,
                                    64,
                                    40,
                                    5,
                                    65,
                                    41
                                ],
                                [
                                    11,
                                    36,
                                    16,
                                    5,
                                    37,
                                    17
                                ],
                                [
                                    11,
                                    36,
                                    12,
                                    5,
                                    37,
                                    13
                                ],
                                [
                                    5,
                                    109,
                                    87,
                                    1,
                                    110,
                                    88
                                ],
                                [
                                    5,
                                    65,
                                    41,
                                    5,
                                    66,
                                    42
                                ],
                                [
                                    5,
                                    54,
                                    24,
                                    7,
                                    55,
                                    25
                                ],
                                [
                                    11,
                                    36,
                                    12,
                                    7,
                                    37,
                                    13
                                ],
                                [
                                    5,
                                    122,
                                    98,
                                    1,
                                    123,
                                    99
                                ],
                                [
                                    7,
                                    73,
                                    45,
                                    3,
                                    74,
                                    46
                                ],
                                [
                                    15,
                                    43,
                                    19,
                                    2,
                                    44,
                                    20
                                ],
                                [
                                    3,
                                    45,
                                    15,
                                    13,
                                    46,
                                    16
                                ],
                                [
                                    1,
                                    135,
                                    107,
                                    5,
                                    136,
                                    108
                                ],
                                [
                                    10,
                                    74,
                                    46,
                                    1,
                                    75,
                                    47
                                ],
                                [
                                    1,
                                    50,
                                    22,
                                    15,
                                    51,
                                    23
                                ],
                                [
                                    2,
                                    42,
                                    14,
                                    17,
                                    43,
                                    15
                                ],
                                [
                                    5,
                                    150,
                                    120,
                                    1,
                                    151,
                                    121
                                ],
                                [
                                    9,
                                    69,
                                    43,
                                    4,
                                    70,
                                    44
                                ],
                                [
                                    17,
                                    50,
                                    22,
                                    1,
                                    51,
                                    23
                                ],
                                [
                                    2,
                                    42,
                                    14,
                                    19,
                                    43,
                                    15
                                ],
                                [
                                    3,
                                    141,
                                    113,
                                    4,
                                    142,
                                    114
                                ],
                                [
                                    3,
                                    70,
                                    44,
                                    11,
                                    71,
                                    45
                                ],
                                [
                                    17,
                                    47,
                                    21,
                                    4,
                                    48,
                                    22
                                ],
                                [
                                    9,
                                    39,
                                    13,
                                    16,
                                    40,
                                    14
                                ],
                                [
                                    3,
                                    135,
                                    107,
                                    5,
                                    136,
                                    108
                                ],
                                [
                                    3,
                                    67,
                                    41,
                                    13,
                                    68,
                                    42
                                ],
                                [
                                    15,
                                    54,
                                    24,
                                    5,
                                    55,
                                    25
                                ],
                                [
                                    15,
                                    43,
                                    15,
                                    10,
                                    44,
                                    16
                                ],
                                [
                                    4,
                                    144,
                                    116,
                                    4,
                                    145,
                                    117
                                ],
                                [
                                    17,
                                    68,
                                    42
                                ],
                                [
                                    17,
                                    50,
                                    22,
                                    6,
                                    51,
                                    23
                                ],
                                [
                                    19,
                                    46,
                                    16,
                                    6,
                                    47,
                                    17
                                ],
                                [
                                    2,
                                    139,
                                    111,
                                    7,
                                    140,
                                    112
                                ],
                                [
                                    17,
                                    74,
                                    46
                                ],
                                [
                                    7,
                                    54,
                                    24,
                                    16,
                                    55,
                                    25
                                ],
                                [
                                    34,
                                    37,
                                    13
                                ],
                                [
                                    4,
                                    151,
                                    121,
                                    5,
                                    152,
                                    122
                                ],
                                [
                                    4,
                                    75,
                                    47,
                                    14,
                                    76,
                                    48
                                ],
                                [
                                    11,
                                    54,
                                    24,
                                    14,
                                    55,
                                    25
                                ],
                                [
                                    16,
                                    45,
                                    15,
                                    14,
                                    46,
                                    16
                                ],
                                [
                                    6,
                                    147,
                                    117,
                                    4,
                                    148,
                                    118
                                ],
                                [
                                    6,
                                    73,
                                    45,
                                    14,
                                    74,
                                    46
                                ],
                                [
                                    11,
                                    54,
                                    24,
                                    16,
                                    55,
                                    25
                                ],
                                [
                                    30,
                                    46,
                                    16,
                                    2,
                                    47,
                                    17
                                ],
                                [
                                    8,
                                    132,
                                    106,
                                    4,
                                    133,
                                    107
                                ],
                                [
                                    8,
                                    75,
                                    47,
                                    13,
                                    76,
                                    48
                                ],
                                [
                                    7,
                                    54,
                                    24,
                                    22,
                                    55,
                                    25
                                ],
                                [
                                    22,
                                    45,
                                    15,
                                    13,
                                    46,
                                    16
                                ],
                                [
                                    10,
                                    142,
                                    114,
                                    2,
                                    143,
                                    115
                                ],
                                [
                                    19,
                                    74,
                                    46,
                                    4,
                                    75,
                                    47
                                ],
                                [
                                    28,
                                    50,
                                    22,
                                    6,
                                    51,
                                    23
                                ],
                                [
                                    33,
                                    46,
                                    16,
                                    4,
                                    47,
                                    17
                                ],
                                [
                                    8,
                                    152,
                                    122,
                                    4,
                                    153,
                                    123
                                ],
                                [
                                    22,
                                    73,
                                    45,
                                    3,
                                    74,
                                    46
                                ],
                                [
                                    8,
                                    53,
                                    23,
                                    26,
                                    54,
                                    24
                                ],
                                [
                                    12,
                                    45,
                                    15,
                                    28,
                                    46,
                                    16
                                ],
                                [
                                    3,
                                    147,
                                    117,
                                    10,
                                    148,
                                    118
                                ],
                                [
                                    3,
                                    73,
                                    45,
                                    23,
                                    74,
                                    46
                                ],
                                [
                                    4,
                                    54,
                                    24,
                                    31,
                                    55,
                                    25
                                ],
                                [
                                    11,
                                    45,
                                    15,
                                    31,
                                    46,
                                    16
                                ],
                                [
                                    7,
                                    146,
                                    116,
                                    7,
                                    147,
                                    117
                                ],
                                [
                                    21,
                                    73,
                                    45,
                                    7,
                                    74,
                                    46
                                ],
                                [
                                    1,
                                    53,
                                    23,
                                    37,
                                    54,
                                    24
                                ],
                                [
                                    19,
                                    45,
                                    15,
                                    26,
                                    46,
                                    16
                                ],
                                [
                                    5,
                                    145,
                                    115,
                                    10,
                                    146,
                                    116
                                ],
                                [
                                    19,
                                    75,
                                    47,
                                    10,
                                    76,
                                    48
                                ],
                                [
                                    15,
                                    54,
                                    24,
                                    25,
                                    55,
                                    25
                                ],
                                [
                                    23,
                                    45,
                                    15,
                                    25,
                                    46,
                                    16
                                ],
                                [
                                    13,
                                    145,
                                    115,
                                    3,
                                    146,
                                    116
                                ],
                                [
                                    2,
                                    74,
                                    46,
                                    29,
                                    75,
                                    47
                                ],
                                [
                                    42,
                                    54,
                                    24,
                                    1,
                                    55,
                                    25
                                ],
                                [
                                    23,
                                    45,
                                    15,
                                    28,
                                    46,
                                    16
                                ],
                                [
                                    17,
                                    145,
                                    115
                                ],
                                [
                                    10,
                                    74,
                                    46,
                                    23,
                                    75,
                                    47
                                ],
                                [
                                    10,
                                    54,
                                    24,
                                    35,
                                    55,
                                    25
                                ],
                                [
                                    19,
                                    45,
                                    15,
                                    35,
                                    46,
                                    16
                                ],
                                [
                                    17,
                                    145,
                                    115,
                                    1,
                                    146,
                                    116
                                ],
                                [
                                    14,
                                    74,
                                    46,
                                    21,
                                    75,
                                    47
                                ],
                                [
                                    29,
                                    54,
                                    24,
                                    19,
                                    55,
                                    25
                                ],
                                [
                                    11,
                                    45,
                                    15,
                                    46,
                                    46,
                                    16
                                ],
                                [
                                    13,
                                    145,
                                    115,
                                    6,
                                    146,
                                    116
                                ],
                                [
                                    14,
                                    74,
                                    46,
                                    23,
                                    75,
                                    47
                                ],
                                [
                                    44,
                                    54,
                                    24,
                                    7,
                                    55,
                                    25
                                ],
                                [
                                    59,
                                    46,
                                    16,
                                    1,
                                    47,
                                    17
                                ],
                                [
                                    12,
                                    151,
                                    121,
                                    7,
                                    152,
                                    122
                                ],
                                [
                                    12,
                                    75,
                                    47,
                                    26,
                                    76,
                                    48
                                ],
                                [
                                    39,
                                    54,
                                    24,
                                    14,
                                    55,
                                    25
                                ],
                                [
                                    22,
                                    45,
                                    15,
                                    41,
                                    46,
                                    16
                                ],
                                [
                                    6,
                                    151,
                                    121,
                                    14,
                                    152,
                                    122
                                ],
                                [
                                    6,
                                    75,
                                    47,
                                    34,
                                    76,
                                    48
                                ],
                                [
                                    46,
                                    54,
                                    24,
                                    10,
                                    55,
                                    25
                                ],
                                [
                                    2,
                                    45,
                                    15,
                                    64,
                                    46,
                                    16
                                ],
                                [
                                    17,
                                    152,
                                    122,
                                    4,
                                    153,
                                    123
                                ],
                                [
                                    29,
                                    74,
                                    46,
                                    14,
                                    75,
                                    47
                                ],
                                [
                                    49,
                                    54,
                                    24,
                                    10,
                                    55,
                                    25
                                ],
                                [
                                    24,
                                    45,
                                    15,
                                    46,
                                    46,
                                    16
                                ],
                                [
                                    4,
                                    152,
                                    122,
                                    18,
                                    153,
                                    123
                                ],
                                [
                                    13,
                                    74,
                                    46,
                                    32,
                                    75,
                                    47
                                ],
                                [
                                    48,
                                    54,
                                    24,
                                    14,
                                    55,
                                    25
                                ],
                                [
                                    42,
                                    45,
                                    15,
                                    32,
                                    46,
                                    16
                                ],
                                [
                                    20,
                                    147,
                                    117,
                                    4,
                                    148,
                                    118
                                ],
                                [
                                    40,
                                    75,
                                    47,
                                    7,
                                    76,
                                    48
                                ],
                                [
                                    43,
                                    54,
                                    24,
                                    22,
                                    55,
                                    25
                                ],
                                [
                                    10,
                                    45,
                                    15,
                                    67,
                                    46,
                                    16
                                ],
                                [
                                    19,
                                    148,
                                    118,
                                    6,
                                    149,
                                    119
                                ],
                                [
                                    18,
                                    75,
                                    47,
                                    31,
                                    76,
                                    48
                                ],
                                [
                                    34,
                                    54,
                                    24,
                                    34,
                                    55,
                                    25
                                ],
                                [
                                    20,
                                    45,
                                    15,
                                    61,
                                    46,
                                    16
                                ]
                            ], T = function(y, w) {
                                var M = {};
                                return M.totalCount = y, M.dataCount = w, M;
                            }, I = {
                                getRSBlocks: function(y, w) {
                                    var M = function(ne, ie) {
                                        switch(ie){
                                            case x.L:
                                                return C[4 * (ne - 1) + 0];
                                            case x.M:
                                                return C[4 * (ne - 1) + 1];
                                            case x.Q:
                                                return C[4 * (ne - 1) + 2];
                                            case x.H:
                                                return C[4 * (ne - 1) + 3];
                                            default:
                                                return;
                                        }
                                    }(y, w);
                                    if (M === void 0) throw "bad rs block @ typeNumber:" + y + "/errorCorrectionLevel:" + w;
                                    for(var D = M.length / 3, A = [], L = 0; L < D; L += 1)for(var V = M[3 * L + 0], Y = M[3 * L + 1], K = M[3 * L + 2], J = 0; J < V; J += 1)A.push(T(Y, K));
                                    return A;
                                }
                            };
                            return I;
                        }(), z = function() {
                            var C = [], T = 0, I = {
                                getBuffer: function() {
                                    return C;
                                },
                                getAt: function(y) {
                                    var w = Math.floor(y / 8);
                                    return (C[w] >>> 7 - y % 8 & 1) == 1;
                                },
                                put: function(y, w) {
                                    for(var M = 0; M < w; M += 1)I.putBit((y >>> w - M - 1 & 1) == 1);
                                },
                                getLengthInBits: function() {
                                    return T;
                                },
                                putBit: function(y) {
                                    var w = Math.floor(T / 8);
                                    C.length <= w && C.push(0), y && (C[w] |= 128 >>> T % 8), T += 1;
                                }
                            };
                            return I;
                        }, P = function(C) {
                            var T = C, I = {
                                getMode: function() {
                                    return 1;
                                },
                                getLength: function(M) {
                                    return T.length;
                                },
                                write: function(M) {
                                    for(var D = T, A = 0; A + 2 < D.length;)M.put(y(D.substring(A, A + 3)), 10), A += 3;
                                    A < D.length && (D.length - A == 1 ? M.put(y(D.substring(A, A + 1)), 4) : D.length - A == 2 && M.put(y(D.substring(A, A + 2)), 7));
                                }
                            }, y = function(M) {
                                for(var D = 0, A = 0; A < M.length; A += 1)D = 10 * D + w(M.charAt(A));
                                return D;
                            }, w = function(M) {
                                if ("0" <= M && M <= "9") return M.charCodeAt(0) - 48;
                                throw "illegal char :" + M;
                            };
                            return I;
                        }, U = function(C) {
                            var T = C, I = {
                                getMode: function() {
                                    return 2;
                                },
                                getLength: function(w) {
                                    return T.length;
                                },
                                write: function(w) {
                                    for(var M = T, D = 0; D + 1 < M.length;)w.put(45 * y(M.charAt(D)) + y(M.charAt(D + 1)), 11), D += 2;
                                    D < M.length && w.put(y(M.charAt(D)), 6);
                                }
                            }, y = function(w) {
                                if ("0" <= w && w <= "9") return w.charCodeAt(0) - 48;
                                if ("A" <= w && w <= "Z") return w.charCodeAt(0) - 65 + 10;
                                switch(w){
                                    case " ":
                                        return 36;
                                    case "$":
                                        return 37;
                                    case "%":
                                        return 38;
                                    case "*":
                                        return 39;
                                    case "+":
                                        return 40;
                                    case "-":
                                        return 41;
                                    case ".":
                                        return 42;
                                    case "/":
                                        return 43;
                                    case ":":
                                        return 44;
                                    default:
                                        throw "illegal char :" + w;
                                }
                            };
                            return I;
                        }, R = function(C) {
                            var T = d.stringToBytes(C);
                            return {
                                getMode: function() {
                                    return 4;
                                },
                                getLength: function(I) {
                                    return T.length;
                                },
                                write: function(I) {
                                    for(var y = 0; y < T.length; y += 1)I.put(T[y], 8);
                                }
                            };
                        }, G = function(C) {
                            var T = d.stringToBytesFuncs.SJIS;
                            if (!T) throw "sjis not supported.";
                            (function() {
                                var w = T("");
                                if (w.length != 2 || (w[0] << 8 | w[1]) != 38726) throw "sjis not supported.";
                            })();
                            var I = T(C), y = {
                                getMode: function() {
                                    return 8;
                                },
                                getLength: function(w) {
                                    return ~~(I.length / 2);
                                },
                                write: function(w) {
                                    for(var M = I, D = 0; D + 1 < M.length;){
                                        var A = (255 & M[D]) << 8 | 255 & M[D + 1];
                                        if (33088 <= A && A <= 40956) A -= 33088;
                                        else {
                                            if (!(57408 <= A && A <= 60351)) throw "illegal char at " + (D + 1) + "/" + A;
                                            A -= 49472;
                                        }
                                        A = 192 * (A >>> 8 & 255) + (255 & A), w.put(A, 13), D += 2;
                                    }
                                    if (D < M.length) throw "illegal char at " + (D + 1);
                                }
                            };
                            return y;
                        }, F = function() {
                            var C = [], T = {
                                writeByte: function(I) {
                                    C.push(255 & I);
                                },
                                writeShort: function(I) {
                                    T.writeByte(I), T.writeByte(I >>> 8);
                                },
                                writeBytes: function(I, y, w) {
                                    y = y || 0, w = w || I.length;
                                    for(var M = 0; M < w; M += 1)T.writeByte(I[M + y]);
                                },
                                writeString: function(I) {
                                    for(var y = 0; y < I.length; y += 1)T.writeByte(I.charCodeAt(y));
                                },
                                toByteArray: function() {
                                    return C;
                                },
                                toString: function() {
                                    var I = "";
                                    I += "[";
                                    for(var y = 0; y < C.length; y += 1)y > 0 && (I += ","), I += C[y];
                                    return I + "]";
                                }
                            };
                            return T;
                        }, H = function(C) {
                            var T = C, I = 0, y = 0, w = 0, M = {
                                read: function() {
                                    for(; w < 8;){
                                        if (I >= T.length) {
                                            if (w == 0) return -1;
                                            throw "unexpected end of file./" + w;
                                        }
                                        var A = T.charAt(I);
                                        if (I += 1, A == "=") return w = 0, -1;
                                        A.match(/^\s$/) || (y = y << 6 | D(A.charCodeAt(0)), w += 6);
                                    }
                                    var L = y >>> w - 8 & 255;
                                    return w -= 8, L;
                                }
                            }, D = function(A) {
                                if (65 <= A && A <= 90) return A - 65;
                                if (97 <= A && A <= 122) return A - 97 + 26;
                                if (48 <= A && A <= 57) return A - 48 + 52;
                                if (A == 43) return 62;
                                if (A == 47) return 63;
                                throw "c:" + A;
                            };
                            return M;
                        }, B = function(C, T, I) {
                            for(var y = function(Y, K) {
                                var J = Y, ne = K, ie = new Array(Y * K), oe = {
                                    setPixel: function(Q, Z, W) {
                                        ie[Z * J + Q] = W;
                                    },
                                    write: function(Q) {
                                        Q.writeString("GIF87a"), Q.writeShort(J), Q.writeShort(ne), Q.writeByte(128), Q.writeByte(0), Q.writeByte(0), Q.writeByte(0), Q.writeByte(0), Q.writeByte(0), Q.writeByte(255), Q.writeByte(255), Q.writeByte(255), Q.writeString(","), Q.writeShort(0), Q.writeShort(0), Q.writeShort(J), Q.writeShort(ne), Q.writeByte(0);
                                        var Z = le(2);
                                        Q.writeByte(2);
                                        for(var W = 0; Z.length - W > 255;)Q.writeByte(255), Q.writeBytes(Z, W, 255), W += 255;
                                        Q.writeByte(Z.length - W), Q.writeBytes(Z, W, Z.length - W), Q.writeByte(0), Q.writeString(";");
                                    }
                                }, le = function(Q) {
                                    for(var Z = 1 << Q, W = 1 + (1 << Q), ee = Q + 1, se = fe(), pe = 0; pe < Z; pe += 1)se.add(String.fromCharCode(pe));
                                    se.add(String.fromCharCode(Z)), se.add(String.fromCharCode(W));
                                    var be, ve, _e, Ie = F(), xe = (be = Ie, ve = 0, _e = 0, {
                                        write: function(Ae, j) {
                                            if (Ae >>> j) throw "length over";
                                            for(; ve + j >= 8;)be.writeByte(255 & (Ae << ve | _e)), j -= 8 - ve, Ae >>>= 8 - ve, _e = 0, ve = 0;
                                            _e |= Ae << ve, ve += j;
                                        },
                                        flush: function() {
                                            ve > 0 && be.writeByte(_e);
                                        }
                                    });
                                    xe.write(Z, ee);
                                    var He = 0, Qe = String.fromCharCode(ie[He]);
                                    for(He += 1; He < ie.length;){
                                        var De = String.fromCharCode(ie[He]);
                                        He += 1, se.contains(Qe + De) ? Qe += De : (xe.write(se.indexOf(Qe), ee), se.size() < 4095 && (se.size() == 1 << ee && (ee += 1), se.add(Qe + De)), Qe = De);
                                    }
                                    return xe.write(se.indexOf(Qe), ee), xe.write(W, ee), xe.flush(), Ie.toByteArray();
                                }, fe = function() {
                                    var Q = {}, Z = 0, W = {
                                        add: function(ee) {
                                            if (W.contains(ee)) throw "dup key:" + ee;
                                            Q[ee] = Z, Z += 1;
                                        },
                                        size: function() {
                                            return Z;
                                        },
                                        indexOf: function(ee) {
                                            return Q[ee];
                                        },
                                        contains: function(ee) {
                                            return Q[ee] !== void 0;
                                        }
                                    };
                                    return W;
                                };
                                return oe;
                            }(C, T), w = 0; w < T; w += 1)for(var M = 0; M < C; M += 1)y.setPixel(M, w, I(M, w));
                            var D = F();
                            y.write(D);
                            for(var A = function() {
                                var Y = 0, K = 0, J = 0, ne = "", ie = {}, oe = function(fe) {
                                    ne += String.fromCharCode(le(63 & fe));
                                }, le = function(fe) {
                                    if (!(fe < 0)) {
                                        if (fe < 26) return 65 + fe;
                                        if (fe < 52) return fe - 26 + 97;
                                        if (fe < 62) return fe - 52 + 48;
                                        if (fe == 62) return 43;
                                        if (fe == 63) return 47;
                                    }
                                    throw "n:" + fe;
                                };
                                return ie.writeByte = function(fe) {
                                    for(Y = Y << 8 | 255 & fe, K += 8, J += 1; K >= 6;)oe(Y >>> K - 6), K -= 6;
                                }, ie.flush = function() {
                                    if (K > 0 && (oe(Y << 6 - K), Y = 0, K = 0), J % 3 != 0) for(var fe = 3 - J % 3, Q = 0; Q < fe; Q += 1)ne += "=";
                                }, ie.toString = function() {
                                    return ne;
                                }, ie;
                            }(), L = D.toByteArray(), V = 0; V < L.length; V += 1)A.writeByte(L[V]);
                            return A.flush(), "data:image/gif;base64," + A;
                        };
                        return d;
                    }();
                    l.stringToBytesFuncs["UTF-8"] = function(d) {
                        return function(h) {
                            for(var f = [], g = 0; g < h.length; g++){
                                var p = h.charCodeAt(g);
                                p < 128 ? f.push(p) : p < 2048 ? f.push(192 | p >> 6, 128 | 63 & p) : p < 55296 || p >= 57344 ? f.push(224 | p >> 12, 128 | p >> 6 & 63, 128 | 63 & p) : (g++, p = 65536 + ((1023 & p) << 10 | 1023 & h.charCodeAt(g)), f.push(240 | p >> 18, 128 | p >> 12 & 63, 128 | p >> 6 & 63, 128 | 63 & p));
                            }
                            return f;
                        }(d);
                    }, (c = typeof (u = function() {
                        return l;
                    }) == "function" ? u.apply(a, []) : u) === void 0 || (o.exports = c);
                }
            }, n = {};
            function s(o) {
                var a = n[o];
                if (a !== void 0) return a.exports;
                var u = n[o] = {
                    exports: {}
                };
                return t[o](u, u.exports, s), u.exports;
            }
            s.n = (o)=>{
                var a = o && o.__esModule ? ()=>o.default : ()=>o;
                return s.d(a, {
                    a
                }), a;
            }, s.d = (o, a)=>{
                for(var u in a)s.o(a, u) && !s.o(o, u) && Object.defineProperty(o, u, {
                    enumerable: !0,
                    get: a[u]
                });
            }, s.o = (o, a)=>Object.prototype.hasOwnProperty.call(o, a);
            var i = {};
            return (()=>{
                s.d(i, {
                    default: ()=>T
                });
                const o = (I)=>!!I && typeof I == "object" && !Array.isArray(I);
                function a(I, ...y) {
                    if (!y.length) return I;
                    const w = y.shift();
                    return w !== void 0 && o(I) && o(w) ? (I = Object.assign({}, I), Object.keys(w).forEach((M)=>{
                        const D = I[M], A = w[M];
                        Array.isArray(D) && Array.isArray(A) ? I[M] = A : o(D) && o(A) ? I[M] = a(Object.assign({}, D), A) : I[M] = A;
                    }), a(I, ...y)) : I;
                }
                function u(I, y) {
                    const w = document.createElement("a");
                    w.download = y, w.href = I, document.body.appendChild(w), w.click(), document.body.removeChild(w);
                }
                const c = {
                    L: 0.07,
                    M: 0.15,
                    Q: 0.25,
                    H: 0.3
                };
                class l {
                    constructor({ svg: y, type: w, window: M }){
                        this._svg = y, this._type = w, this._window = M;
                    }
                    draw(y, w, M, D) {
                        let A;
                        switch(this._type){
                            case "dots":
                                A = this._drawDot;
                                break;
                            case "classy":
                                A = this._drawClassy;
                                break;
                            case "classy-rounded":
                                A = this._drawClassyRounded;
                                break;
                            case "rounded":
                                A = this._drawRounded;
                                break;
                            case "extra-rounded":
                                A = this._drawExtraRounded;
                                break;
                            default:
                                A = this._drawSquare;
                        }
                        A.call(this, {
                            x: y,
                            y: w,
                            size: M,
                            getNeighbor: D
                        });
                    }
                    _rotateFigure({ x: y, y: w, size: M, rotation: D = 0, draw: A }) {
                        var L;
                        const V = y + M / 2, Y = w + M / 2;
                        A(), (L = this._element) === null || L === void 0 || L.setAttribute("transform", `rotate(${180 * D / Math.PI},${V},${Y})`);
                    }
                    _basicDot(y) {
                        const { size: w, x: M, y: D } = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(M + w / 2)), this._element.setAttribute("cy", String(D + w / 2)), this._element.setAttribute("r", String(w / 2));
                            }
                        }));
                    }
                    _basicSquare(y) {
                        const { size: w, x: M, y: D } = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(M)), this._element.setAttribute("y", String(D)), this._element.setAttribute("width", String(w)), this._element.setAttribute("height", String(w));
                            }
                        }));
                    }
                    _basicSideRounded(y) {
                        const { size: w, x: M, y: D } = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${M} ${D}v ${w}h ` + w / 2 + `a ${w / 2} ${w / 2}, 0, 0, 0, 0 ${-w}`);
                            }
                        }));
                    }
                    _basicCornerRounded(y) {
                        const { size: w, x: M, y: D } = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${M} ${D}v ${w}h ${w}v ` + -w / 2 + `a ${w / 2} ${w / 2}, 0, 0, 0, ${-w / 2} ${-w / 2}`);
                            }
                        }));
                    }
                    _basicCornerExtraRounded(y) {
                        const { size: w, x: M, y: D } = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${M} ${D}v ${w}h ${w}a ${w} ${w}, 0, 0, 0, ${-w} ${-w}`);
                            }
                        }));
                    }
                    _basicCornersRounded(y) {
                        const { size: w, x: M, y: D } = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${M} ${D}v ` + w / 2 + `a ${w / 2} ${w / 2}, 0, 0, 0, ${w / 2} ${w / 2}h ` + w / 2 + "v " + -w / 2 + `a ${w / 2} ${w / 2}, 0, 0, 0, ${-w / 2} ${-w / 2}`);
                            }
                        }));
                    }
                    _drawDot({ x: y, y: w, size: M }) {
                        this._basicDot({
                            x: y,
                            y: w,
                            size: M,
                            rotation: 0
                        });
                    }
                    _drawSquare({ x: y, y: w, size: M }) {
                        this._basicSquare({
                            x: y,
                            y: w,
                            size: M,
                            rotation: 0
                        });
                    }
                    _drawRounded({ x: y, y: w, size: M, getNeighbor: D }) {
                        const A = D ? +D(-1, 0) : 0, L = D ? +D(1, 0) : 0, V = D ? +D(0, -1) : 0, Y = D ? +D(0, 1) : 0, K = A + L + V + Y;
                        if (K !== 0) if (K > 2 || A && L || V && Y) this._basicSquare({
                            x: y,
                            y: w,
                            size: M,
                            rotation: 0
                        });
                        else {
                            if (K === 2) {
                                let J = 0;
                                return A && V ? J = Math.PI / 2 : V && L ? J = Math.PI : L && Y && (J = -Math.PI / 2), void this._basicCornerRounded({
                                    x: y,
                                    y: w,
                                    size: M,
                                    rotation: J
                                });
                            }
                            if (K === 1) {
                                let J = 0;
                                return V ? J = Math.PI / 2 : L ? J = Math.PI : Y && (J = -Math.PI / 2), void this._basicSideRounded({
                                    x: y,
                                    y: w,
                                    size: M,
                                    rotation: J
                                });
                            }
                        }
                        else this._basicDot({
                            x: y,
                            y: w,
                            size: M,
                            rotation: 0
                        });
                    }
                    _drawExtraRounded({ x: y, y: w, size: M, getNeighbor: D }) {
                        const A = D ? +D(-1, 0) : 0, L = D ? +D(1, 0) : 0, V = D ? +D(0, -1) : 0, Y = D ? +D(0, 1) : 0, K = A + L + V + Y;
                        if (K !== 0) if (K > 2 || A && L || V && Y) this._basicSquare({
                            x: y,
                            y: w,
                            size: M,
                            rotation: 0
                        });
                        else {
                            if (K === 2) {
                                let J = 0;
                                return A && V ? J = Math.PI / 2 : V && L ? J = Math.PI : L && Y && (J = -Math.PI / 2), void this._basicCornerExtraRounded({
                                    x: y,
                                    y: w,
                                    size: M,
                                    rotation: J
                                });
                            }
                            if (K === 1) {
                                let J = 0;
                                return V ? J = Math.PI / 2 : L ? J = Math.PI : Y && (J = -Math.PI / 2), void this._basicSideRounded({
                                    x: y,
                                    y: w,
                                    size: M,
                                    rotation: J
                                });
                            }
                        }
                        else this._basicDot({
                            x: y,
                            y: w,
                            size: M,
                            rotation: 0
                        });
                    }
                    _drawClassy({ x: y, y: w, size: M, getNeighbor: D }) {
                        const A = D ? +D(-1, 0) : 0, L = D ? +D(1, 0) : 0, V = D ? +D(0, -1) : 0, Y = D ? +D(0, 1) : 0;
                        A + L + V + Y !== 0 ? A || V ? L || Y ? this._basicSquare({
                            x: y,
                            y: w,
                            size: M,
                            rotation: 0
                        }) : this._basicCornerRounded({
                            x: y,
                            y: w,
                            size: M,
                            rotation: Math.PI / 2
                        }) : this._basicCornerRounded({
                            x: y,
                            y: w,
                            size: M,
                            rotation: -Math.PI / 2
                        }) : this._basicCornersRounded({
                            x: y,
                            y: w,
                            size: M,
                            rotation: Math.PI / 2
                        });
                    }
                    _drawClassyRounded({ x: y, y: w, size: M, getNeighbor: D }) {
                        const A = D ? +D(-1, 0) : 0, L = D ? +D(1, 0) : 0, V = D ? +D(0, -1) : 0, Y = D ? +D(0, 1) : 0;
                        A + L + V + Y !== 0 ? A || V ? L || Y ? this._basicSquare({
                            x: y,
                            y: w,
                            size: M,
                            rotation: 0
                        }) : this._basicCornerExtraRounded({
                            x: y,
                            y: w,
                            size: M,
                            rotation: Math.PI / 2
                        }) : this._basicCornerExtraRounded({
                            x: y,
                            y: w,
                            size: M,
                            rotation: -Math.PI / 2
                        }) : this._basicCornersRounded({
                            x: y,
                            y: w,
                            size: M,
                            rotation: Math.PI / 2
                        });
                    }
                }
                const d = {
                    dot: "dot",
                    square: "square",
                    extraRounded: "extra-rounded"
                }, h = Object.values(d);
                class f {
                    constructor({ svg: y, type: w, window: M }){
                        this._svg = y, this._type = w, this._window = M;
                    }
                    draw(y, w, M, D) {
                        let A;
                        switch(this._type){
                            case d.square:
                                A = this._drawSquare;
                                break;
                            case d.extraRounded:
                                A = this._drawExtraRounded;
                                break;
                            default:
                                A = this._drawDot;
                        }
                        A.call(this, {
                            x: y,
                            y: w,
                            size: M,
                            rotation: D
                        });
                    }
                    _rotateFigure({ x: y, y: w, size: M, rotation: D = 0, draw: A }) {
                        var L;
                        const V = y + M / 2, Y = w + M / 2;
                        A(), (L = this._element) === null || L === void 0 || L.setAttribute("transform", `rotate(${180 * D / Math.PI},${V},${Y})`);
                    }
                    _basicDot(y) {
                        const { size: w, x: M, y: D } = y, A = w / 7;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${M + w / 2} ${D}a ${w / 2} ${w / 2} 0 1 0 0.1 0zm 0 ${A}a ${w / 2 - A} ${w / 2 - A} 0 1 1 -0.1 0Z`);
                            }
                        }));
                    }
                    _basicSquare(y) {
                        const { size: w, x: M, y: D } = y, A = w / 7;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${M} ${D}v ${w}h ${w}v ` + -w + `zM ${M + A} ${D + A}h ` + (w - 2 * A) + "v " + (w - 2 * A) + "h " + (2 * A - w) + "z");
                            }
                        }));
                    }
                    _basicExtraRounded(y) {
                        const { size: w, x: M, y: D } = y, A = w / 7;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${M} ${D + 2.5 * A}v ` + 2 * A + `a ${2.5 * A} ${2.5 * A}, 0, 0, 0, ${2.5 * A} ${2.5 * A}h ` + 2 * A + `a ${2.5 * A} ${2.5 * A}, 0, 0, 0, ${2.5 * A} ${2.5 * -A}v ` + -2 * A + `a ${2.5 * A} ${2.5 * A}, 0, 0, 0, ${2.5 * -A} ${2.5 * -A}h ` + -2 * A + `a ${2.5 * A} ${2.5 * A}, 0, 0, 0, ${2.5 * -A} ${2.5 * A}M ${M + 2.5 * A} ${D + A}h ` + 2 * A + `a ${1.5 * A} ${1.5 * A}, 0, 0, 1, ${1.5 * A} ${1.5 * A}v ` + 2 * A + `a ${1.5 * A} ${1.5 * A}, 0, 0, 1, ${1.5 * -A} ${1.5 * A}h ` + -2 * A + `a ${1.5 * A} ${1.5 * A}, 0, 0, 1, ${1.5 * -A} ${1.5 * -A}v ` + -2 * A + `a ${1.5 * A} ${1.5 * A}, 0, 0, 1, ${1.5 * A} ${1.5 * -A}`);
                            }
                        }));
                    }
                    _drawDot({ x: y, y: w, size: M, rotation: D }) {
                        this._basicDot({
                            x: y,
                            y: w,
                            size: M,
                            rotation: D
                        });
                    }
                    _drawSquare({ x: y, y: w, size: M, rotation: D }) {
                        this._basicSquare({
                            x: y,
                            y: w,
                            size: M,
                            rotation: D
                        });
                    }
                    _drawExtraRounded({ x: y, y: w, size: M, rotation: D }) {
                        this._basicExtraRounded({
                            x: y,
                            y: w,
                            size: M,
                            rotation: D
                        });
                    }
                }
                const g = {
                    dot: "dot",
                    square: "square"
                }, p = Object.values(g);
                class m {
                    constructor({ svg: y, type: w, window: M }){
                        this._svg = y, this._type = w, this._window = M;
                    }
                    draw(y, w, M, D) {
                        let A;
                        A = this._type === g.square ? this._drawSquare : this._drawDot, A.call(this, {
                            x: y,
                            y: w,
                            size: M,
                            rotation: D
                        });
                    }
                    _rotateFigure({ x: y, y: w, size: M, rotation: D = 0, draw: A }) {
                        var L;
                        const V = y + M / 2, Y = w + M / 2;
                        A(), (L = this._element) === null || L === void 0 || L.setAttribute("transform", `rotate(${180 * D / Math.PI},${V},${Y})`);
                    }
                    _basicDot(y) {
                        const { size: w, x: M, y: D } = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(M + w / 2)), this._element.setAttribute("cy", String(D + w / 2)), this._element.setAttribute("r", String(w / 2));
                            }
                        }));
                    }
                    _basicSquare(y) {
                        const { size: w, x: M, y: D } = y;
                        this._rotateFigure(Object.assign(Object.assign({}, y), {
                            draw: ()=>{
                                this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(M)), this._element.setAttribute("y", String(D)), this._element.setAttribute("width", String(w)), this._element.setAttribute("height", String(w));
                            }
                        }));
                    }
                    _drawDot({ x: y, y: w, size: M, rotation: D }) {
                        this._basicDot({
                            x: y,
                            y: w,
                            size: M,
                            rotation: D
                        });
                    }
                    _drawSquare({ x: y, y: w, size: M, rotation: D }) {
                        this._basicSquare({
                            x: y,
                            y: w,
                            size: M,
                            rotation: D
                        });
                    }
                }
                const x = "circle", _ = [
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ], v = [
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                ];
                class N {
                    constructor(y, w){
                        this._roundSize = (M)=>this._options.dotsOptions.roundSize ? Math.floor(M) : M, this._window = w, this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(y.width)), this._element.setAttribute("height", String(y.height)), this._element.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), y.dotsOptions.roundSize || this._element.setAttribute("shape-rendering", "crispEdges"), this._element.setAttribute("viewBox", `0 0 ${y.width} ${y.height}`), this._defs = this._window.document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._imageUri = y.image, this._instanceId = N.instanceCount++, this._options = y;
                    }
                    get width() {
                        return this._options.width;
                    }
                    get height() {
                        return this._options.height;
                    }
                    getElement() {
                        return this._element;
                    }
                    async drawQR(y) {
                        const w = y.getModuleCount(), M = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, D = this._options.shape === x ? M / Math.sqrt(2) : M, A = this._roundSize(D / w);
                        let L = {
                            hideXDots: 0,
                            hideYDots: 0,
                            width: 0,
                            height: 0
                        };
                        if (this._qr = y, this._options.image) {
                            if (await this.loadImage(), !this._image) return;
                            const { imageOptions: V, qrOptions: Y } = this._options, K = V.imageSize * c[Y.errorCorrectionLevel], J = Math.floor(K * w * w);
                            L = function({ originalHeight: ne, originalWidth: ie, maxHiddenDots: oe, maxHiddenAxisDots: le, dotSize: fe }) {
                                const Q = {
                                    x: 0,
                                    y: 0
                                }, Z = {
                                    x: 0,
                                    y: 0
                                };
                                if (ne <= 0 || ie <= 0 || oe <= 0 || fe <= 0) return {
                                    height: 0,
                                    width: 0,
                                    hideYDots: 0,
                                    hideXDots: 0
                                };
                                const W = ne / ie;
                                return Q.x = Math.floor(Math.sqrt(oe / W)), Q.x <= 0 && (Q.x = 1), le && le < Q.x && (Q.x = le), Q.x % 2 == 0 && Q.x--, Z.x = Q.x * fe, Q.y = 1 + 2 * Math.ceil((Q.x * W - 1) / 2), Z.y = Math.round(Z.x * W), (Q.y * Q.x > oe || le && le < Q.y) && (le && le < Q.y ? (Q.y = le, Q.y % 2 == 0 && Q.x--) : Q.y -= 2, Z.y = Q.y * fe, Q.x = 1 + 2 * Math.ceil((Q.y / W - 1) / 2), Z.x = Math.round(Z.y / W)), {
                                    height: Z.y,
                                    width: Z.x,
                                    hideYDots: Q.y,
                                    hideXDots: Q.x
                                };
                            }({
                                originalWidth: this._image.width,
                                originalHeight: this._image.height,
                                maxHiddenDots: J,
                                maxHiddenAxisDots: w - 14,
                                dotSize: A
                            });
                        }
                        this.drawBackground(), this.drawDots((V, Y)=>{
                            var K, J, ne, ie, oe, le;
                            return !(this._options.imageOptions.hideBackgroundDots && V >= (w - L.hideYDots) / 2 && V < (w + L.hideYDots) / 2 && Y >= (w - L.hideXDots) / 2 && Y < (w + L.hideXDots) / 2 || !((K = _[V]) === null || K === void 0) && K[Y] || !((J = _[V - w + 7]) === null || J === void 0) && J[Y] || !((ne = _[V]) === null || ne === void 0) && ne[Y - w + 7] || !((ie = v[V]) === null || ie === void 0) && ie[Y] || !((oe = v[V - w + 7]) === null || oe === void 0) && oe[Y] || !((le = v[V]) === null || le === void 0) && le[Y - w + 7]);
                        }), this.drawCorners(), this._options.image && await this.drawImage({
                            width: L.width,
                            height: L.height,
                            count: w,
                            dotSize: A
                        });
                    }
                    drawBackground() {
                        var y, w, M;
                        const D = this._element, A = this._options;
                        if (D) {
                            const L = (y = A.backgroundOptions) === null || y === void 0 ? void 0 : y.gradient, V = (w = A.backgroundOptions) === null || w === void 0 ? void 0 : w.color;
                            let Y = A.height, K = A.width;
                            if (L || V) {
                                const J = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                this._backgroundClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", `clip-path-background-color-${this._instanceId}`), this._defs.appendChild(this._backgroundClipPath), !((M = A.backgroundOptions) === null || M === void 0) && M.round && (Y = K = Math.min(A.width, A.height), J.setAttribute("rx", String(Y / 2 * A.backgroundOptions.round))), J.setAttribute("x", String(this._roundSize((A.width - K) / 2))), J.setAttribute("y", String(this._roundSize((A.height - Y) / 2))), J.setAttribute("width", String(K)), J.setAttribute("height", String(Y)), this._backgroundClipPath.appendChild(J), this._createColor({
                                    options: L,
                                    color: V,
                                    additionalRotation: 0,
                                    x: 0,
                                    y: 0,
                                    height: A.height,
                                    width: A.width,
                                    name: `background-color-${this._instanceId}`
                                });
                            }
                        }
                    }
                    drawDots(y) {
                        var w, M;
                        if (!this._qr) throw "QR code is not defined";
                        const D = this._options, A = this._qr.getModuleCount();
                        if (A > D.width || A > D.height) throw "The canvas is too small.";
                        const L = Math.min(D.width, D.height) - 2 * D.margin, V = D.shape === x ? L / Math.sqrt(2) : L, Y = this._roundSize(V / A), K = this._roundSize((D.width - A * Y) / 2), J = this._roundSize((D.height - A * Y) / 2), ne = new l({
                            svg: this._element,
                            type: D.dotsOptions.type,
                            window: this._window
                        });
                        this._dotsClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", `clip-path-dot-color-${this._instanceId}`), this._defs.appendChild(this._dotsClipPath), this._createColor({
                            options: (w = D.dotsOptions) === null || w === void 0 ? void 0 : w.gradient,
                            color: D.dotsOptions.color,
                            additionalRotation: 0,
                            x: 0,
                            y: 0,
                            height: D.height,
                            width: D.width,
                            name: `dot-color-${this._instanceId}`
                        });
                        for(let ie = 0; ie < A; ie++)for(let oe = 0; oe < A; oe++)y && !y(ie, oe) || !((M = this._qr) === null || M === void 0) && M.isDark(ie, oe) && (ne.draw(K + oe * Y, J + ie * Y, Y, (le, fe)=>!(oe + le < 0 || ie + fe < 0 || oe + le >= A || ie + fe >= A) && !(y && !y(ie + fe, oe + le)) && !!this._qr && this._qr.isDark(ie + fe, oe + le)), ne._element && this._dotsClipPath && this._dotsClipPath.appendChild(ne._element));
                        if (D.shape === x) {
                            const ie = this._roundSize((L / Y - A) / 2), oe = A + 2 * ie, le = K - ie * Y, fe = J - ie * Y, Q = [], Z = this._roundSize(oe / 2);
                            for(let W = 0; W < oe; W++){
                                Q[W] = [];
                                for(let ee = 0; ee < oe; ee++)W >= ie - 1 && W <= oe - ie && ee >= ie - 1 && ee <= oe - ie || Math.sqrt((W - Z) * (W - Z) + (ee - Z) * (ee - Z)) > Z ? Q[W][ee] = 0 : Q[W][ee] = this._qr.isDark(ee - 2 * ie < 0 ? ee : ee >= A ? ee - 2 * ie : ee - ie, W - 2 * ie < 0 ? W : W >= A ? W - 2 * ie : W - ie) ? 1 : 0;
                            }
                            for(let W = 0; W < oe; W++)for(let ee = 0; ee < oe; ee++)Q[W][ee] && (ne.draw(le + ee * Y, fe + W * Y, Y, (se, pe)=>{
                                var be;
                                return !!(!((be = Q[W + pe]) === null || be === void 0) && be[ee + se]);
                            }), ne._element && this._dotsClipPath && this._dotsClipPath.appendChild(ne._element));
                        }
                    }
                    drawCorners() {
                        if (!this._qr) throw "QR code is not defined";
                        const y = this._element, w = this._options;
                        if (!y) throw "Element code is not defined";
                        const M = this._qr.getModuleCount(), D = Math.min(w.width, w.height) - 2 * w.margin, A = w.shape === x ? D / Math.sqrt(2) : D, L = this._roundSize(A / M), V = 7 * L, Y = 3 * L, K = this._roundSize((w.width - M * L) / 2), J = this._roundSize((w.height - M * L) / 2);
                        [
                            [
                                0,
                                0,
                                0
                            ],
                            [
                                1,
                                0,
                                Math.PI / 2
                            ],
                            [
                                0,
                                1,
                                -Math.PI / 2
                            ]
                        ].forEach(([ne, ie, oe])=>{
                            var le, fe, Q, Z, W, ee, se, pe, be, ve, _e, Ie, xe, He;
                            const Qe = K + ne * L * (M - 7), De = J + ie * L * (M - 7);
                            let Ae = this._dotsClipPath, j = this._dotsClipPath;
                            if ((!((le = w.cornersSquareOptions) === null || le === void 0) && le.gradient || !((fe = w.cornersSquareOptions) === null || fe === void 0) && fe.color) && (Ae = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), Ae.setAttribute("id", `clip-path-corners-square-color-${ne}-${ie}-${this._instanceId}`), this._defs.appendChild(Ae), this._cornersSquareClipPath = this._cornersDotClipPath = j = Ae, this._createColor({
                                options: (Q = w.cornersSquareOptions) === null || Q === void 0 ? void 0 : Q.gradient,
                                color: (Z = w.cornersSquareOptions) === null || Z === void 0 ? void 0 : Z.color,
                                additionalRotation: oe,
                                x: Qe,
                                y: De,
                                height: V,
                                width: V,
                                name: `corners-square-color-${ne}-${ie}-${this._instanceId}`
                            })), ((W = w.cornersSquareOptions) === null || W === void 0 ? void 0 : W.type) && h.includes(w.cornersSquareOptions.type)) {
                                const b = new f({
                                    svg: this._element,
                                    type: w.cornersSquareOptions.type,
                                    window: this._window
                                });
                                b.draw(Qe, De, V, oe), b._element && Ae && Ae.appendChild(b._element);
                            } else {
                                const b = new l({
                                    svg: this._element,
                                    type: ((ee = w.cornersSquareOptions) === null || ee === void 0 ? void 0 : ee.type) || w.dotsOptions.type,
                                    window: this._window
                                });
                                for(let E = 0; E < _.length; E++)for(let k = 0; k < _[E].length; k++)!((se = _[E]) === null || se === void 0) && se[k] && (b.draw(Qe + k * L, De + E * L, L, (q, X)=>{
                                    var re;
                                    return !!(!((re = _[E + X]) === null || re === void 0) && re[k + q]);
                                }), b._element && Ae && Ae.appendChild(b._element));
                            }
                            if ((!((pe = w.cornersDotOptions) === null || pe === void 0) && pe.gradient || !((be = w.cornersDotOptions) === null || be === void 0) && be.color) && (j = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), j.setAttribute("id", `clip-path-corners-dot-color-${ne}-${ie}-${this._instanceId}`), this._defs.appendChild(j), this._cornersDotClipPath = j, this._createColor({
                                options: (ve = w.cornersDotOptions) === null || ve === void 0 ? void 0 : ve.gradient,
                                color: (_e = w.cornersDotOptions) === null || _e === void 0 ? void 0 : _e.color,
                                additionalRotation: oe,
                                x: Qe + 2 * L,
                                y: De + 2 * L,
                                height: Y,
                                width: Y,
                                name: `corners-dot-color-${ne}-${ie}-${this._instanceId}`
                            })), ((Ie = w.cornersDotOptions) === null || Ie === void 0 ? void 0 : Ie.type) && p.includes(w.cornersDotOptions.type)) {
                                const b = new m({
                                    svg: this._element,
                                    type: w.cornersDotOptions.type,
                                    window: this._window
                                });
                                b.draw(Qe + 2 * L, De + 2 * L, Y, oe), b._element && j && j.appendChild(b._element);
                            } else {
                                const b = new l({
                                    svg: this._element,
                                    type: ((xe = w.cornersDotOptions) === null || xe === void 0 ? void 0 : xe.type) || w.dotsOptions.type,
                                    window: this._window
                                });
                                for(let E = 0; E < v.length; E++)for(let k = 0; k < v[E].length; k++)!((He = v[E]) === null || He === void 0) && He[k] && (b.draw(Qe + k * L, De + E * L, L, (q, X)=>{
                                    var re;
                                    return !!(!((re = v[E + X]) === null || re === void 0) && re[k + q]);
                                }), b._element && j && j.appendChild(b._element));
                            }
                        });
                    }
                    loadImage() {
                        return new Promise((y, w)=>{
                            var M;
                            const D = this._options;
                            if (!D.image) return w("Image is not defined");
                            if (!((M = D.nodeCanvas) === null || M === void 0) && M.loadImage) D.nodeCanvas.loadImage(D.image).then((A)=>{
                                var L, V;
                                if (this._image = A, this._options.imageOptions.saveAsBlob) {
                                    const Y = (L = D.nodeCanvas) === null || L === void 0 ? void 0 : L.createCanvas(this._image.width, this._image.height);
                                    (V = Y == null ? void 0 : Y.getContext("2d")) === null || V === void 0 || V.drawImage(A, 0, 0), this._imageUri = Y == null ? void 0 : Y.toDataURL();
                                }
                                y();
                            }).catch(w);
                            else {
                                const A = new this._window.Image();
                                typeof D.imageOptions.crossOrigin == "string" && (A.crossOrigin = D.imageOptions.crossOrigin), this._image = A, A.onload = async ()=>{
                                    this._options.imageOptions.saveAsBlob && (this._imageUri = await async function(L, V) {
                                        return new Promise((Y)=>{
                                            const K = new V.XMLHttpRequest();
                                            K.onload = function() {
                                                const J = new V.FileReader();
                                                J.onloadend = function() {
                                                    Y(J.result);
                                                }, J.readAsDataURL(K.response);
                                            }, K.open("GET", L), K.responseType = "blob", K.send();
                                        });
                                    }(D.image || "", this._window)), y();
                                }, A.src = D.image;
                            }
                        });
                    }
                    async drawImage({ width: y, height: w, count: M, dotSize: D }) {
                        const A = this._options, L = this._roundSize((A.width - M * D) / 2), V = this._roundSize((A.height - M * D) / 2), Y = L + this._roundSize(A.imageOptions.margin + (M * D - y) / 2), K = V + this._roundSize(A.imageOptions.margin + (M * D - w) / 2), J = y - 2 * A.imageOptions.margin, ne = w - 2 * A.imageOptions.margin, ie = this._window.document.createElementNS("http://www.w3.org/2000/svg", "image");
                        ie.setAttribute("href", this._imageUri || ""), ie.setAttribute("xlink:href", this._imageUri || ""), ie.setAttribute("x", String(Y)), ie.setAttribute("y", String(K)), ie.setAttribute("width", `${J}px`), ie.setAttribute("height", `${ne}px`), this._element.appendChild(ie);
                    }
                    _createColor({ options: y, color: w, additionalRotation: M, x: D, y: A, height: L, width: V, name: Y }) {
                        const K = V > L ? V : L, J = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        if (J.setAttribute("x", String(D)), J.setAttribute("y", String(A)), J.setAttribute("height", String(L)), J.setAttribute("width", String(V)), J.setAttribute("clip-path", `url('#clip-path-${Y}')`), y) {
                            let ne;
                            if (y.type === "radial") ne = this._window.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"), ne.setAttribute("id", Y), ne.setAttribute("gradientUnits", "userSpaceOnUse"), ne.setAttribute("fx", String(D + V / 2)), ne.setAttribute("fy", String(A + L / 2)), ne.setAttribute("cx", String(D + V / 2)), ne.setAttribute("cy", String(A + L / 2)), ne.setAttribute("r", String(K / 2));
                            else {
                                const ie = ((y.rotation || 0) + M) % (2 * Math.PI), oe = (ie + 2 * Math.PI) % (2 * Math.PI);
                                let le = D + V / 2, fe = A + L / 2, Q = D + V / 2, Z = A + L / 2;
                                oe >= 0 && oe <= 0.25 * Math.PI || oe > 1.75 * Math.PI && oe <= 2 * Math.PI ? (le -= V / 2, fe -= L / 2 * Math.tan(ie), Q += V / 2, Z += L / 2 * Math.tan(ie)) : oe > 0.25 * Math.PI && oe <= 0.75 * Math.PI ? (fe -= L / 2, le -= V / 2 / Math.tan(ie), Z += L / 2, Q += V / 2 / Math.tan(ie)) : oe > 0.75 * Math.PI && oe <= 1.25 * Math.PI ? (le += V / 2, fe += L / 2 * Math.tan(ie), Q -= V / 2, Z -= L / 2 * Math.tan(ie)) : oe > 1.25 * Math.PI && oe <= 1.75 * Math.PI && (fe += L / 2, le += V / 2 / Math.tan(ie), Z -= L / 2, Q -= V / 2 / Math.tan(ie)), ne = this._window.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), ne.setAttribute("id", Y), ne.setAttribute("gradientUnits", "userSpaceOnUse"), ne.setAttribute("x1", String(Math.round(le))), ne.setAttribute("y1", String(Math.round(fe))), ne.setAttribute("x2", String(Math.round(Q))), ne.setAttribute("y2", String(Math.round(Z)));
                            }
                            y.colorStops.forEach(({ offset: ie, color: oe })=>{
                                const le = this._window.document.createElementNS("http://www.w3.org/2000/svg", "stop");
                                le.setAttribute("offset", 100 * ie + "%"), le.setAttribute("stop-color", oe), ne.appendChild(le);
                            }), J.setAttribute("fill", `url('#${Y}')`), this._defs.appendChild(ne);
                        } else w && J.setAttribute("fill", w);
                        this._element.appendChild(J);
                    }
                }
                N.instanceCount = 0;
                const O = N, z = "canvas", P = {};
                for(let I = 0; I <= 40; I++)P[I] = I;
                const U = {
                    type: z,
                    shape: "square",
                    width: 300,
                    height: 300,
                    data: "",
                    margin: 0,
                    qrOptions: {
                        typeNumber: P[0],
                        mode: void 0,
                        errorCorrectionLevel: "Q"
                    },
                    imageOptions: {
                        saveAsBlob: !0,
                        hideBackgroundDots: !0,
                        imageSize: 0.4,
                        crossOrigin: void 0,
                        margin: 0
                    },
                    dotsOptions: {
                        type: "square",
                        color: "#000",
                        roundSize: !0
                    },
                    backgroundOptions: {
                        round: 0,
                        color: "#fff"
                    }
                };
                function R(I) {
                    const y = Object.assign({}, I);
                    if (!y.colorStops || !y.colorStops.length) throw "Field 'colorStops' is required in gradient";
                    return y.rotation ? y.rotation = Number(y.rotation) : y.rotation = 0, y.colorStops = y.colorStops.map((w)=>Object.assign(Object.assign({}, w), {
                            offset: Number(w.offset)
                        })), y;
                }
                function G(I) {
                    const y = Object.assign({}, I);
                    return y.width = Number(y.width), y.height = Number(y.height), y.margin = Number(y.margin), y.imageOptions = Object.assign(Object.assign({}, y.imageOptions), {
                        hideBackgroundDots: !!y.imageOptions.hideBackgroundDots,
                        imageSize: Number(y.imageOptions.imageSize),
                        margin: Number(y.imageOptions.margin)
                    }), y.margin > Math.min(y.width, y.height) && (y.margin = Math.min(y.width, y.height)), y.dotsOptions = Object.assign({}, y.dotsOptions), y.dotsOptions.gradient && (y.dotsOptions.gradient = R(y.dotsOptions.gradient)), y.cornersSquareOptions && (y.cornersSquareOptions = Object.assign({}, y.cornersSquareOptions), y.cornersSquareOptions.gradient && (y.cornersSquareOptions.gradient = R(y.cornersSquareOptions.gradient))), y.cornersDotOptions && (y.cornersDotOptions = Object.assign({}, y.cornersDotOptions), y.cornersDotOptions.gradient && (y.cornersDotOptions.gradient = R(y.cornersDotOptions.gradient))), y.backgroundOptions && (y.backgroundOptions = Object.assign({}, y.backgroundOptions), y.backgroundOptions.gradient && (y.backgroundOptions.gradient = R(y.backgroundOptions.gradient))), y;
                }
                var F = s(873), H = s.n(F);
                function B(I) {
                    if (!I) throw new Error("Extension must be defined");
                    I[0] === "." && (I = I.substring(1));
                    const y = {
                        bmp: "image/bmp",
                        gif: "image/gif",
                        ico: "image/vnd.microsoft.icon",
                        jpeg: "image/jpeg",
                        jpg: "image/jpeg",
                        png: "image/png",
                        svg: "image/svg+xml",
                        tif: "image/tiff",
                        tiff: "image/tiff",
                        webp: "image/webp",
                        pdf: "application/pdf"
                    }[I.toLowerCase()];
                    if (!y) throw new Error(`Extension "${I}" is not supported`);
                    return y;
                }
                class C {
                    constructor(y){
                        y != null && y.jsdom ? this._window = new y.jsdom("", {
                            resources: "usable"
                        }).window : this._window = window, this._options = y ? G(a(U, y)) : U, this.update();
                    }
                    static _clearContainer(y) {
                        y && (y.innerHTML = "");
                    }
                    _setupSvg() {
                        if (!this._qr) return;
                        const y = new O(this._options, this._window);
                        this._svg = y.getElement(), this._svgDrawingPromise = y.drawQR(this._qr).then(()=>{
                            var w;
                            this._svg && ((w = this._extension) === null || w === void 0 || w.call(this, y.getElement(), this._options));
                        });
                    }
                    _setupCanvas() {
                        var y, w;
                        this._qr && (!((y = this._options.nodeCanvas) === null || y === void 0) && y.createCanvas ? (this._nodeCanvas = this._options.nodeCanvas.createCanvas(this._options.width, this._options.height), this._nodeCanvas.width = this._options.width, this._nodeCanvas.height = this._options.height) : (this._domCanvas = document.createElement("canvas"), this._domCanvas.width = this._options.width, this._domCanvas.height = this._options.height), this._setupSvg(), this._canvasDrawingPromise = (w = this._svgDrawingPromise) === null || w === void 0 ? void 0 : w.then(()=>{
                            var M;
                            if (!this._svg) return;
                            const D = this._svg, A = new this._window.XMLSerializer().serializeToString(D), L = btoa(A), V = `data:${B("svg")};base64,${L}`;
                            if (!((M = this._options.nodeCanvas) === null || M === void 0) && M.loadImage) return this._options.nodeCanvas.loadImage(V).then((Y)=>{
                                var K, J;
                                Y.width = this._options.width, Y.height = this._options.height, (J = (K = this._nodeCanvas) === null || K === void 0 ? void 0 : K.getContext("2d")) === null || J === void 0 || J.drawImage(Y, 0, 0);
                            });
                            {
                                const Y = new this._window.Image();
                                return new Promise((K)=>{
                                    Y.onload = ()=>{
                                        var J, ne;
                                        (ne = (J = this._domCanvas) === null || J === void 0 ? void 0 : J.getContext("2d")) === null || ne === void 0 || ne.drawImage(Y, 0, 0), K();
                                    }, Y.src = V;
                                });
                            }
                        }));
                    }
                    async _getElement(y = "png") {
                        if (!this._qr) throw "QR code is empty";
                        return y.toLowerCase() === "svg" ? (this._svg && this._svgDrawingPromise || this._setupSvg(), await this._svgDrawingPromise, this._svg) : ((this._domCanvas || this._nodeCanvas) && this._canvasDrawingPromise || this._setupCanvas(), await this._canvasDrawingPromise, this._domCanvas || this._nodeCanvas);
                    }
                    update(y) {
                        C._clearContainer(this._container), this._options = y ? G(a(this._options, y)) : this._options, this._options.data && (this._qr = H()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(w) {
                            switch(!0){
                                case /^[0-9]*$/.test(w):
                                    return "Numeric";
                                case /^[0-9A-Z $%*+\-./:]*$/.test(w):
                                    return "Alphanumeric";
                                default:
                                    return "Byte";
                            }
                        }(this._options.data)), this._qr.make(), this._options.type === z ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
                    }
                    append(y) {
                        if (y) {
                            if (typeof y.appendChild != "function") throw "Container should be a single DOM node";
                            this._options.type === z ? this._domCanvas && y.appendChild(this._domCanvas) : this._svg && y.appendChild(this._svg), this._container = y;
                        }
                    }
                    applyExtension(y) {
                        if (!y) throw "Extension function should be defined.";
                        this._extension = y, this.update();
                    }
                    deleteExtension() {
                        this._extension = void 0, this.update();
                    }
                    async getRawData(y = "png") {
                        if (!this._qr) throw "QR code is empty";
                        const w = await this._getElement(y), M = B(y);
                        if (!w) return null;
                        if (y.toLowerCase() === "svg") {
                            const D = `<?xml version="1.0" standalone="no"?>\r
${new this._window.XMLSerializer().serializeToString(w)}`;
                            return typeof Blob > "u" || this._options.jsdom ? ye.Buffer.from(D) : new Blob([
                                D
                            ], {
                                type: M
                            });
                        }
                        return new Promise((D)=>{
                            const A = w;
                            if ("toBuffer" in A) if (M === "image/png") D(A.toBuffer(M));
                            else if (M === "image/jpeg") D(A.toBuffer(M));
                            else {
                                if (M !== "application/pdf") throw Error("Unsupported extension");
                                D(A.toBuffer(M));
                            }
                            else "toBlob" in A && A.toBlob(D, M, 1);
                        });
                    }
                    async download(y) {
                        if (!this._qr) throw "QR code is empty";
                        if (typeof Blob > "u") throw "Cannot download in Node.js, call getRawData instead.";
                        let w = "png", M = "qr";
                        typeof y == "string" ? (w = y, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : typeof y == "object" && y !== null && (y.name && (M = y.name), y.extension && (w = y.extension));
                        const D = await this._getElement(w);
                        if (D) if (w.toLowerCase() === "svg") {
                            let A = new XMLSerializer().serializeToString(D);
                            A = `<?xml version="1.0" standalone="no"?>\r
` + A, u(`data:${B(w)};charset=utf-8,${encodeURIComponent(A)}`, `${M}.svg`);
                        } else u(D.toDataURL(B(w)), `${M}.${w}`);
                    }
                }
                const T = C;
            })(), i.default;
        })());
})(B0);
var jb = B0.exports;
const Dh = /* @__PURE__ */ Di(jb), Oe = {
    QR_CODE: 260,
    LOADING_LOGO: 80,
    MODAL_WIDTH: 343,
    MODAL_BORDER_RADIUS: 20,
    QR_CARD_PADDING: 28,
    BUTTON_PADDING_VERTICAL: 16,
    BUTTON_PADDING_HORIZONTAL: 20,
    BUTTON_BORDER_RADIUS: 12,
    ICON_SMALL: 24,
    ICON_MEDIUM: 28,
    ICON_LARGE: 80,
    CLOSE_BUTTON_SIZE: 34,
    HEADER_PADDING: 18
}, Er = {
    QR_RENDER_DELAY: 100,
    COPY_FEEDBACK_DURATION: 2e3,
    ANIMATION_DURATION: 200,
    SAFARI_CONNECT_DELAY: 0,
    NON_SAFARI_CONNECT_DELAY: 100
}, So = {
    OVERLAY: 9999,
    LOADING_BORDER_AFTER: 1,
    LOADING_LOGO: 2
}, NR = {
    BACKGROUND_COLOR: "#000637",
    TEXT_COLOR: "#F5F4E7",
    PRIMARY_COLOR: "#0ea5e9",
    FONT_FAMILY: "'Karla', sans-serif"
}, gt = {
    SIZE: 260,
    MARGIN: 0,
    IMAGE_MARGIN: 6,
    IMAGE_SIZE: 0.25,
    DOT_COLOR: "#000637",
    ERROR_CORRECTION_LEVEL: "Q",
    DOT_TYPE: "rounded",
    BACKGROUND_COLOR: "transparent"
}, nn = {
    THRESHOLD: 0.5,
    GAMMA_CORRECTION_THRESHOLD: 0.03928,
    GAMMA_CORRECTION_DIVISOR: 12.92,
    GAMMA_CORRECTION_OFFSET: 0.055,
    GAMMA_CORRECTION_POWER: 2.4,
    GAMMA_CORRECTION_BASE: 1.055,
    RED_WEIGHT: 0.2126,
    GREEN_WEIGHT: 0.7152,
    BLUE_WEIGHT: 0.0722
}, pi = {
    HOVER_BRIGHTNESS: 0.15,
    MAX_COLOR_VALUE: 255
}, F0 = {
    SAFARI: /^((?!chrome|android).)*safari/i,
    MOBILE: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i
}, Oo = {
    USER_REJECTED: 4001,
    POPUP_CLOSED: -32002
}, xR = {
    QR_URL_PATTERN: "xumm.app/sign",
    QR_IMAGE_EXTENSION: ".png"
}, Mt = {
    LIGHT: 300,
    REGULAR: 400,
    MEDIUM: 500,
    SEMIBOLD: 600
};
function Cb(r) {
    const e = r.replace("#", ""), t = parseInt(e.substring(0, 2), 16) / pi.MAX_COLOR_VALUE, n = parseInt(e.substring(2, 4), 16) / pi.MAX_COLOR_VALUE, s = parseInt(e.substring(4, 6), 16) / pi.MAX_COLOR_VALUE, [i, o, a] = [
        t,
        n,
        s
    ].map((u)=>u <= nn.GAMMA_CORRECTION_THRESHOLD ? u / nn.GAMMA_CORRECTION_DIVISOR : Math.pow((u + nn.GAMMA_CORRECTION_OFFSET) / nn.GAMMA_CORRECTION_BASE, nn.GAMMA_CORRECTION_POWER));
    return nn.RED_WEIGHT * i + nn.GREEN_WEIGHT * o + nn.BLUE_WEIGHT * a;
}
function IR(r) {
    return Cb(r) < nn.THRESHOLD ? "#ffffff" : "#000000";
}
function _h(r, e) {
    const t = r.replace("#", ""), n = parseInt(t, 16), s = Math.round(pi.MAX_COLOR_VALUE * e);
    let i = (n >> 16) + s, o = (n >> 8 & 255) + s, a = (n & 255) + s;
    return i = Math.max(0, Math.min(pi.MAX_COLOR_VALUE, i)), o = Math.max(0, Math.min(pi.MAX_COLOR_VALUE, o)), a = Math.max(0, Math.min(pi.MAX_COLOR_VALUE, a)), `#${(i << 16 | o << 8 | a).toString(16).padStart(6, "0")}`;
}
function jo() {
    return F0.SAFARI.test(navigator.userAgent);
}
function Ah() {
    return F0.MOBILE.test(navigator.userAgent);
}
function Lb(r) {
    return r.includes("xumm.app/sign") && r.includes(".png");
}
function TR(r, e) {
    return r.length <= e ? r : r.substring(0, e) + "...";
}
function vs(r) {
    return new Promise((e)=>setTimeout(e, r));
}
const Me = rc("[WalletConnector]");
let Sh = null;
if (("TURBOPACK compile-time value", "undefined") < "u" && typeof HTMLElement < "u") {
    class r extends HTMLElement {
        constructor(){
            super(), this.walletManager = null, this.isOpen = !1, this.isFirstOpen = !0, this.primaryWalletId = null, this.viewState = "list", this.qrCodeData = null, this.loadingData = null, this.errorData = null, this.accountSelectionData = null, this.previousModalHeight = 0, this.preGeneratedQRCode = null, this.preGeneratedURI = null, this.specifiedWalletIds = [], this.availableWallets = [], this.walletAvailabilityChecked = !1, this.accountModalOpen = !1, this.accountBalance = null, this.shadow = this.attachShadow({
                mode: "open"
            });
        }
        // Cached account balance
        // Observed attributes
        static get observedAttributes() {
            return [
                "primary-wallet",
                "wallets"
            ];
        }
        connectedCallback() {
            this.render(), requestAnimationFrame(()=>this.updateDerivedColors()), new MutationObserver(()=>{
                this.updateDerivedColors();
            }).observe(this, {
                attributes: !0,
                attributeFilter: [
                    "style"
                ]
            });
        }
        /**
     * Update derived colors (like hover states) based on color changes
     */ updateDerivedColors() {
            const t = window.getComputedStyle(this), n = t.getPropertyValue("--xc-primary-color").trim() || "#0EA5E9", s = t.getPropertyValue("--xc-background-color").trim() || "#000637", i = _h(n, 0.15), o = _h(s, 0.15);
            this.style.setProperty("--xc-primary-button-hover-background", i), this.style.setProperty("--xc-connect-button-hover-background", o), this.style.setProperty("--xc-account-address-button-hover-color", i);
        }
        attributeChangedCallback(t, n, s) {
            this.shadow.children.length > 0 && this.render();
        }
        /**
     * Set the WalletManager instance
     */ setWalletManager(t) {
            this.walletManager = t, this.walletManager.on("connect", ()=>{
                this.close(), this.render();
            }), this.walletManager.on("disconnect", ()=>{
                this.render();
            }), this.walletManager.on("accountChanged", ()=>{
                this.render();
            }), this.render(), this.checkXamanStateOnInit();
        }
        /**
     * Check for existing Xaman authentication on page load
     */ async checkXamanStateOnInit() {
            var t, n;
            try {
                if (this.listAdapters().includes("xaman")) {
                    const s = (n = (t = this.walletManager) == null ? void 0 : t.adapters) == null ? void 0 : n.get("xaman");
                    if (!s) return;
                    await s.checkXamanState() && this.walletManager && !this.walletManager.connected && await this.walletManager.connect("xaman");
                }
            } catch (s) {
                console.error("Failed to check Xaman state:", s);
            }
        }
        /**
     * Parse wallet IDs from the 'wallets' attribute
     */ parseWalletAttribute() {
            var n;
            const t = this.getAttribute("wallets") || "";
            return t ? t.split(",").map((s)=>s.trim()).filter((s)=>s.length > 0) : ((n = this.walletManager) == null ? void 0 : n.wallets.map((s)=>s.id)) || [];
        }
        listAdapters() {
            var n;
            const t = [];
            if (!((n = this.walletManager) != null && n.wallets)) return t;
            for (const s of Object.values(this.walletManager.wallets))t.push(s.id);
            return t;
        }
        /**
     * Check which wallets are available
     * Filters wallets based on 'wallets' attribute and checks isAvailable() on each
     */ async checkWalletAvailability() {
            if (!this.walletManager || !this.walletManager.wallets.length) {
                Me.warn("No wallet manager or wallets registered"), this.availableWallets = [];
                return;
            }
            try {
                this.specifiedWalletIds = this.parseWalletAttribute(), Me.debug("Checking availability for wallets:", this.specifiedWalletIds);
                const t = this.walletManager.wallets.filter((s)=>this.specifiedWalletIds.includes(s.id)), n = await Promise.all(t.map(async (s)=>{
                    try {
                        const i = await s.isAvailable();
                        return Me.debug(`Wallet ${s.id} availability: ${i}`), {
                            wallet: s,
                            available: i
                        };
                    } catch (i) {
                        return Me.warn(`Error checking availability for ${s.id}:`, i), {
                            wallet: s,
                            available: !1
                        };
                    }
                }));
                this.availableWallets = this.specifiedWalletIds.map((s)=>{
                    var i;
                    return (i = n.find((o)=>o.wallet.id === s)) == null ? void 0 : i.wallet;
                }).filter((s)=>{
                    var i;
                    return (s !== void 0 && ((i = n.find((o)=>o.wallet.id === s.id)) == null ? void 0 : i.available)) ?? !1;
                }), Me.debug("Available wallets:", this.availableWallets.map((s)=>s.id));
            } catch (t) {
                Me.error("Error checking wallet availability:", t), this.availableWallets = [];
            }
        }
        /**
     * Open the modal
     */ async open() {
            this.isOpen = !0, this.isFirstOpen = !0, document.body.style.overflow = "hidden", this.walletAvailabilityChecked || (await this.checkWalletAvailability(), this.walletAvailabilityChecked = !0), this.render(), this.dispatchEvent(new CustomEvent("open")), this.preInitializeWalletConnect();
        }
        /**
     * Close the modal
     */ close() {
            this.isOpen = !1, document.body.style.overflow = "", this.viewState = "list", this.qrCodeData = null, this.loadingData = null, this.errorData = null, this.accountSelectionData = null, this.render(), this.dispatchEvent(new CustomEvent("close"));
        }
        /**
     * Toggle the modal
     */ toggle() {
            this.isOpen ? this.close() : this.open();
        }
        /**
     * Open the account details modal
     */ openAccountModal() {
            this.accountModalOpen = !0, this.render();
        }
        /**
     * Close the account details modal
     */ closeAccountModal() {
            this.accountModalOpen = !1, this.render();
        }
        /**
     * Disconnect wallet from the account modal
     */ async disconnectFromAccountModal() {
            var t;
            try {
                await ((t = this.walletManager) == null ? void 0 : t.disconnect()), this.closeAccountModal(), this.render();
            } catch (n) {
                Me.error("Failed to disconnect:", n);
            }
        }
        /**
     * Set the account balance to display in the account modal
     */ setAccountBalance(t) {
            this.accountBalance = t, this.render();
        }
        /**
     * Get the current account balance
     */ getAccountBalance() {
            return this.accountBalance;
        }
        /**
     * Pre-initialize WalletConnect when modal opens to reduce loading time
     * Based on ConnectKit's eager initialization pattern
     */ async preInitializeWalletConnect() {
            var n, s;
            if (!this.walletManager) return;
            const t = this.walletManager.wallets.find((i)=>i.id === "walletconnect");
            if (t && typeof t.preInitialize == "function") try {
                Me.debug("Pre-initializing WalletConnect...");
                const i = (n = t.options) == null ? void 0 : n.projectId, o = (s = this.walletManager.options) == null ? void 0 : s.network;
                t.options || (t.options = {}), t.options.onQRCode = (a)=>{
                    Me.debug("Pre-generating QR code..."), this.preGenerateQRCode(a);
                }, await t.preInitialize(i, o);
            } catch (i) {
                Me.warn("Failed to pre-initialize WalletConnect:", i);
            }
        }
        /**
     * Pre-generate QR code to have it ready when user clicks WalletConnect
     */ async preGenerateQRCode(t) {
            var n;
            try {
                this.preGeneratedURI = t;
                const s = (n = this.walletManager) == null ? void 0 : n.wallets.find((o)=>o.id === "walletconnect"), i = new Dh({
                    width: gt.SIZE,
                    height: gt.SIZE,
                    type: "svg",
                    data: t,
                    image: s == null ? void 0 : s.icon,
                    margin: gt.MARGIN,
                    qrOptions: {
                        errorCorrectionLevel: gt.ERROR_CORRECTION_LEVEL
                    },
                    dotsOptions: {
                        type: gt.DOT_TYPE,
                        color: gt.DOT_COLOR
                    },
                    backgroundOptions: {
                        color: gt.BACKGROUND_COLOR
                    },
                    imageOptions: {
                        crossOrigin: "anonymous",
                        margin: gt.IMAGE_MARGIN,
                        imageSize: gt.IMAGE_SIZE
                    }
                });
                this.preGeneratedQRCode = i, Me.debug("QR code pre-generated successfully");
            } catch (s) {
                Me.warn("Failed to pre-generate QR code:", s);
            }
        }
        /**
     * Connect to a specific wallet
     */ async connectWallet(t, n) {
            var s, i, o;
            if (!this.walletManager) {
                Me.error("WalletManager not set");
                return;
            }
            try {
                const a = this.walletManager.wallets.find((u)=>u.id === t);
                if (!a) throw new Error("Wallet not found");
                if (Me.debug("Connecting to wallet:", t), t === "walletconnect") {
                    const u = a, c = ((s = u.options) == null ? void 0 : s.useModal) ?? !1, l = ((i = u.options) == null ? void 0 : i.modalMode) ?? "mobile-only";
                    if (c && (l === "always" || l === "mobile-only" && Ah())) Me.debug("Using WalletConnect modal (mobile deeplink mode)"), this.showLoadingView(t, a.name, a.icon), this.dispatchEvent(new CustomEvent("connecting", {
                        detail: {
                            walletId: t
                        }
                    })), await vs(Er.NON_SAFARI_CONNECT_DELAY), await this.walletManager.connect(t, n), this.dispatchEvent(new CustomEvent("connected", {
                        detail: {
                            walletId: t
                        }
                    })), this.close();
                    else {
                        Me.debug("Using custom QR code (desktop mode)"), this.showQRCodeView(t);
                        const h = {
                            ...n,
                            onQRCode: (f)=>{
                                Me.debug("QR code callback received:", f.substring(0, 50) + "..."), this.setQRCode(t, f);
                            }
                        };
                        this.dispatchEvent(new CustomEvent("connecting", {
                            detail: {
                                walletId: t
                            }
                        })), await this.walletManager.connect(t, h), this.dispatchEvent(new CustomEvent("connected", {
                            detail: {
                                walletId: t
                            }
                        }));
                    }
                } else if (t === "ledger") {
                    if (!await a.isAvailable()) throw new Error(`${a.name} is not supported in this browser. Please use Chrome, Edge, or Opera.`);
                    this.showLoadingView(t, a.name, a.icon), jo() || await vs(Er.NON_SAFARI_CONNECT_DELAY), Me.debug("Fetching Ledger accounts...");
                    const c = await a.getAccounts(5, 0);
                    Me.debug("Fetched accounts:", c), this.showAccountSelectionView(t, a.name, a.icon, c);
                } else {
                    if (!await a.isAvailable()) throw new Error(`${a.name} is not installed. Please install the extension first.`);
                    this.showLoadingView(t, a.name, a.icon), this.dispatchEvent(new CustomEvent("connecting", {
                        detail: {
                            walletId: t
                        }
                    })), jo() || await vs(Er.NON_SAFARI_CONNECT_DELAY), await this.walletManager.connect(t, n), this.dispatchEvent(new CustomEvent("connected", {
                        detail: {
                            walletId: t
                        }
                    }));
                }
            } catch (a) {
                const u = (o = this.walletManager) == null ? void 0 : o.wallets.find((d)=>d.id === t);
                let c = a.message || "An unexpected error occurred", l = "failed";
                a.code === Oo.USER_REJECTED || c.toLowerCase().includes("user rejected") ? (l = "rejected", c = "Connection request was cancelled") : a.code === Oo.POPUP_CLOSED || c.toLowerCase().includes("already pending") ? (l = "unavailable", c = "Wallet popup was closed or did not respond. Please try again.") : c.toLowerCase().includes("not installed") && (l = "unavailable"), Me.debug("Connection error type:", l, "Code:", a.code), this.showErrorView(t, (u == null ? void 0 : u.name) || "Wallet", new Error(c)), this.dispatchEvent(new CustomEvent("error", {
                    detail: {
                        error: a,
                        walletId: t,
                        errorType: l
                    }
                })), Me.error("Failed to connect:", a);
            }
        }
        /**
     * Connect with selected Ledger account
     */ async connectWithLedgerAccount(t) {
            if (!this.walletManager || !this.accountSelectionData) return;
            const { walletId: n, walletName: s, walletIcon: i } = this.accountSelectionData;
            try {
                this.showLoadingView(n, s, i), jo() || await vs(Er.NON_SAFARI_CONNECT_DELAY), Me.debug("Connecting to Ledger with account index:", t), this.dispatchEvent(new CustomEvent("connecting", {
                    detail: {
                        walletId: n,
                        accountIndex: t
                    }
                })), await this.walletManager.connect(n, {
                    accountIndex: t
                }), this.dispatchEvent(new CustomEvent("connected", {
                    detail: {
                        walletId: n,
                        accountIndex: t
                    }
                }));
            } catch (o) {
                let a = o.message || "An unexpected error occurred", u = "failed";
                (o.code === Oo.USER_REJECTED || a.toLowerCase().includes("user rejected")) && (u = "rejected", a = "Connection request was cancelled"), Me.debug("Connection error type:", u, "Code:", o.code), this.showErrorView(n, s, new Error(a)), this.dispatchEvent(new CustomEvent("error", {
                    detail: {
                        error: o,
                        walletId: n,
                        errorType: u
                    }
                })), Me.error("Failed to connect:", o);
            }
        }
        /**
     * Connect with a custom derivation path for Ledger
     */ async connectWithCustomDerivationPath(t) {
            if (!this.walletManager || !this.accountSelectionData) return;
            const { walletId: n, walletName: s, walletIcon: i } = this.accountSelectionData;
            try {
                if (!/^44'\/144'\/\d+'\/\d+\/\d+$/.test(t)) throw new Error("Invalid derivation path format. Expected format: 44'/144'/0'/0/0");
                this.showLoadingView(n, s, i), jo() || await vs(Er.NON_SAFARI_CONNECT_DELAY), Me.debug("Connecting to Ledger with custom derivation path:", t), this.dispatchEvent(new CustomEvent("connecting", {
                    detail: {
                        walletId: n,
                        derivationPath: t
                    }
                })), await this.walletManager.connect(n, {
                    derivationPath: t
                }), this.dispatchEvent(new CustomEvent("connected", {
                    detail: {
                        walletId: n,
                        derivationPath: t
                    }
                }));
            } catch (o) {
                let a = o.message || "An unexpected error occurred", u = "failed";
                (o.code === Oo.USER_REJECTED || a.toLowerCase().includes("user rejected")) && (u = "rejected", a = "Connection request was cancelled"), Me.debug("Connection error type:", u, "Code:", o.code), this.showErrorView(n, s, new Error(a)), this.dispatchEvent(new CustomEvent("error", {
                    detail: {
                        error: o,
                        walletId: n,
                        errorType: u
                    }
                })), Me.error("Failed to connect:", o);
            }
        }
        /**
     * Show QR code view
     */ showQRCodeView(t, n) {
            this.viewState = "qr", this.qrCodeData = {
                walletId: t,
                uri: n || ""
            }, this.loadingData = null, this.errorData = null, this.accountSelectionData = null, this.render();
        }
        /**
     * Show loading view
     */ showLoadingView(t, n, s) {
            this.viewState = "loading", this.loadingData = {
                walletId: t,
                walletName: n,
                walletIcon: s
            }, this.qrCodeData = null, this.errorData = null, this.accountSelectionData = null, this.render();
        }
        /**
     * Show error view
     */ showErrorView(t, n, s) {
            this.viewState = "error", this.errorData = {
                walletId: t,
                walletName: n,
                error: s
            }, this.qrCodeData = null, this.loadingData = null, this.accountSelectionData = null, this.render();
        }
        /**
     * Show wallet list view
     */ showWalletList() {
            this.viewState = "list", this.qrCodeData = null, this.loadingData = null, this.errorData = null, this.accountSelectionData = null, this.render();
        }
        /**
     * Show account selection view
     */ showAccountSelectionView(t, n, s, i) {
            this.viewState = "account-selection", this.accountSelectionData = {
                walletId: t,
                walletName: n,
                walletIcon: s,
                accounts: i
            }, this.qrCodeData = null, this.loadingData = null, this.errorData = null, this.render();
        }
        /**
     * Update QR code with URI
     * Called by wallet adapters when QR code URI is ready
     */ setQRCode(t, n) {
            var s, i;
            Me.debug("setQRCode called:", {
                walletId: t,
                uri: n.substring(0, 60) + "...",
                viewState: this.viewState,
                qrCodeData: this.qrCodeData
            }), this.viewState === "qr" && ((s = this.qrCodeData) == null ? void 0 : s.walletId) === t ? (this.qrCodeData.uri = n, setTimeout(()=>{
                Me.debug("Attempting to render QR code...");
                const o = this.shadow.querySelector("#qr-container");
                Me.debug("QR container found:", !!o), this.renderQRCode(n);
            }, Er.QR_RENDER_DELAY)) : Me.warn("QR code view not active or wallet mismatch", {
                viewState: this.viewState,
                expectedWallet: t,
                currentDataWallet: (i = this.qrCodeData) == null ? void 0 : i.walletId
            });
        }
        /**
     * Render QR code using QRCodeStyling library
     * Supports both URI strings and direct image URLs (for Xaman)
     */ async renderQRCode(t) {
            var s;
            Me.debug("renderQRCode called with URI:", t.substring(0, 60) + "...");
            const n = this.shadow.querySelector("#qr-container");
            if (!n || !t) {
                Me.warn("No container or URI for QR code rendering");
                return;
            }
            try {
                if (Lb(t)) {
                    Me.debug("Using direct QR code image from Xaman"), n.innerHTML = `
          <img
            src="${t}"
            alt="QR Code"
            style="width: ${Oe.QR_CODE}px; height: ${Oe.QR_CODE}px; border-radius: 16px; display: block;"
          />
        `;
                    return;
                }
                if (this.preGeneratedQRCode && this.preGeneratedURI === t) {
                    Me.debug("Using pre-generated QR code - instant render!"), n.innerHTML = "", this.preGeneratedQRCode.append(n);
                    return;
                }
                Me.debug("Generating modern QR code from URI");
                const i = (s = this.walletManager) == null ? void 0 : s.wallets.find((a)=>{
                    var u;
                    return a.id === ((u = this.qrCodeData) == null ? void 0 : u.walletId);
                }), o = new Dh({
                    width: gt.SIZE,
                    height: gt.SIZE,
                    type: "svg",
                    data: t,
                    image: i == null ? void 0 : i.icon,
                    margin: gt.MARGIN,
                    qrOptions: {
                        errorCorrectionLevel: gt.ERROR_CORRECTION_LEVEL
                    },
                    dotsOptions: {
                        type: gt.DOT_TYPE,
                        color: gt.DOT_COLOR
                    },
                    backgroundOptions: {
                        color: gt.BACKGROUND_COLOR
                    },
                    imageOptions: {
                        crossOrigin: "anonymous",
                        margin: gt.IMAGE_MARGIN,
                        imageSize: gt.IMAGE_SIZE
                    }
                });
                n.innerHTML = "", o.append(n), Me.debug("Modern QR code generated successfully");
            } catch (i) {
                Me.error("Failed to generate QR code:", i), n.innerHTML = `
        <div class="qr-loading" style="color: #ef4444;">
          Failed to generate QR code
        </div>
      `;
            }
        }
        /**
     * Truncate address for display
     */ truncateAddress(t, n = 6) {
            return t.length <= n * 2 ? t : `${t.substring(0, n)}...${t.substring(t.length - n)}`;
        }
        /**
     * Generate a deterministic gradient from wallet address
     * Creates a unique color pair based on the address hash
     */ generateGradientFromAddress(t) {
            let n = 0;
            for(let u = 0; u < t.length; u++){
                const c = t.charCodeAt(u);
                n = (n << 5) - n + c, n = n & n;
            }
            const s = Math.abs(n % 360), i = (s + 60) % 360, o = `hsl(${s}, 70%, 55%)`, a = `hsl(${i}, 70%, 55%)`;
            return {
                color1: o,
                color2: a
            };
        }
        /**
     * Render the component
     */ render() {
            var h, f, g;
            const t = this.shadow.querySelector(".modal");
            t && (this.previousModalHeight = t.offsetHeight), this.primaryWalletId = this.getAttribute("primary-wallet");
            const n = ((h = this.walletManager) == null ? void 0 : h.connected) || !1, s = (f = this.walletManager) == null ? void 0 : f.account, i = n && s ? this.truncateAddress(s.address, 4) : "Connect Wallet", o = this.walletAvailabilityChecked && this.availableWallets.length > 0 ? this.availableWallets : ((g = this.walletManager) == null ? void 0 : g.wallets) || [], a = this.primaryWalletId ? o.find((p)=>p.id === this.primaryWalletId) : null, u = o.filter((p)=>p.id !== this.primaryWalletId);
            let c = "";
            this.viewState === "qr" && this.qrCodeData ? c = this.renderQRView() : this.viewState === "loading" && this.loadingData ? c = this.renderLoadingView() : this.viewState === "error" && this.errorData ? c = this.renderErrorView() : this.viewState === "account-selection" && this.accountSelectionData ? c = this.renderAccountSelectionView() : c = this.renderWalletListView(a, u);
            const l = this.isFirstOpen ? "overlay fade-in" : "overlay", d = this.isFirstOpen ? "modal slide-up" : "modal";
            this.isFirstOpen && (this.isFirstOpen = !1), this.shadow.innerHTML = `
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Karla:wght@300;400;600&display=swap');

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: var(--font-family);
        color: var(--text-color);
      }

      html, body {
        overflow-y: overlay;
      }

      :host {
        /* Defaults for CSS variables - can be overridden via style attribute or CSS */
        /* General */
        --xc-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        --xc-border-radius: 12px;
        --xc-overlay-background: rgba(0, 0, 0, 0.7);
        --xc-overlay-backdrop-filter: blur(0px);

        /* Colors */
        --xc-primary-color: #0EA5E9;
        --xc-background-color: #000637;
        --xc-text-color: #F5F4E7;
        --xc-text-muted-color: rgba(245, 244, 231, 0.6);
        --xc-background-secondary: #1a1a3e;
        --xc-background-tertiary: #242452;
        --xc-loading-border-color: #0EA5E9;

        /* Connect Button */
        --xc-connect-button-font-size: 16px;
        --xc-connect-button-border-radius: 8px;
        --xc-connect-button-color: var(--xc-text-color);
        --xc-connect-button-background: var(--xc-background-color);
        --xc-connect-button-border: 1px solid rgba(255, 255, 255, 0.1);
        --xc-connect-button-hover-background: var(--xc-background-color);
        --xc-connect-button-font-weight: 600;

        /* Primary Button */
        --xc-primary-button-color: #ffffff;
        --xc-primary-button-background: var(--xc-primary-color);
        --xc-primary-button-border-radius: 8px;
        --xc-primary-button-font-weight: 600;
        --xc-primary-button-hover-background: var(--xc-primary-color);

        /* Secondary Button */
        --xc-secondary-button-color: var(--xc-text-color);
        --xc-secondary-button-background: var(--xc-background-secondary);
        --xc-secondary-button-border-radius: 8px;
        --xc-secondary-button-font-weight: 500;
        --xc-secondary-button-hover-background: var(--xc-background-tertiary);

        /* Account Address Button */
        --xc-account-address-button-hover-color: var(--xc-primary-color);

        /* Modal */
        --xc-modal-background: var(--xc-background-color);
        --xc-modal-border-radius: 12px;
        --xc-modal-box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);

        /* Miscellaneous */
        --xc-focus-color: var(--xc-primary-color);
        --xc-danger-color: #ef4444;
        --xc-success-color: #10b981;
        --xc-warning-color: #f59e0b;

        /* Internal aliases */
        --bg-color: var(--xc-background-color);
        --text-color: var(--xc-text-color);
        --primary-color: var(--xc-primary-color);
        --primary-bn-hover: var(--xc-primary-button-hover-background);
        --font-family: var(--xc-font-family);
        --wallet-btn-bg: var(--xc-background-secondary);
        --wallet-btn-hover: var(--xc-background-tertiary);
      }

      /* WalletConnect Modal Overrides */
      /* These styles ensure the WalletConnect modal appears correctly and matches your theme */
      wcm-modal,
      w3m-modal {
        /* Ensure modal appears on top of everything */
        --wcm-z-index: 2147483647 !important;
        --w3m-z-index: 2147483647 !important;

        /* Match your app's theme (optional) */
        --wcm-accent-color: var(--xc-primary-color) !important;
        --wcm-background-color: var(--xc-background-color) !important;
      }

      @keyframes heightChange {
        from { height: var(--old-height); }
        to { height: var(--new-height); }
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--xc-overlay-background);
        backdrop-filter: var(--xc-overlay-backdrop-filter);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: ${So.OVERLAY};
      }

      .overlay.fade-in {
        animation: fadeIn ${Er.ANIMATION_DURATION}ms ease-out;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .modal {
        background: var(--xc-modal-background);
        color: var(--xc-text-color);
        border-radius: var(--xc-modal-border-radius);
        width: ${Oe.MODAL_WIDTH}px;
        max-width: calc(100vw - 32px);
        max-height: 85vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        box-shadow: var(--xc-modal-box-shadow);
        border: 1px solid rgba(255, 255, 255, 0.08);
        transition: height ${Er.ANIMATION_DURATION}ms cubic-bezier(0.25, 0.1, 0.25, 1);
      }

      .modal.slide-up {
        animation: slideUp 0.3s ease-out;
      }

      @keyframes slideUp {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: ${Oe.HEADER_PADDING}px 20px 16px;
      }

      .header-with-back {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .back-button {
        width: ${Oe.CLOSE_BUTTON_SIZE}px;
        height: ${Oe.CLOSE_BUTTON_SIZE}px;
        border-radius: 50%;
        border: none;
        background: transparent;
        color: var(--text-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        opacity: 0.7;
        transition: all 0.2s;
      }

      .back-button:hover {
        opacity: 1;
        background: var(--wallet-btn-bg);
      }

      .title {
        font-size: 22px;
        font-weight: ${Mt.SEMIBOLD};
        letter-spacing: -0.3px;
        flex: 1;
      }

      .close-button {
        width: ${Oe.CLOSE_BUTTON_SIZE}px;
        height: ${Oe.CLOSE_BUTTON_SIZE}px;
        border-radius: 50%;
        border: none;
        background: transparent;
        color: var(--text-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        opacity: 0.7;
        transition: all 0.2s;
      }

      .close-button:hover {
        opacity: 1;
        background: var(--wallet-btn-bg);
      }

      .content {
        flex: 1;
        overflow-y: hidden;
        padding: 0 24px 24px;
        transition: opacity 0.3s ease;
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      .content::-webkit-scrollbar {
        display: none;
      }

      .connect-button {
        padding: ${Oe.BUTTON_PADDING_VERTICAL}px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: var(--xc-connect-button-border-radius);
        border: var(--xc-connect-button-border);
        background: var(--xc-connect-button-background);
        color: var(--xc-connect-button-color);
        font-size: var(--xc-connect-button-font-size);
        font-weight: var(--xc-connect-button-font-weight);
        cursor: pointer;
        transition: all 0.2s;
        font-family: var(--xc-font-family);
      }

      .connect-button:hover {
        background: var(--xc-connect-button-hover-background);
      }

      .primary-button {
        width: 100%;
        padding: ${Oe.BUTTON_PADDING_VERTICAL}px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: var(--xc-primary-button-border-radius);
        border: none;
        margin-bottom: 20px;
        background: var(--xc-primary-button-background);
        color: var(--xc-primary-button-color);
        font-size: 16px;
        font-weight: var(--xc-primary-button-font-weight);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        transition: all 0.2s;
      }

      .primary-button:hover {
          background: var(--xc-primary-button-hover-background);
      }

      .wallet-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .wallet-button {
        width: 100%;
        padding: ${Oe.BUTTON_PADDING_VERTICAL}px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: var(--xc-secondary-button-border-radius);
        border: none;
        background: var(--xc-secondary-button-background);
        color: var(--xc-secondary-button-color);
        font-size: 16px;
        font-weight: var(--xc-secondary-button-font-weight);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: background 0.2s;
      }

      .wallet-button:hover {
        background: var(--xc-secondary-button-hover-background);
      }

      .wallet-button img {
        border-radius: 6px;
      }

      .qr-view {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 20px 0;
      }

      .qr-card {
        background: #fff;
        border-radius: ${Oe.MODAL_BORDER_RADIUS}px;
        padding: ${Oe.QR_CARD_PADDING}px;
        width: 100%;
        max-width: 295px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.12), 0 0 0 1px rgba(0,0,0,0.05);
        border: 1px solid rgba(0,0,0,0.06);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 18px;
      }

      .qr-header {
        font-size: 16px;
        font-weight: ${Mt.SEMIBOLD};
        color: #111;
      }

      .qr-container {
        width: ${Oe.QR_CODE}px;
        height: ${Oe.QR_CODE}px;
        border-radius: 16px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        background: white;
      }

      .qr-container img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .qr-loading {
        font-size: 14px;
        color: #555;
      }

      .qr-footer {
        width: 100%;
        display: flex;
        justify-content: center;
      }

      .copy-button {
        padding: 12px 16px;
        border: none;
        border-radius: 10px;
        background: #f3f3f3;
        color: #111;
        font-weight: ${Mt.MEDIUM};
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .copy-button:hover {
        background: #e5e5e5;
      }

      .qr-placeholder {
        width: 280px;
        height: 280px;
        background: white;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .qr-instructions {
        text-align: center;
        font-size: 14px;
        opacity: 0.8;
        line-height: 1.5;
      }

      .qr-deeplink {
        width: 100%;
        margin-top: 10px;
      }

      .deeplink-button {
        width: 100%;
        padding: 14px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: ${Oe.BUTTON_BORDER_RADIUS}px;
        border: none;
        background: var(--primary-color);
        color: white;
        font-size: 15px;
        font-weight: ${Mt.SEMIBOLD};
        cursor: pointer;
        transition: all 0.2s;
      }

      .deeplink-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(14, 165, 233, 0.3);
      }

      /* Loading View */
      .loading-view {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 24px;
        padding: 40px 0;
      }

      .loading-logo-container {
        position: relative;
        width: 120px;
        height: 120px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .loading-logo {
        width: ${Oe.LOADING_LOGO}px;
        height: ${Oe.LOADING_LOGO}px;
        border-radius: 16px;
        z-index: ${So.LOADING_LOGO};
        position: relative;
      }

      .loading-border {
        position: absolute;
        top: -4px;
        left: -4px;
        right: -4px;
        bottom: -4px;
        border-radius: 20px;
        overflow: hidden;
      }

      .loading-border::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: conic-gradient(
          transparent 0deg 90deg,
          var(--xc-loading-border-color) 90deg 180deg,
          transparent 180deg 270deg,
          var(--xc-loading-border-color) 270deg 360deg
        );
        animation: rotate 2s linear infinite;
      }

      .loading-border::after {
        content: '';
        position: absolute;
        top: 4px;
        left: 4px;
        right: 4px;
        bottom: 4px;
        background: var(--xc-background-color);
        border-radius: 16px;
        z-index: ${So.LOADING_BORDER_AFTER};
      }

      @keyframes rotate {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        text-align: center;
        font-size: 16px;
        font-weight: ${Mt.LIGHT};
        opacity: 0.9;
      }

      /* Error View */
      .error-view {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 30px 0;
      }

      .error-icon {
        width: ${Oe.ICON_LARGE}px;
        height: ${Oe.ICON_LARGE}px;
        border-radius: 50%;
        background: rgba(239, 68, 68, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 48px;
        color: #ef4444;
      }

      .error-text {
        text-align: center;
      }

      .error-title {
        font-size: 18px;
        font-weight: ${Mt.SEMIBOLD};
        margin-bottom: 8px;
      }

      .error-message {
        font-size: 14px;
        font-weight: ${Mt.LIGHT};
        opacity: 0.8;
        line-height: 1.5;
      }

      .error-buttons {
        width: 100%;
        display: flex;
        gap: 12px;
        margin-top: 10px;
      }

      .error-button {
        flex: 1;
        padding: 14px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: ${Oe.BUTTON_BORDER_RADIUS}px;
        border: none;
        font-size: 15px;
        font-weight: ${Mt.SEMIBOLD};
        cursor: pointer;
        transition: all 0.2s;
      }

      .error-button-primary {
        background: var(--primary-color);
        color: white;
      }

      .error-button-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(14, 165, 233, 0.3);
      }

      .error-button-secondary {
        background: var(--wallet-btn-bg);
        color: var(--text-color);
      }

      .error-button-secondary:hover {
        background: var(--wallet-btn-hover);
      }

      /* Account Selection Styles */
      .account-selection-view {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 20px 0;
      }

      .account-selection-wallet-icon {
        width: ${Oe.ICON_LARGE}px;
        height: ${Oe.ICON_LARGE}px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .wallet-icon-small {
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: 12px;
      }

      .account-selection-description {
        text-align: center;
        font-size: 14px;
        font-weight: ${Mt.LIGHT};
        opacity: 0.8;
        line-height: 1.5;
        margin: 0;
      }

      .account-list {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .account-button {
        width: 100%;
        padding: 16px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: ${Oe.BUTTON_BORDER_RADIUS}px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        background: var(--wallet-btn-bg);
        color: var(--text-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        transition: all 0.2s;
      }

      .account-button:hover {
        background: var(--wallet-btn-hover);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .account-info {
        display: flex;
        flex-direction: column;
        gap: 6px;
        text-align: left;
        width: 100%;
      }

      .account-address {
        font-size: 15px;
        font-weight: ${Mt.SEMIBOLD};
      }

      .account-address-value {
        font-size: 13px;
        font-weight: ${Mt.LIGHT};
        opacity: 0.7;
        font-family: monospace;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .custom-path-section {
        margin-top: 24px;
        padding-top: 24px;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        width: 100%;
      }

      .custom-path-label {
        font-size: 14px;
        font-weight: ${Mt.MEDIUM};
        margin-bottom: 12px;
        color: var(--text-color);
      }

      .custom-path-input {
        width: 100%;
        padding: 12px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: ${Oe.BUTTON_BORDER_RADIUS}px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: var(--wallet-btn-bg);
        color: var(--text-color);
        font-size: 14px;
        font-family: monospace;
        margin-bottom: 12px;
        box-sizing: border-box;
      }

      .custom-path-input:focus {
        outline: none;
        border-color: var(--primary-color, #007bff);
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
      }

      .custom-path-button {
        width: 100%;
        padding: 14px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: ${Oe.BUTTON_BORDER_RADIUS}px;
        border: none;
        background: var(--primary-color, #007bff);
        color: white;
        font-size: 15px;
        font-weight: ${Mt.SEMIBOLD};
        cursor: pointer;
        transition: all 0.2s;
      }

      .custom-path-button:hover {
        background: var(--primary-color-hover, #0056b3);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      .custom-path-button:active {
        transform: translateY(0);
      }

      /* Account Modal Styles */
      .account-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--xc-overlay-background);
        backdrop-filter: var(--xc-overlay-backdrop-filter);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: ${So.OVERLAY};
        animation: fadeIn ${Er.ANIMATION_DURATION}ms ease-out;
      }

      .account-modal {
        background: var(--xc-modal-background);
        color: var(--xc-text-color);
        border-radius: var(--xc-modal-border-radius);
        width: 100%;
        max-width: 280px;
        padding: 0;
        box-shadow: var(--xc-modal-box-shadow);
        border: 1px solid rgba(255, 255, 255, 0.08);
        animation: slideUp 0.3s ease-out;
        overflow: hidden;
      }

      .account-modal-header {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px 20px;
        background: rgba(255, 255, 255, 0.02);
        position: relative;
      }

      .account-modal-title {
        font-size: 16px;
        font-weight: ${Mt.SEMIBOLD};
        letter-spacing: -0.3px;
        flex: 1;
        text-align: center;
      }

      .account-modal-close {
        position: absolute;
        right: 8px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background: transparent;
        color: var(--text-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        opacity: 0.6;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .account-modal-close:hover {
        opacity: 1;
        background: var(--wallet-btn-bg);
      }

      .account-modal-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 24px 32px;
        gap: 0;
        text-align: center;
      }

      .account-avatar-container {
        width: 100px;
        height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        margin-bottom: 28px;
        flex-shrink: 0;
      }

      .account-info-section {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        margin-bottom: 24px;
      }

      .account-address-button {
        background: none;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        font-size: 14px;
        font-weight: ${Mt.SEMIBOLD};
        font-family: var(--font-family);
        padding: 0;
        transition: opacity 0.2s;
        letter-spacing: 0.3px;
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
      }

      .account-address-button:hover {
        color: var(--xc-account-address-button-hover-color);
      }

      .copy-icon {
        width: 20px;
        height: 20px;
        opacity: 0.5;
        transition: opacity 0.2s ease;
        flex-shrink: 0;
      }

      .account-address-button:hover .copy-icon {
        opacity: 1;
        color: var(--xc-account-address-button-hover-color);
      }

      .account-balance-display {
        display: flex;
        align-items: baseline;
        justify-content: center;
        gap: 8px;
      }

      .account-balance-value {
        font-size: 28px;
        font-weight: ${Mt.SEMIBOLD};
        color: var(--primary-color);
      }

      .account-balance-unit {
        font-size: 14px;
        font-weight: ${Mt.MEDIUM};
        opacity: 0.8;
      }

      .account-disconnect-button {
        width: 100%;
        padding: 12px ${Oe.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: var(--xc-secondary-button-border-radius);
        border: none;
        background: var(--xc-secondary-button-background);
        color: var(--xc-secondary-button-color);
        font-size: 14px;
        font-weight: var(--xc-secondary-button-font-weight);
        cursor: pointer;
        transition: all 0.2s;
        font-family: var(--xc-font-family);
        margin-top: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .account-disconnect-button:hover {
        background: var(--xc-secondary-button-hover-background);
      }

      .disconnect-icon {
        width: 15px;
        height: 14px;
        transition: opacity 0.2s ease;
        flex-shrink: 0;
      }

      .account-disconnect-button:hover .disconnect-icon {
        opacity: 1;
      }

      .account-disconnect-button:hover .disconnect-icon path {
        fill: #ef4444;
      }
    </style>

    <button class="connect-button" id="connect-wallet-button" part="connect-button">${i}</button>

    ${this.isOpen ? `
    <div class="${l}" part="overlay">
      <div class="${d}" part="modal">
        ${c}
      </div>
    </div>
    ` : ""}

    ${this.accountModalOpen ? this.renderAccountModal() : ""}
  `, this.attachEventListeners(), requestAnimationFrame(()=>{
                this.updateModalHeight();
            });
        }
        /**
     * Update modal height with smooth transition
     */ updateModalHeight() {
            const t = this.shadow.querySelector(".modal");
            if (!t) return;
            const n = this.previousModalHeight, s = t.offsetHeight;
            n > 0 && s > 0 && n !== s && (t.style.height = `${n}px`, t.offsetHeight, requestAnimationFrame(()=>{
                t.style.height = `${s}px`;
            })), this.previousModalHeight = s;
        }
        /**
     * Render wallet list view
     */ renderWalletListView(t, n) {
            return `
      <div class="header">
        <h2 class="title">Connect Wallet</h2>
        <button class="close-button" part="close-button" aria-label="Close"></button>
      </div>

      <div class="content">
        ${t ? `
          <button class="primary-button" data-wallet-id="${t.id}">
            ${t.icon ? `<img src="${t.icon}" width="24" height="24" alt="${t.name}">` : ""}
            <span>Continue with ${t.name}</span>
          </button>
        ` : ""}
        <div class="wallet-list">
          ${n.map((s)=>`
            <button class="wallet-button" data-wallet-id="${s.id}">
              <span>${s.name}</span>
              ${s.icon ? `<img src="${s.icon}" width="28" height="28" alt="${s.name}">` : ""}
            </button>`).join("")}
        </div>
      </div>
    `;
        }
        /**
     * Render QR code view
     */ renderQRView() {
            var s;
            const t = (s = this.walletManager) == null ? void 0 : s.wallets.find((i)=>{
                var o;
                return i.id === ((o = this.qrCodeData) == null ? void 0 : o.walletId);
            });
            return `
    <div class="header">
      <div class="header-with-back">
        <button class="back-button" id="back-button" aria-label="Back"></button>
        <h2 class="title">${(t == null ? void 0 : t.name) || "Wallet"}</h2>
      </div>
      <button class="close-button" part="close-button" aria-label="Close"></button>
    </div>

    <div class="content">
      <div class="qr-view">
        <div class="qr-card">
          <div class="qr-header">Scan with Phone</div>
          <div class="qr-container" id="qr-container">
            <div class="qr-loading">Loading QR...</div>
          </div>
          <div class="qr-footer">
            <button class="copy-button" id="copy-button">Copy to Clipboard</button>
          </div>
        </div>
      </div>
    </div>
  `;
        }
        /**
     * Render loading view
     */ renderLoadingView() {
            if (!this.loadingData) return "";
            const { walletName: t, walletIcon: n } = this.loadingData;
            return `
      <div class="header">
        <div class="header-with-back">
          <button class="back-button" id="loading-back-button" aria-label="Back"></button>
          <h2 class="title">Connect Wallet</h2>
        </div>
        <button class="close-button" part="close-button" aria-label="Close"></button>
      </div>

      <div class="content loading-content">
        <div class="loading-view">
          <div class="loading-logo-container">
            ${n ? `<img src="${n}" alt="${t}" class="loading-logo">` : ""}
            <div class="loading-border"></div>
          </div>
          <div class="loading-text">
            <p>Requesting connection...</p>
            <p style="margin-top: 8px; font-size: 14px; opacity: 0.7;">Check your ${t}</p>
          </div>
        </div>
      </div>
    `;
        }
        /**
     * Render error view
     */ renderErrorView() {
            if (!this.errorData) return "";
            const { walletName: t, error: n } = this.errorData;
            return `
      <div class="header">
        <h2 class="title">Connection Failed</h2>
        <button class="close-button" part="close-button" aria-label="Close"></button>
      </div>

      <div class="content">
        <div class="error-view">
          <div class="error-icon"></div>
          <div class="error-text">
            <div class="error-title">Failed to connect to ${t}</div>
            <div class="error-message">${n.message}</div>
          </div>
          <div class="error-buttons">
            <button class="error-button error-button-secondary" id="error-back-button">
              Back
            </button>
            <button class="error-button error-button-primary" id="error-retry-button">
              Try Again
            </button>
          </div>
        </div>
      </div>
    `;
        }
        /**
     * Render account selection view for Ledger
     */ renderAccountSelectionView() {
            if (!this.accountSelectionData) return "";
            const { walletName: t, walletIcon: n, accounts: s } = this.accountSelectionData, i = s.map((o)=>`
        <button class="account-button" data-account-index="${o.index}">
          <div class="account-info">
            <div class="account-address">Account ${o.index}</div>
            <div class="account-address-value">${o.address}</div>
          </div>
        </button>
      `).join("");
            return `
      <div class="header">
        <div class="header-with-back">
          <button class="back-button" id="account-selection-back-button" aria-label="Back"></button>
          <h2 class="title">Select Account</h2>
        </div>
        <button class="close-button" part="close-button" aria-label="Close"></button>
      </div>

      <div class="content">
        <div class="account-selection-view">
          ${n ? `
          <div class="account-selection-wallet-icon">
            <img src="${n}" alt="${t}" class="wallet-icon-small">
          </div>
          ` : ""}
          <p class="account-selection-description">Select which account to connect from your ${t}</p>
          <div class="account-list">
            ${i}
          </div>
          <div class="custom-path-section">
            <p class="custom-path-label">Or enter a custom derivation path:</p>
            <input
              type="text"
              id="custom-derivation-path"
              class="custom-path-input"
              placeholder="44'/144'/0'/0/0"
              value=""
            />
            <button class="custom-path-button" id="custom-path-connect-button">
              Connect with Custom Path
            </button>
          </div>
        </div>
      </div>
    `;
        }
        /**
     * Render account details modal
     */ renderAccountModal() {
            var o;
            const t = (o = this.walletManager) == null ? void 0 : o.account;
            if (!t) return "";
            const n = this.truncateAddress(t.address, 6), { color1: s, color2: i } = this.generateGradientFromAddress(t.address);
            return `
      <div id="account-modal-overlay" class="account-modal-overlay">
        <div class="account-modal">
          <div class="account-modal-header">
            <h2 class="account-modal-title">Connected</h2>
            <button class="account-modal-close" id="account-modal-close" aria-label="Close"></button>
          </div>

          <div class="account-modal-content">
            <div class="account-avatar-container" style="background: linear-gradient(135deg, ${s}, ${i});">
            </div>

            <div class="account-info-section">
              <button class="account-address-button" id="copy-account-address" title="Click to copy full address">
                <span>${n}</span>
                <svg
                  aria-hidden="true"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  class="copy-icon"
                >
                  <path d="M14 9.5V7C14 5.89543 13.1046 5 12 5H7C5.89543 5 5 5.89543 5 7V12C5 13.1046 5.89543 14 7 14H9.5" stroke="currentColor" stroke-width="2"></path>
                  <rect x="10" y="10" width="9" height="9" rx="2" stroke="currentColor" stroke-width="2"></rect>
                </svg>
              </button>

              ${this.accountBalance ? `
                <div class="account-balance-display">
                  <span class="account-balance-value">${this.accountBalance}</span>
                  <span class="account-balance-unit">XRP</span>
                </div>
              ` : ""}
            </div>

            <button class="account-disconnect-button" id="account-modal-disconnect">
              <svg
                aria-hidden="true"
                width="15"
                height="14"
                viewBox="0 0 15 14"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                class="disconnect-icon"
              >
                <path
                  fill-rule="evenodd"
                  clip-rule="evenodd"
                  d="M4 0C1.79086 0 0 1.79086 0 4V10C0 12.2091 1.79086 14 4 14H6C6.55228 14 7 13.5523 7 13C7 12.4477 6.55228 12 6 12H4C2.89543 12 2 11.1046 2 10V4C2 2.89543 2.89543 2 4 2H6C6.55228 2 7 1.55228 7 1C7 0.447715 6.55228 0 6 0H4ZM11.7071 3.29289C11.3166 2.90237 10.6834 2.90237 10.2929 3.29289C9.90237 3.68342 9.90237 4.31658 10.2929 4.70711L11.5858 6H9.5H6C5.44772 6 5 6.44772 5 7C5 7.55228 5.44772 8 6 8H9.5H11.5858L10.2929 9.29289C9.90237 9.68342 9.90237 10.3166 10.2929 10.7071C10.6834 11.0976 11.3166 11.0976 11.7071 10.7071L14.7071 7.70711C15.0976 7.31658 15.0976 6.68342 14.7071 6.29289L11.7071 3.29289Z"
                  fill="currentColor"
                  fill-opacity="0.4"
                ></path>
              </svg>
              <span>Disconnect</span>
            </button>
          </div>
        </div>
      </div>
    `;
        }
        /**
     * Attach event listeners
     */ attachEventListeners() {
            var t, n, s, i, o, a, u, c, l, d, h, f, g, p, m;
            (t = this.shadow.querySelector("#connect-wallet-button")) == null || t.addEventListener("click", async ()=>{
                var _;
                ((_ = this.walletManager) == null ? void 0 : _.connected) || !1 ? this.openAccountModal() : this.open();
            }), (n = this.shadow.querySelector("#account-modal-close")) == null || n.addEventListener("click", ()=>{
                this.closeAccountModal();
            }), (s = this.shadow.querySelector("#account-modal-disconnect")) == null || s.addEventListener("click", ()=>{
                this.disconnectFromAccountModal();
            }), (i = this.shadow.querySelector("#account-modal-overlay")) == null || i.addEventListener("click", (x)=>{
                x.target === x.currentTarget && this.closeAccountModal();
            }), (o = this.shadow.querySelector("#copy-account-address")) == null || o.addEventListener("click", async ()=>{
                var _, v;
                const x = (v = (_ = this.walletManager) == null ? void 0 : _.account) == null ? void 0 : v.address;
                if (x) try {
                    await navigator.clipboard.writeText(x);
                    const N = this.shadow.querySelector("#copy-account-address"), O = N.innerHTML;
                    N.innerHTML = "<span>Copied!</span>", setTimeout(()=>{
                        N && (N.innerHTML = O);
                    }, Er.COPY_FEEDBACK_DURATION);
                } catch (N) {
                    Me.error("Failed to copy address:", N);
                }
            }), (a = this.shadow.querySelector(".close-button")) == null || a.addEventListener("click", ()=>this.close()), (u = this.shadow.querySelector(".overlay")) == null || u.addEventListener("click", (x)=>{
                x.target === x.currentTarget && this.close();
            }), this.shadow.querySelectorAll("[data-wallet-id]").forEach((x)=>{
                x.addEventListener("click", ()=>{
                    const _ = x.dataset.walletId;
                    _ && this.connectWallet(_);
                });
            }), (c = this.shadow.querySelector("#back-button")) == null || c.addEventListener("click", ()=>{
                this.showWalletList();
            }), (l = this.shadow.querySelector("#loading-back-button")) == null || l.addEventListener("click", ()=>{
                this.showWalletList();
            }), (d = this.shadow.querySelector("#copy-button")) == null || d.addEventListener("click", async ()=>{
                var x;
                if ((x = this.qrCodeData) != null && x.uri) try {
                    await navigator.clipboard.writeText(this.qrCodeData.uri);
                    const _ = this.shadow.querySelector("#copy-button");
                    _ && (_.textContent = "Copied!", setTimeout(()=>_.textContent = "Copy to Clipboard", Er.COPY_FEEDBACK_DURATION));
                } catch (_) {
                    Me.error("Failed to copy to clipboard:", _);
                }
            }), (h = this.shadow.querySelector("#deeplink-button")) == null || h.addEventListener("click", ()=>{
                var x, _, v;
                if ((x = this.qrCodeData) != null && x.uri && (_ = this.qrCodeData) != null && _.walletId) {
                    const N = (v = this.walletManager) == null ? void 0 : v.wallets.find((z)=>{
                        var P;
                        return z.id === ((P = this.qrCodeData) == null ? void 0 : P.walletId);
                    });
                    let O = this.qrCodeData.uri;
                    N && typeof N.getDeepLinkURI == "function" && (O = N.getDeepLinkURI(this.qrCodeData.uri)), Ah() ? window.location.href = O : window.open(O, "_blank");
                }
            }), (f = this.shadow.querySelector("#error-retry-button")) == null || f.addEventListener("click", ()=>{
                var x;
                (x = this.errorData) != null && x.walletId && this.connectWallet(this.errorData.walletId);
            }), (g = this.shadow.querySelector("#error-back-button")) == null || g.addEventListener("click", ()=>{
                this.showWalletList();
            }), (p = this.shadow.querySelector("#account-selection-back-button")) == null || p.addEventListener("click", ()=>{
                this.showWalletList();
            }), this.shadow.querySelectorAll(".account-button").forEach((x)=>{
                x.addEventListener("click", ()=>{
                    const _ = parseInt(x.dataset.accountIndex || "0", 10);
                    Me.debug("Account selected:", _), this.connectWithLedgerAccount(_);
                });
            }), (m = this.shadow.querySelector("#custom-path-connect-button")) == null || m.addEventListener("click", ()=>{
                const x = this.shadow.querySelector("#custom-derivation-path");
                if (x && x.value.trim()) {
                    const _ = x.value.trim();
                    Me.debug("Custom derivation path entered:", _), this.connectWithCustomDerivationPath(_);
                }
            });
        }
    }
    Sh = r, customElements.get("xrpl-wallet-connector") || customElements.define("xrpl-wallet-connector", Sh);
}
var vd = {}, is = {}, Ed = {
    exports: {}
}, Zi = typeof Reflect == "object" ? Reflect : null, Oh = Zi && typeof Zi.apply == "function" ? Zi.apply : function(e, t, n) {
    return Function.prototype.apply.call(e, t, n);
}, ga;
Zi && typeof Zi.ownKeys == "function" ? ga = Zi.ownKeys : Object.getOwnPropertySymbols ? ga = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : ga = function(e) {
    return Object.getOwnPropertyNames(e);
};
function kb(r) {
    console && console.warn && console.warn(r);
}
var q0 = Number.isNaN || function(e) {
    return e !== e;
};
function Be() {
    Be.init.call(this);
}
Ed.exports = Be;
Ed.exports.once = Rb;
Be.EventEmitter = Be;
Be.prototype._events = void 0;
Be.prototype._eventsCount = 0;
Be.prototype._maxListeners = void 0;
var jh = 10;
function ic(r) {
    if (typeof r != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
}
Object.defineProperty(Be, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return jh;
    },
    set: function(r) {
        if (typeof r != "number" || r < 0 || q0(r)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
        jh = r;
    }
});
Be.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Be.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || q0(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
};
function Q0(r) {
    return r._maxListeners === void 0 ? Be.defaultMaxListeners : r._maxListeners;
}
Be.prototype.getMaxListeners = function() {
    return Q0(this);
};
Be.prototype.emit = function(e) {
    for(var t = [], n = 1; n < arguments.length; n++)t.push(arguments[n]);
    var s = e === "error", i = this._events;
    if (i !== void 0) s = s && i.error === void 0;
    else if (!s) return !1;
    if (s) {
        var o;
        if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
        var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
        throw a.context = o, a;
    }
    var u = i[e];
    if (u === void 0) return !1;
    if (typeof u == "function") Oh(u, this, t);
    else for(var c = u.length, l = W0(u, c), n = 0; n < c; ++n)Oh(l[n], this, t);
    return !0;
};
function V0(r, e, t, n) {
    var s, i, o;
    if (ic(t), i = r._events, i === void 0 ? (i = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (i.newListener !== void 0 && (r.emit("newListener", e, t.listener ? t.listener : t), i = r._events), o = i[e]), o === void 0) o = i[e] = t, ++r._eventsCount;
    else if (typeof o == "function" ? o = i[e] = n ? [
        t,
        o
    ] : [
        o,
        t
    ] : n ? o.unshift(t) : o.push(t), s = Q0(r), s > 0 && o.length > s && !o.warned) {
        o.warned = !0;
        var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a.name = "MaxListenersExceededWarning", a.emitter = r, a.type = e, a.count = o.length, kb(a);
    }
    return r;
}
Be.prototype.addListener = function(e, t) {
    return V0(this, e, t, !1);
};
Be.prototype.on = Be.prototype.addListener;
Be.prototype.prependListener = function(e, t) {
    return V0(this, e, t, !0);
};
function zb() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Y0(r, e, t) {
    var n = {
        fired: !1,
        wrapFn: void 0,
        target: r,
        type: e,
        listener: t
    }, s = zb.bind(n);
    return s.listener = t, n.wrapFn = s, s;
}
Be.prototype.once = function(e, t) {
    return ic(t), this.on(e, Y0(this, e, t)), this;
};
Be.prototype.prependOnceListener = function(e, t) {
    return ic(t), this.prependListener(e, Y0(this, e, t)), this;
};
Be.prototype.removeListener = function(e, t) {
    var n, s, i, o, a;
    if (ic(t), s = this._events, s === void 0) return this;
    if (n = s[e], n === void 0) return this;
    if (n === t || n.listener === t) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, n.listener || t));
    else if (typeof n != "function") {
        for(i = -1, o = n.length - 1; o >= 0; o--)if (n[o] === t || n[o].listener === t) {
            a = n[o].listener, i = o;
            break;
        }
        if (i < 0) return this;
        i === 0 ? n.shift() : Pb(n, i), n.length === 1 && (s[e] = n[0]), s.removeListener !== void 0 && this.emit("removeListener", e, a || t);
    }
    return this;
};
Be.prototype.off = Be.prototype.removeListener;
Be.prototype.removeAllListeners = function(e) {
    var t, n, s;
    if (n = this._events, n === void 0) return this;
    if (n.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
    if (arguments.length === 0) {
        var i = Object.keys(n), o;
        for(s = 0; s < i.length; ++s)o = i[s], o !== "removeListener" && this.removeAllListeners(o);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (t = n[e], typeof t == "function") this.removeListener(e, t);
    else if (t !== void 0) for(s = t.length - 1; s >= 0; s--)this.removeListener(e, t[s]);
    return this;
};
function G0(r, e, t) {
    var n = r._events;
    if (n === void 0) return [];
    var s = n[e];
    return s === void 0 ? [] : typeof s == "function" ? t ? [
        s.listener || s
    ] : [
        s
    ] : t ? Ub(s) : W0(s, s.length);
}
Be.prototype.listeners = function(e) {
    return G0(this, e, !0);
};
Be.prototype.rawListeners = function(e) {
    return G0(this, e, !1);
};
Be.listenerCount = function(r, e) {
    return typeof r.listenerCount == "function" ? r.listenerCount(e) : H0.call(r, e);
};
Be.prototype.listenerCount = H0;
function H0(r) {
    var e = this._events;
    if (e !== void 0) {
        var t = e[r];
        if (typeof t == "function") return 1;
        if (t !== void 0) return t.length;
    }
    return 0;
}
Be.prototype.eventNames = function() {
    return this._eventsCount > 0 ? ga(this._events) : [];
};
function W0(r, e) {
    for(var t = new Array(e), n = 0; n < e; ++n)t[n] = r[n];
    return t;
}
function Pb(r, e) {
    for(; e + 1 < r.length; e++)r[e] = r[e + 1];
    r.pop();
}
function Ub(r) {
    for(var e = new Array(r.length), t = 0; t < e.length; ++t)e[t] = r[t].listener || r[t];
    return e;
}
function Rb(r, e) {
    return new Promise(function(t, n) {
        function s(o) {
            r.removeListener(e, i), n(o);
        }
        function i() {
            typeof r.removeListener == "function" && r.removeListener("error", s), t([].slice.call(arguments));
        }
        K0(r, e, i, {
            once: !0
        }), e !== "error" && $b(r, s, {
            once: !0
        });
    });
}
function $b(r, e, t) {
    typeof r.on == "function" && K0(r, "error", e, t);
}
function K0(r, e, t, n) {
    if (typeof r.on == "function") n.once ? r.once(e, t) : r.on(e, t);
    else if (typeof r.addEventListener == "function") r.addEventListener(e, function s(i) {
        n.once && r.removeEventListener(e, s), t(i);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r);
}
var rr = Ed.exports;
const Md = /* @__PURE__ */ Di(rr);
var ei = {}, Co = {
    exports: {}
}, nu, Ch;
function Bb() {
    if (Ch) return nu;
    Ch = 1;
    var r = 1e3, e = r * 60, t = e * 60, n = t * 24, s = n * 7, i = n * 365.25;
    nu = function(l, d) {
        d = d || {};
        var h = typeof l;
        if (h === "string" && l.length > 0) return o(l);
        if (h === "number" && isFinite(l)) return d.long ? u(l) : a(l);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(l));
    };
    function o(l) {
        if (l = String(l), !(l.length > 100)) {
            var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(l);
            if (d) {
                var h = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
                switch(f){
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return h * i;
                    case "weeks":
                    case "week":
                    case "w":
                        return h * s;
                    case "days":
                    case "day":
                    case "d":
                        return h * n;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return h * t;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return h * e;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return h * r;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return h;
                    default:
                        return;
                }
            }
        }
    }
    function a(l) {
        var d = Math.abs(l);
        return d >= n ? Math.round(l / n) + "d" : d >= t ? Math.round(l / t) + "h" : d >= e ? Math.round(l / e) + "m" : d >= r ? Math.round(l / r) + "s" : l + "ms";
    }
    function u(l) {
        var d = Math.abs(l);
        return d >= n ? c(l, d, n, "day") : d >= t ? c(l, d, t, "hour") : d >= e ? c(l, d, e, "minute") : d >= r ? c(l, d, r, "second") : l + " ms";
    }
    function c(l, d, h, f) {
        var g = d >= h * 1.5;
        return Math.round(l / h) + " " + f + (g ? "s" : "");
    }
    return nu;
}
var iu, Lh;
function Fb() {
    if (Lh) return iu;
    Lh = 1;
    function r(e) {
        n.debug = n, n.default = n, n.coerce = c, n.disable = a, n.enable = i, n.enabled = u, n.humanize = Bb(), n.destroy = l, Object.keys(e).forEach((d)=>{
            n[d] = e[d];
        }), n.names = [], n.skips = [], n.formatters = {};
        function t(d) {
            let h = 0;
            for(let f = 0; f < d.length; f++)h = (h << 5) - h + d.charCodeAt(f), h |= 0;
            return n.colors[Math.abs(h) % n.colors.length];
        }
        n.selectColor = t;
        function n(d) {
            let h, f = null, g, p;
            function m(...x) {
                if (!m.enabled) return;
                const _ = m, v = Number(/* @__PURE__ */ new Date()), N = v - (h || v);
                _.diff = N, _.prev = h, _.curr = v, h = v, x[0] = n.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
                let O = 0;
                x[0] = x[0].replace(/%([a-zA-Z%])/g, (P, U)=>{
                    if (P === "%%") return "%";
                    O++;
                    const R = n.formatters[U];
                    if (typeof R == "function") {
                        const G = x[O];
                        P = R.call(_, G), x.splice(O, 1), O--;
                    }
                    return P;
                }), n.formatArgs.call(_, x), (_.log || n.log).apply(_, x);
            }
            return m.namespace = d, m.useColors = n.useColors(), m.color = n.selectColor(d), m.extend = s, m.destroy = n.destroy, Object.defineProperty(m, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: ()=>f !== null ? f : (g !== n.namespaces && (g = n.namespaces, p = n.enabled(d)), p),
                set: (x)=>{
                    f = x;
                }
            }), typeof n.init == "function" && n.init(m), m;
        }
        function s(d, h) {
            const f = n(this.namespace + (typeof h > "u" ? ":" : h) + d);
            return f.log = this.log, f;
        }
        function i(d) {
            n.save(d), n.namespaces = d, n.names = [], n.skips = [];
            const h = (typeof d == "string" ? d : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
            for (const f of h)f[0] === "-" ? n.skips.push(f.slice(1)) : n.names.push(f);
        }
        function o(d, h) {
            let f = 0, g = 0, p = -1, m = 0;
            for(; f < d.length;)if (g < h.length && (h[g] === d[f] || h[g] === "*")) h[g] === "*" ? (p = g, m = f, g++) : (f++, g++);
            else if (p !== -1) g = p + 1, m++, f = m;
            else return !1;
            for(; g < h.length && h[g] === "*";)g++;
            return g === h.length;
        }
        function a() {
            const d = [
                ...n.names,
                ...n.skips.map((h)=>"-" + h)
            ].join(",");
            return n.enable(""), d;
        }
        function u(d) {
            for (const h of n.skips)if (o(d, h)) return !1;
            for (const h of n.names)if (o(d, h)) return !0;
            return !1;
        }
        function c(d) {
            return d instanceof Error ? d.stack || d.message : d;
        }
        function l() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return n.enable(n.load()), n;
    }
    return iu = r, iu;
}
var kh;
function _i() {
    return kh || (kh = 1, function(r, e) {
        e.formatArgs = n, e.save = s, e.load = i, e.useColors = t, e.storage = o(), e.destroy = /* @__PURE__ */ (()=>{
            let u = !1;
            return ()=>{
                u || (u = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
            };
        })(), e.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33"
        ];
        function t() {
            if (("TURBOPACK compile-time value", "undefined") < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return !0;
            if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
            let u;
            return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
            ("TURBOPACK compile-time value", "undefined") < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            typeof navigator < "u" && navigator.userAgent && (u = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(u[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
            typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function n(u) {
            if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + r.exports.humanize(this.diff), !this.useColors) return;
            const c = "color: " + this.color;
            u.splice(1, 0, c, "color: inherit");
            let l = 0, d = 0;
            u[0].replace(/%[a-zA-Z%]/g, (h)=>{
                h !== "%%" && (l++, h === "%c" && (d = l));
            }), u.splice(d, 0, c);
        }
        e.log = console.debug || console.log || (()=>{});
        function s(u) {
            try {
                u ? e.storage.setItem("debug", u) : e.storage.removeItem("debug");
            } catch  {}
        }
        function i() {
            let u;
            try {
                u = e.storage.getItem("debug") || e.storage.getItem("DEBUG");
            } catch  {}
            return !u && typeof process < "u" && "env" in process && (u = process.env.DEBUG), u;
        }
        function o() {
            try {
                return localStorage;
            } catch  {}
        }
        r.exports = Fb()(e);
        const { formatters: a } = r.exports;
        a.j = function(u) {
            try {
                return JSON.stringify(u);
            } catch (c) {
                return "[UnexpectedJSONParseError]: " + c.message;
            }
        };
    }(Co, Co.exports)), Co.exports;
}
var Es = {}, Lo = {
    exports: {}
}, zh;
function qb() {
    return zh || (zh = 1, function(r, e) {
        (function(t) {
            function n(s) {
                var i = s && s.Promise || t.Promise, o = s && s.XMLHttpRequest || t.XMLHttpRequest;
                return function() {
                    var a = Object.create(t, {
                        fetch: {
                            value: void 0,
                            writable: !0
                        }
                    });
                    return function(u, c) {
                        c(e);
                    }(this, function(u) {
                        var c = typeof a < "u" && a || typeof self < "u" && self || typeof c < "u" && c, l = {
                            searchParams: "URLSearchParams" in c,
                            iterable: "Symbol" in c && "iterator" in Symbol,
                            blob: "FileReader" in c && "Blob" in c && function() {
                                try {
                                    return new Blob(), !0;
                                } catch  {
                                    return !1;
                                }
                            }(),
                            formData: "FormData" in c,
                            arrayBuffer: "ArrayBuffer" in c
                        };
                        function d(y) {
                            return y && DataView.prototype.isPrototypeOf(y);
                        }
                        if (l.arrayBuffer) var h = [
                            "[object Int8Array]",
                            "[object Uint8Array]",
                            "[object Uint8ClampedArray]",
                            "[object Int16Array]",
                            "[object Uint16Array]",
                            "[object Int32Array]",
                            "[object Uint32Array]",
                            "[object Float32Array]",
                            "[object Float64Array]"
                        ], f = ArrayBuffer.isView || function(y) {
                            return y && h.indexOf(Object.prototype.toString.call(y)) > -1;
                        };
                        function g(y) {
                            if (typeof y != "string" && (y = String(y)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(y) || y === "") throw new TypeError("Invalid character in header field name");
                            return y.toLowerCase();
                        }
                        function p(y) {
                            return typeof y != "string" && (y = String(y)), y;
                        }
                        function m(y) {
                            var w = {
                                next: function() {
                                    var M = y.shift();
                                    return {
                                        done: M === void 0,
                                        value: M
                                    };
                                }
                            };
                            return l.iterable && (w[Symbol.iterator] = function() {
                                return w;
                            }), w;
                        }
                        function x(y) {
                            this.map = {}, y instanceof x ? y.forEach(function(w, M) {
                                this.append(M, w);
                            }, this) : Array.isArray(y) ? y.forEach(function(w) {
                                this.append(w[0], w[1]);
                            }, this) : y && Object.getOwnPropertyNames(y).forEach(function(w) {
                                this.append(w, y[w]);
                            }, this);
                        }
                        x.prototype.append = function(y, w) {
                            y = g(y), w = p(w);
                            var M = this.map[y];
                            this.map[y] = M ? M + ", " + w : w;
                        }, x.prototype.delete = function(y) {
                            delete this.map[g(y)];
                        }, x.prototype.get = function(y) {
                            return y = g(y), this.has(y) ? this.map[y] : null;
                        }, x.prototype.has = function(y) {
                            return this.map.hasOwnProperty(g(y));
                        }, x.prototype.set = function(y, w) {
                            this.map[g(y)] = p(w);
                        }, x.prototype.forEach = function(y, w) {
                            for(var M in this.map)this.map.hasOwnProperty(M) && y.call(w, this.map[M], M, this);
                        }, x.prototype.keys = function() {
                            var y = [];
                            return this.forEach(function(w, M) {
                                y.push(M);
                            }), m(y);
                        }, x.prototype.values = function() {
                            var y = [];
                            return this.forEach(function(w) {
                                y.push(w);
                            }), m(y);
                        }, x.prototype.entries = function() {
                            var y = [];
                            return this.forEach(function(w, M) {
                                y.push([
                                    M,
                                    w
                                ]);
                            }), m(y);
                        }, l.iterable && (x.prototype[Symbol.iterator] = x.prototype.entries);
                        function _(y) {
                            if (y.bodyUsed) return i.reject(new TypeError("Already read"));
                            y.bodyUsed = !0;
                        }
                        function v(y) {
                            return new i(function(w, M) {
                                y.onload = function() {
                                    w(y.result);
                                }, y.onerror = function() {
                                    M(y.error);
                                };
                            });
                        }
                        function N(y) {
                            var w = new FileReader(), M = v(w);
                            return w.readAsArrayBuffer(y), M;
                        }
                        function O(y) {
                            var w = new FileReader(), M = v(w);
                            return w.readAsText(y), M;
                        }
                        function z(y) {
                            for(var w = new Uint8Array(y), M = new Array(w.length), D = 0; D < w.length; D++)M[D] = String.fromCharCode(w[D]);
                            return M.join("");
                        }
                        function P(y) {
                            if (y.slice) return y.slice(0);
                            var w = new Uint8Array(y.byteLength);
                            return w.set(new Uint8Array(y)), w.buffer;
                        }
                        function U() {
                            return this.bodyUsed = !1, this._initBody = function(y) {
                                this.bodyUsed = this.bodyUsed, this._bodyInit = y, y ? typeof y == "string" ? this._bodyText = y : l.blob && Blob.prototype.isPrototypeOf(y) ? this._bodyBlob = y : l.formData && FormData.prototype.isPrototypeOf(y) ? this._bodyFormData = y : l.searchParams && URLSearchParams.prototype.isPrototypeOf(y) ? this._bodyText = y.toString() : l.arrayBuffer && l.blob && d(y) ? (this._bodyArrayBuffer = P(y.buffer), this._bodyInit = new Blob([
                                    this._bodyArrayBuffer
                                ])) : l.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(y) || f(y)) ? this._bodyArrayBuffer = P(y) : this._bodyText = y = Object.prototype.toString.call(y) : this._bodyText = "", this.headers.get("content-type") || (typeof y == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : l.searchParams && URLSearchParams.prototype.isPrototypeOf(y) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
                            }, l.blob && (this.blob = function() {
                                var y = _(this);
                                if (y) return y;
                                if (this._bodyBlob) return i.resolve(this._bodyBlob);
                                if (this._bodyArrayBuffer) return i.resolve(new Blob([
                                    this._bodyArrayBuffer
                                ]));
                                if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                                return i.resolve(new Blob([
                                    this._bodyText
                                ]));
                            }, this.arrayBuffer = function() {
                                if (this._bodyArrayBuffer) {
                                    var y = _(this);
                                    return y || (ArrayBuffer.isView(this._bodyArrayBuffer) ? i.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : i.resolve(this._bodyArrayBuffer));
                                } else return this.blob().then(N);
                            }), this.text = function() {
                                var y = _(this);
                                if (y) return y;
                                if (this._bodyBlob) return O(this._bodyBlob);
                                if (this._bodyArrayBuffer) return i.resolve(z(this._bodyArrayBuffer));
                                if (this._bodyFormData) throw new Error("could not read FormData body as text");
                                return i.resolve(this._bodyText);
                            }, l.formData && (this.formData = function() {
                                return this.text().then(H);
                            }), this.json = function() {
                                return this.text().then(JSON.parse);
                            }, this;
                        }
                        var R = [
                            "DELETE",
                            "GET",
                            "HEAD",
                            "OPTIONS",
                            "POST",
                            "PUT"
                        ];
                        function G(y) {
                            var w = y.toUpperCase();
                            return R.indexOf(w) > -1 ? w : y;
                        }
                        function F(y, w) {
                            if (!(this instanceof F)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                            w = w || {};
                            var M = w.body;
                            if (y instanceof F) {
                                if (y.bodyUsed) throw new TypeError("Already read");
                                this.url = y.url, this.credentials = y.credentials, w.headers || (this.headers = new x(y.headers)), this.method = y.method, this.mode = y.mode, this.signal = y.signal, !M && y._bodyInit != null && (M = y._bodyInit, y.bodyUsed = !0);
                            } else this.url = String(y);
                            if (this.credentials = w.credentials || this.credentials || "same-origin", (w.headers || !this.headers) && (this.headers = new x(w.headers)), this.method = G(w.method || this.method || "GET"), this.mode = w.mode || this.mode || null, this.signal = w.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && M) throw new TypeError("Body not allowed for GET or HEAD requests");
                            if (this._initBody(M), (this.method === "GET" || this.method === "HEAD") && (w.cache === "no-store" || w.cache === "no-cache")) {
                                var D = /([?&])_=[^&]*/;
                                if (D.test(this.url)) this.url = this.url.replace(D, "$1_=" + /* @__PURE__ */ new Date().getTime());
                                else {
                                    var A = /\?/;
                                    this.url += (A.test(this.url) ? "&" : "?") + "_=" + /* @__PURE__ */ new Date().getTime();
                                }
                            }
                        }
                        F.prototype.clone = function() {
                            return new F(this, {
                                body: this._bodyInit
                            });
                        };
                        function H(y) {
                            var w = new FormData();
                            return y.trim().split("&").forEach(function(M) {
                                if (M) {
                                    var D = M.split("="), A = D.shift().replace(/\+/g, " "), L = D.join("=").replace(/\+/g, " ");
                                    w.append(decodeURIComponent(A), decodeURIComponent(L));
                                }
                            }), w;
                        }
                        function B(y) {
                            var w = new x(), M = y.replace(/\r?\n[\t ]+/g, " ");
                            return M.split("\r").map(function(D) {
                                return D.indexOf(`
`) === 0 ? D.substr(1, D.length) : D;
                            }).forEach(function(D) {
                                var A = D.split(":"), L = A.shift().trim();
                                if (L) {
                                    var V = A.join(":").trim();
                                    w.append(L, V);
                                }
                            }), w;
                        }
                        U.call(F.prototype);
                        function C(y, w) {
                            if (!(this instanceof C)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                            w || (w = {}), this.type = "default", this.status = w.status === void 0 ? 200 : w.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in w ? w.statusText : "", this.headers = new x(w.headers), this.url = w.url || "", this._initBody(y);
                        }
                        U.call(C.prototype), C.prototype.clone = function() {
                            return new C(this._bodyInit, {
                                status: this.status,
                                statusText: this.statusText,
                                headers: new x(this.headers),
                                url: this.url
                            });
                        }, C.error = function() {
                            var y = new C(null, {
                                status: 0,
                                statusText: ""
                            });
                            return y.type = "error", y;
                        };
                        var T = [
                            301,
                            302,
                            303,
                            307,
                            308
                        ];
                        C.redirect = function(y, w) {
                            if (T.indexOf(w) === -1) throw new RangeError("Invalid status code");
                            return new C(null, {
                                status: w,
                                headers: {
                                    location: y
                                }
                            });
                        }, u.DOMException = c.DOMException;
                        try {
                            new u.DOMException();
                        } catch  {
                            u.DOMException = function(w, M) {
                                this.message = w, this.name = M;
                                var D = Error(w);
                                this.stack = D.stack;
                            }, u.DOMException.prototype = Object.create(Error.prototype), u.DOMException.prototype.constructor = u.DOMException;
                        }
                        function I(y, w) {
                            return new i(function(M, D) {
                                var A = new F(y, w);
                                if (A.signal && A.signal.aborted) return D(new u.DOMException("Aborted", "AbortError"));
                                var L = new o();
                                function V() {
                                    L.abort();
                                }
                                L.onload = function() {
                                    var K = {
                                        status: L.status,
                                        statusText: L.statusText,
                                        headers: B(L.getAllResponseHeaders() || "")
                                    };
                                    K.url = "responseURL" in L ? L.responseURL : K.headers.get("X-Request-URL");
                                    var J = "response" in L ? L.response : L.responseText;
                                    setTimeout(function() {
                                        M(new C(J, K));
                                    }, 0);
                                }, L.onerror = function() {
                                    setTimeout(function() {
                                        D(new TypeError("Network request failed"));
                                    }, 0);
                                }, L.ontimeout = function() {
                                    setTimeout(function() {
                                        D(new TypeError("Network request failed"));
                                    }, 0);
                                }, L.onabort = function() {
                                    setTimeout(function() {
                                        D(new u.DOMException("Aborted", "AbortError"));
                                    }, 0);
                                };
                                function Y(K) {
                                    try {
                                        return K === "" && c.location.href ? c.location.href : K;
                                    } catch  {
                                        return K;
                                    }
                                }
                                L.open(A.method, Y(A.url), !0), A.credentials === "include" ? L.withCredentials = !0 : A.credentials === "omit" && (L.withCredentials = !1), "responseType" in L && (l.blob ? L.responseType = "blob" : l.arrayBuffer && A.headers.get("Content-Type") && A.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (L.responseType = "arraybuffer")), w && typeof w.headers == "object" && !(w.headers instanceof x) ? Object.getOwnPropertyNames(w.headers).forEach(function(K) {
                                    L.setRequestHeader(K, p(w.headers[K]));
                                }) : A.headers.forEach(function(K, J) {
                                    L.setRequestHeader(J, K);
                                }), A.signal && (A.signal.addEventListener("abort", V), L.onreadystatechange = function() {
                                    L.readyState === 4 && A.signal.removeEventListener("abort", V);
                                }), L.send(typeof A._bodyInit > "u" ? null : A._bodyInit);
                            });
                        }
                        I.polyfill = !0, c.fetch || (c.fetch = I, c.Headers = x, c.Request = F, c.Response = C), u.Headers = x, u.Request = F, u.Response = C, u.fetch = I, Object.defineProperty(u, "__esModule", {
                            value: !0
                        });
                    }), {
                        fetch: a.fetch,
                        Headers: a.Headers,
                        Request: a.Request,
                        Response: a.Response,
                        DOMException: a.DOMException
                    };
                }();
            }
            r.exports = n;
        })(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : $);
    }(Lo, Lo.exports)), Lo.exports;
}
var ut = {}, Ph;
function Qb() {
    return Ph || (Ph = 1, ut.endianness = function() {
        return "LE";
    }, ut.hostname = function() {
        return typeof location < "u" ? location.hostname : "";
    }, ut.loadavg = function() {
        return [];
    }, ut.uptime = function() {
        return 0;
    }, ut.freemem = function() {
        return Number.MAX_VALUE;
    }, ut.totalmem = function() {
        return Number.MAX_VALUE;
    }, ut.cpus = function() {
        return [];
    }, ut.type = function() {
        return "Browser";
    }, ut.release = function() {
        return typeof navigator < "u" ? navigator.appVersion : "";
    }, ut.networkInterfaces = ut.getNetworkInterfaces = function() {
        return {};
    }, ut.arch = function() {
        return "javascript";
    }, ut.platform = function() {
        return "browser";
    }, ut.tmpdir = ut.tmpDir = function() {
        return "/tmp";
    }, ut.EOL = `
`, ut.homedir = function() {
        return "/";
    }), ut;
}
var ti = {}, Uh;
function fs() {
    if (Uh) return ti;
    Uh = 1, Object.defineProperty(ti, "__esModule", {
        value: !0
    }), ti.DeferredPromise = ti.throwIfError = void 0;
    function r(t) {
        var n, s, i, o, a, u;
        if (t.message !== void 0) throw new Error(t.message);
        if (t.next === void 0 && ((s = (n = t) === null || n === void 0 ? void 0 : n.meta) === null || s === void 0 ? void 0 : s.uuid) === void 0 && ((o = (i = t) === null || i === void 0 ? void 0 : i.application) === null || o === void 0 ? void 0 : o.uuidv4) === void 0 && ((u = (a = t) === null || a === void 0 ? void 0 : a.error) === null || u === void 0 ? void 0 : u.code) !== void 0) {
            const d = t.error;
            throw new Error(`Error code ${d.code}, see XUMM Dev Console, reference: ${d.reference}`);
        }
    }
    ti.throwIfError = r;
    class e {
        constructor(){
            this.resolveFn = (n)=>{}, this.rejectFn = (n)=>{}, this.promise = new Promise((n, s)=>{
                this.resolveFn = n, this.rejectFn = s;
            });
        }
        resolve(n) {
            return this.resolveFn(n), this.promise;
        }
        reject(n) {
            return this.rejectFn(n), this.promise;
        }
    }
    return ti.DeferredPromise = e, ti;
}
var Rh;
function Vb() {
    if (Rh) return Es;
    Rh = 1;
    var r = $ && $.__awaiter || function(f, g, p, m) {
        function x(_) {
            return _ instanceof p ? _ : new p(function(v) {
                v(_);
            });
        }
        return new (p || (p = Promise))(function(_, v) {
            function N(P) {
                try {
                    z(m.next(P));
                } catch (U) {
                    v(U);
                }
            }
            function O(P) {
                try {
                    z(m.throw(P));
                } catch (U) {
                    v(U);
                }
            }
            function z(P) {
                P.done ? _(P.value) : x(P.value).then(N, O);
            }
            z((m = m.apply(f, g || [])).next());
        });
    }, e = $ && $.__importDefault || function(f) {
        return f && f.__esModule ? f : {
            default: f
        };
    };
    Object.defineProperty(Es, "__esModule", {
        value: !0
    }), Es.Meta = void 0;
    const t = _i(), n = e(qb()), { fetch: s, Request: i, Response: o, Headers: a } = n.default(), u = Qb(), c = fs(), l = Ia(), d = t.debug("xumm-sdk:meta");
    let h = class {
        constructor(g, p){
            this.isBrowser = !1, this.jwtFlow = !1, this.injected = !1, this.endpoint = "https://xumm.app", d("Constructed");
            const m = new RegExp("^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$"), x = {
                split: p.split(":"),
                uuidv4: ""
            };
            if (x.split.length === 3 && x.split.slice(0, 2).join(":") === "xApp:OneTimeToken" ? (x.uuidv4 = x.split[2], this.jwtFlow = !0) : x.split.length > 1 && x.split[0] === "RAWJWT" ? (this.jwtFlow = !0, this.jwt = x.split.slice(1).join(":")) : x.uuidv4 = p, !m.test(g) || !m.test(x.uuidv4)) if (this.jwtFlow) {
                if (!this.jwt) throw new Error("Invalid API Key and/or OTT (One Time Token). Provide OTT param (2nd param) or make sure `xAppToken` query param is present (Browser)");
            } else throw new Error("Invalid API Key and/or API Secret. Use dotenv or constructor params.");
            return typeof globalThis < "u" && Object.keys(globalThis).indexOf("window") < 0 ? d("Running in node") : (console.log("XUMM SDK: Running in browser"), this.isBrowser = !0), this.apiKey = g, this.apiSecret = x.uuidv4, this.jwtFlow && !this.jwt && (this.authPromise = new Promise((_)=>{
                this.authPromiseResolve = _;
            }), Promise.resolve().then(()=>this.authorize()).catch((_)=>{
                d("Authorize error:", _.message), !(this === null || this === void 0) && this.invoker && this.invoker.caught(_), this.authPromiseResolve && this.authPromiseResolve();
            })), this;
        }
        setEndpoint(g) {
            return g.match(/^http/) ? (this.endpoint = g.trim(), !0) : !1;
        }
        authorize() {
            var g, p, m, x;
            return r(this, void 0, void 0, function*() {
                d("JWT Authorize", this.apiSecret);
                let _;
                !(this === null || this === void 0) && this.invoker && this.invoker.constructor === l.XummSdkJwt && (_ = this.invoker._jwtStore(this, (N)=>this.jwt = N));
                const v = (_ == null ? void 0 : _.get(this.apiSecret)) || (yield this.call("authorize"));
                if (!((p = (g = v) === null || g === void 0 ? void 0 : g.error) === null || p === void 0) && p.code) d("Could not resolve API Key & OTT to JWT (already fetched? Unauthorized?)"), !(this === null || this === void 0) && this.invoker && this.invoker.constructor === l.XummSdkJwt && !((m = this === null || this === void 0 ? void 0 : this.invoker) === null || m === void 0) && m.fatalHandler ? this.invoker.fatalHandler(new Error(v.error.reference)) : c.throwIfError(v);
                else if (!((x = v) === null || x === void 0) && x.jwt) {
                    const N = v;
                    _ == null || _.set(this.apiSecret, N);
                } else throw new Error("Unexpected response for xApp JWT authorize request");
                this.authPromiseResolve && this.authPromiseResolve();
            });
        }
        call(g, p = "GET", m) {
            var x;
            return r(this, void 0, void 0, function*() {
                const _ = p.toUpperCase(), v = g.split("/")[0];
                this.jwtFlow && !(!(this === null || this === void 0) && this.jwt) && this.authPromise && g !== "authorize" && (yield this.authPromise);
                try {
                    let N;
                    typeof m < "u" && (typeof m == "object" && m !== null && (N = JSON.stringify(m)), typeof m == "string" && (N = m));
                    const O = {
                        "Content-Type": "application/json"
                    };
                    this.isBrowser || Object.assign(O, {
                        "User-Agent": `xumm-sdk/node (${u.hostname()}) node-fetch`
                    }), this.jwtFlow ? g === "authorize" ? Object.assign(O, {
                        "x-api-key": this.apiKey,
                        "x-api-ott": this.apiSecret
                    }) : Object.assign(O, {
                        Authorization: "Bearer " + this.jwt
                    }) : Object.assign(O, {
                        "x-api-key": this.apiKey,
                        "x-api-secret": this.apiSecret
                    });
                    const z = [
                        "authorize",
                        "ping",
                        "curated-assets",
                        "rates",
                        "payload",
                        "userdata",
                        "xrpl-tx",
                        "nftoken-detail",
                        "rails",
                        "hookhash"
                    ], P = this.jwtFlow && z.indexOf(v) > -1 ? "jwt" : "platform";
                    return yield (yield s(this.endpoint + "/api/v1/" + P + "/" + g, {
                        method: _,
                        body: N,
                        headers: O
                    })).json();
                } catch (N) {
                    const O = new Error(`Unexpected response from XUMM API [${_}:${v}]`);
                    throw O.stack = ((x = N) === null || x === void 0 ? void 0 : x.stack) || void 0, O;
                }
            });
        }
        ping() {
            var g, p;
            return r(this, void 0, void 0, function*() {
                const m = yield this.call("ping");
                if (c.throwIfError(m), typeof m.auth < "u") return m.auth;
                if (typeof ((g = m) === null || g === void 0 ? void 0 : g.ott_uuidv4) < "u") return {
                    application: {
                        uuidv4: m.app_uuidv4,
                        name: m.app_name
                    },
                    jwtData: m
                };
                if (typeof ((p = m) === null || p === void 0 ? void 0 : p.usertoken_uuidv4) < "u") return {
                    application: {
                        uuidv4: m.client_id,
                        name: m.app_name
                    },
                    jwtData: m
                };
                throw new Error("Unexpected response for ping request");
            });
        }
        getCuratedAssets() {
            return r(this, void 0, void 0, function*() {
                return yield this.call("curated-assets");
            });
        }
        getRates(g) {
            return r(this, void 0, void 0, function*() {
                return yield this.call("rates/" + g.trim().toUpperCase());
            });
        }
        getKycStatus(g) {
            return r(this, void 0, void 0, function*() {
                if (g.trim().match(/^r/)) {
                    const p = yield this.call("kyc-status/" + g.trim());
                    return p != null && p.kycApproved ? "SUCCESSFUL" : "NONE";
                } else {
                    const p = yield this.call("kyc-status", "POST", {
                        user_token: g
                    });
                    return (p == null ? void 0 : p.kycStatus) || "NONE";
                }
            });
        }
        getRails() {
            return r(this, void 0, void 0, function*() {
                return yield this.call("rails");
            });
        }
        getHookHash(g) {
            return r(this, void 0, void 0, function*() {
                if (typeof g == "string" && g.trim().match(/^[A-Fa-f0-9]{64}$/)) return yield this.call("hookhash/" + g.trim());
                throw Error("Invalid Hook Hash (expecting 64 char hex)");
            });
        }
        getHookHashes() {
            return r(this, void 0, void 0, function*() {
                return yield this.call("hookhash");
            });
        }
        getTransaction(g) {
            return r(this, void 0, void 0, function*() {
                return yield this.call("xrpl-tx/" + g.trim());
            });
        }
        getNftokenDetail(g) {
            return r(this, void 0, void 0, function*() {
                if (!this.jwtFlow) throw new Error("getNftokenDetail: only available in JWT (XummSdkJwt) mode");
                return yield this.call("nftoken-detail/" + g.trim());
            });
        }
        verifyUserTokens(g) {
            return r(this, void 0, void 0, function*() {
                return (yield this.call("user-tokens", "POST", {
                    tokens: Array.isArray(g) ? g : [
                        g
                    ]
                })).tokens;
            });
        }
        // Internal
        _inject(g) {
            if (!this.injected) this.invoker = g;
            else throw new Error("Cannot `_inject` twice");
        }
    };
    return Es.Meta = h, Es;
}
var Ms = {}, $h;
function Yb() {
    if ($h) return Ms;
    $h = 1;
    var r = $ && $.__awaiter || function(i, o, a, u) {
        function c(l) {
            return l instanceof a ? l : new a(function(d) {
                d(l);
            });
        }
        return new (a || (a = Promise))(function(l, d) {
            function h(p) {
                try {
                    g(u.next(p));
                } catch (m) {
                    d(m);
                }
            }
            function f(p) {
                try {
                    g(u.throw(p));
                } catch (m) {
                    d(m);
                }
            }
            function g(p) {
                p.done ? l(p.value) : c(p.value).then(h, f);
            }
            g((u = u.apply(i, o || [])).next());
        });
    };
    Object.defineProperty(Ms, "__esModule", {
        value: !0
    }), Ms.Storage = void 0;
    const e = _i(), t = fs(), n = e.debug("xumm-sdk:storage");
    let s = class {
        constructor(o){
            n("Constructed"), this.Meta = o;
        }
        get() {
            return r(this, void 0, void 0, function*() {
                const o = yield this.Meta.call("app-storage", "GET");
                return t.throwIfError(o), o.data;
            });
        }
        set(o) {
            return r(this, void 0, void 0, function*() {
                const a = yield this.Meta.call("app-storage", "POST", o);
                return t.throwIfError(a), a.stored;
            });
        }
        delete() {
            return r(this, void 0, void 0, function*() {
                const o = yield this.Meta.call("app-storage", "DELETE");
                return t.throwIfError(o), o.stored;
            });
        }
    };
    return Ms.Storage = s, Ms;
}
var Ns = {}, su, Bh;
function Gb() {
    if (Bh) return su;
    Bh = 1;
    var r = function() {
        if (typeof self == "object" && self) return self;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        throw new Error("Unable to resolve global `this`");
    };
    return su = function() {
        if (this) return this;
        if (typeof globalThis == "object" && globalThis) return globalThis;
        try {
            Object.defineProperty(Object.prototype, "__global__", {
                get: function() {
                    return this;
                },
                configurable: !0
            });
        } catch  {
            return r();
        }
        try {
            return __global__ || r();
        } finally{
            delete Object.prototype.__global__;
        }
    }(), su;
}
const Hb = "1.0.35", Wb = {
    version: Hb
};
var ou, Fh;
function Kb() {
    return Fh || (Fh = 1, ou = Wb.version), ou;
}
var au, qh;
function Xb() {
    if (qh) return au;
    qh = 1;
    var r;
    if (typeof globalThis == "object") r = globalThis;
    else try {
        r = Gb();
    } catch  {} finally{
        if (!r && ("TURBOPACK compile-time value", "undefined") < "u" && (r = window), !r) throw new Error("Could not determine global this");
    }
    var e = r.WebSocket || r.MozWebSocket, t = Kb();
    function n(s, i) {
        var o;
        return i ? o = new e(s, i) : o = new e(s), o;
    }
    return e && [
        "CONNECTING",
        "OPEN",
        "CLOSING",
        "CLOSED"
    ].forEach(function(s) {
        Object.defineProperty(n, s, {
            get: function() {
                return e[s];
            }
        });
    }), au = {
        w3cwebsocket: e ? n : null,
        version: t
    }, au;
}
var Qh;
function Zb() {
    if (Qh) return Ns;
    Qh = 1;
    var r = $ && $.__awaiter || function(d, h, f, g) {
        function p(m) {
            return m instanceof f ? m : new f(function(x) {
                x(m);
            });
        }
        return new (f || (f = Promise))(function(m, x) {
            function _(O) {
                try {
                    N(g.next(O));
                } catch (z) {
                    x(z);
                }
            }
            function v(O) {
                try {
                    N(g.throw(O));
                } catch (z) {
                    x(z);
                }
            }
            function N(O) {
                O.done ? m(O.value) : p(O.value).then(_, v);
            }
            N((g = g.apply(d, h || [])).next());
        });
    };
    Object.defineProperty(Ns, "__esModule", {
        value: !0
    }), Ns.Payload = void 0;
    const e = _i(), t = Xb(), n = fs(), s = e.debug("xumm-sdk:payload"), i = e.debug("xumm-sdk:payload:websocket"), o = typeof jest < "u" ? 0 : 30, a = 2, u = 2, c = 10;
    let l = class {
        constructor(h){
            s("Constructed"), this.Meta = h;
        }
        resolvePayload(h) {
            var f, g, p;
            return r(this, void 0, void 0, function*() {
                if (typeof h == "string") return yield this.get(h, !0);
                if (typeof ((f = h) === null || f === void 0 ? void 0 : f.uuid) < "u") return yield this.get(h.uuid, !0);
                if (typeof ((p = (g = h) === null || g === void 0 ? void 0 : g.meta) === null || p === void 0 ? void 0 : p.uuid) < "u") return h;
                throw new Error("Could not resolve payload (not found)");
            });
        }
        create(h, f = !1) {
            var g;
            return r(this, void 0, void 0, function*() {
                const p = typeof h.TransactionType < "u" && typeof h.txjson > "u", m = yield this.Meta.call("payload", "POST", p ? {
                    txjson: h
                } : h);
                return f && n.throwIfError(m), ((g = m) === null || g === void 0 ? void 0 : g.next) !== void 0 ? m : null;
            });
        }
        get(h, f = !1) {
            var g, p;
            return r(this, void 0, void 0, function*() {
                const m = typeof h == "string" ? h : h == null ? void 0 : h.uuid, x = yield this.Meta.call("payload/" + m, "GET");
                return f && n.throwIfError(x), ((p = (g = x) === null || g === void 0 ? void 0 : g.meta) === null || p === void 0 ? void 0 : p.uuid) !== void 0 ? x : null;
            });
        }
        subscribe(h, f) {
            return r(this, void 0, void 0, function*() {
                const g = new n.DeferredPromise(), p = yield this.resolvePayload(h);
                if (p) {
                    const m = "undefined";
                    let x, _, v, N = 0;
                    g.promise.then(()=>{
                        clearTimeout(_), clearTimeout(v), x.close(1e3);
                    });
                    const O = ()=>{
                        var z, P;
                        return x = typeof ((z = globalThis) === null || z === void 0 ? void 0 : z.MockedWebSocket) !== m && typeof jest !== m ? new ((P = globalThis) === null || P === void 0 ? void 0 : P.MockedWebSocket)("ws://xumm.local") : new t.w3cwebsocket(this.Meta.endpoint.replace(/^http/, "ws") + "/sign/" + p.meta.uuid), x.onopen = ()=>{
                            console.log(`Payload ${p.meta.uuid}: subscription active (WebSocket opened)`), _ = setInterval(()=>{
                                i("Send keepalive"), x.send('{"ping":true}');
                            }, u * 1e3);
                        }, x.onmessage = (U)=>r(this, void 0, void 0, function*() {
                                N = 0;
                                const R = U.data;
                                let G;
                                try {
                                    if (G = JSON.parse(R.toString()), G != null && G.message && G.message === "Right back at you!") {
                                        i("Keepalive response"), clearTimeout(v), v = setTimeout(()=>{
                                            console.log(`WebSocket for ${p.meta.uuid} keepalive response timeout, assume dead... (Reconnect)`), x.close(1002, "Assume dead");
                                        }, c * 1e3);
                                        return;
                                    }
                                    if (G != null && G.signed || G != null && G.expired) {
                                        const F = yield this.resolvePayload(h);
                                        Object.assign(p, Object.assign({}, F));
                                    }
                                } catch (F) {
                                    i(`Payload ${p.meta.uuid}: Received message, unable to parse as JSON`, F);
                                }
                                if (G && f && typeof G.devapp_fetched > "u") try {
                                    const F = yield f({
                                        uuid: p.meta.uuid,
                                        data: G,
                                        resolve (H) {
                                            return r(this, void 0, void 0, function*() {
                                                yield g.resolve(H || void 0);
                                            });
                                        },
                                        payload: p
                                    });
                                    F !== void 0 && g.resolve(F);
                                } catch (F) {
                                    i(`Payload ${p.meta.uuid}: Callback exception`, F), console.log(`Payload ${p.meta.uuid}: Callback exception: ${F.message}`);
                                }
                            }), x.onclose = (U)=>{
                            i("Closed [code]", U.code), i("Closed [reason]", U.reason), i("Closed [wasClean]", U.wasClean), clearInterval(_), clearTimeout(v), (U.code > 1e3 || U.wasClean === !1) && (console.log(U), i("Unhealthy disconnect, reconnecting...", U.code), N < o ? (N === 0 && console.log(`WebSocket for ${p.meta.uuid} lost, reconnecting...`), setTimeout(()=>{
                                N++, i("# Reconnect"), typeof jest > "u" && (x = O());
                            }, a * 1e3)) : typeof jest > "u" && console.log(`WebSocket for ${p.meta.uuid} exceeded reconnect timeouts, give up`)), i(`Payload ${p.meta.uuid}: Subscription ended (WebSocket closed)`);
                        }, x;
                    };
                    return x = O(), {
                        payload: p,
                        resolve (z) {
                            g.resolve(z || void 0);
                        },
                        resolved: g.promise,
                        websocket: x
                    };
                }
                throw n.throwIfError(p), Error("Couldn't subscribe: couldn't fetch payload");
            });
        }
        cancel(h, f = !1) {
            var g, p, m;
            return r(this, void 0, void 0, function*() {
                const x = yield this.resolvePayload(h), _ = yield this.Meta.call("payload/" + ((g = x == null ? void 0 : x.meta) === null || g === void 0 ? void 0 : g.uuid), "DELETE");
                return f && n.throwIfError(_), ((m = (p = _) === null || p === void 0 ? void 0 : p.meta) === null || m === void 0 ? void 0 : m.uuid) !== void 0 ? _ : null;
            });
        }
        createAndSubscribe(h, f) {
            return r(this, void 0, void 0, function*() {
                const g = yield this.create(h, !0);
                if (g) {
                    const p = yield this.subscribe(g, f);
                    return Object.assign({
                        created: g
                    }, p);
                }
                throw new Error("Error creating payload or subscribing to created payload");
            });
        }
    };
    return Ns.Payload = l, Ns;
}
var xs = {}, Is = {}, Vh;
function Nd() {
    if (Vh) return Is;
    Vh = 1;
    var r = $ && $.__awaiter || function(o, a, u, c) {
        function l(d) {
            return d instanceof u ? d : new u(function(h) {
                h(d);
            });
        }
        return new (u || (u = Promise))(function(d, h) {
            function f(m) {
                try {
                    p(c.next(m));
                } catch (x) {
                    h(x);
                }
            }
            function g(m) {
                try {
                    p(c.throw(m));
                } catch (x) {
                    h(x);
                }
            }
            function p(m) {
                m.done ? d(m.value) : l(m.value).then(f, g);
            }
            p((c = c.apply(o, a || [])).next());
        });
    };
    Object.defineProperty(Is, "__esModule", {
        value: !0
    }), Is.JwtUserdata = void 0;
    const e = _i(), t = fs(), n = e.debug("xumm-sdk:xapp:userdata"), s = (o)=>{
        if (!(typeof o == "string" && o.match(/^[a-z0-9]{3,}$/))) throw new Error("Invalid key, only a-z0-9 (min three chars) allowed: " + o);
    };
    let i = class {
        constructor(a){
            n("Constructed"), this.Meta = a;
        }
        list() {
            return r(this, void 0, void 0, function*() {
                const a = yield this.Meta.call("userdata", "GET");
                return t.throwIfError(a), a.keys;
            });
        }
        get(a) {
            var u;
            return r(this, void 0, void 0, function*() {
                const c = Array.isArray(a) ? a.join(",") : a;
                c.split(",").forEach((d)=>s(d));
                const l = yield this.Meta.call("userdata/" + c, "GET");
                return t.throwIfError(l), c.split(",").length > 1 ? l.data : ((u = l.data) === null || u === void 0 ? void 0 : u[c]) || {};
            });
        }
        delete(a) {
            return r(this, void 0, void 0, function*() {
                s(a);
                const u = yield this.Meta.call("userdata/" + a, "DELETE");
                return t.throwIfError(u), u.persisted;
            });
        }
        set(a, u) {
            return r(this, void 0, void 0, function*() {
                s(a);
                const c = yield this.Meta.call("userdata/" + a, "POST", u);
                return t.throwIfError(c), c.persisted;
            });
        }
    };
    return Is.JwtUserdata = i, Is;
}
var Yh;
function Jb() {
    if (Yh) return xs;
    Yh = 1;
    var r = $ && $.__awaiter || function(o, a, u, c) {
        function l(d) {
            return d instanceof u ? d : new u(function(h) {
                h(d);
            });
        }
        return new (u || (u = Promise))(function(d, h) {
            function f(m) {
                try {
                    p(c.next(m));
                } catch (x) {
                    h(x);
                }
            }
            function g(m) {
                try {
                    p(c.throw(m));
                } catch (x) {
                    h(x);
                }
            }
            function p(m) {
                m.done ? d(m.value) : l(m.value).then(f, g);
            }
            p((c = c.apply(o, a || [])).next());
        });
    };
    Object.defineProperty(xs, "__esModule", {
        value: !0
    }), xs.xApp = void 0;
    const e = _i(), t = Nd(), n = fs(), s = e.debug("xumm-sdk:xapp");
    let i = class {
        constructor(a){
            s("Constructed"), this.Meta = a, this.userdata = new t.JwtUserdata(a);
        }
        get(a) {
            return r(this, void 0, void 0, function*() {
                const u = yield this.Meta.call("xapp/ott/" + a, "GET");
                return n.throwIfError(u), u;
            });
        }
    };
    return xs.xApp = i, xs;
}
var Ts = {}, Gh;
function ev() {
    if (Gh) return Ts;
    Gh = 1;
    var r = $ && $.__awaiter || function(o, a, u, c) {
        function l(d) {
            return d instanceof u ? d : new u(function(h) {
                h(d);
            });
        }
        return new (u || (u = Promise))(function(d, h) {
            function f(m) {
                try {
                    p(c.next(m));
                } catch (x) {
                    h(x);
                }
            }
            function g(m) {
                try {
                    p(c.throw(m));
                } catch (x) {
                    h(x);
                }
            }
            function p(m) {
                m.done ? d(m.value) : l(m.value).then(f, g);
            }
            p((c = c.apply(o, a || [])).next());
        });
    };
    Object.defineProperty(Ts, "__esModule", {
        value: !0
    }), Ts.Push = void 0;
    const e = _i(), t = Nd(), n = fs(), s = e.debug("xumm-sdk:xapp");
    let i = class {
        constructor(a){
            s("Constructed"), this.Meta = a, this.userdata = new t.JwtUserdata(a);
        }
        event(a) {
            return r(this, void 0, void 0, function*() {
                const u = yield this.Meta.call("xapp/event", "POST", a);
                return n.throwIfError(u), u;
            });
        }
        notification(a) {
            return r(this, void 0, void 0, function*() {
                const u = yield this.Meta.call("xapp/push", "POST", a);
                return n.throwIfError(u), u;
            });
        }
    };
    return Ts.Push = i, Ts;
}
var Hh;
function Ia() {
    if (Hh) return ei;
    Hh = 1;
    var r = $ && $.__awaiter || function(h, f, g, p) {
        function m(x) {
            return x instanceof g ? x : new g(function(_) {
                _(x);
            });
        }
        return new (g || (g = Promise))(function(x, _) {
            function v(z) {
                try {
                    O(p.next(z));
                } catch (P) {
                    _(P);
                }
            }
            function N(z) {
                try {
                    O(p.throw(z));
                } catch (P) {
                    _(P);
                }
            }
            function O(z) {
                z.done ? x(z.value) : m(z.value).then(v, N);
            }
            O((p = p.apply(h, f || [])).next());
        });
    };
    Object.defineProperty(ei, "__esModule", {
        value: !0
    }), ei.XummSdkJwt = ei.XummSdk = void 0;
    const e = _i(), t = Vb(), n = Yb(), s = Zb(), i = Jb(), o = ev(), a = Nd(), u = ye, c = e.debug("xumm-sdk");
    class l {
        constructor(f, g){
            return c("Constructed"), this.Meta = new t.Meta(f || this.getEnv("XUMM_APIKEY"), g || this.getEnv("XUMM_APISECRET")), this.storage = new n.Storage(this.Meta), this.payload = new s.Payload(this.Meta), this.jwtUserdata = new a.JwtUserdata(this.Meta), this.Push = new o.Push(this.Meta), this.xApp = new i.xApp(this.Meta), this.Meta._inject(this), this;
        }
        getEnv(f) {
            let g = "";
            try {
                g = (process == null ? void 0 : process.env[f]) || "";
            } catch  {}
            return g;
        }
        /**
     * Proxy methods to Meta class below
     */ ping() {
            return this.Meta.ping();
        }
        getCuratedAssets() {
            return this.Meta.getCuratedAssets();
        }
        getRails() {
            return this.Meta.getRails();
        }
        getHookHashes() {
            return this.Meta.getHookHashes();
        }
        getHookHash(f) {
            return this.Meta.getHookHash(f);
        }
        getRates(f) {
            return this.Meta.getRates(f);
        }
        getKycStatus(f) {
            return this.Meta.getKycStatus(f);
        }
        getTransaction(f) {
            return this.Meta.getTransaction(f);
        }
        getNftokenDetail(f) {
            return this.Meta.getNftokenDetail(f);
        }
        verifyUserTokens(f) {
            return this.Meta.verifyUserTokens(f);
        }
        verifyUserToken(f) {
            return r(this, void 0, void 0, function*() {
                const g = yield this.Meta.verifyUserTokens([
                    f
                ]);
                return Array.isArray(g) && g.length === 1 ? g[0] : null;
            });
        }
        setEndpoint(f) {
            return this.Meta.setEndpoint(f);
        }
        caught(f) {
            throw f;
        }
    }
    ei.XummSdk = l;
    class d extends l {
        constructor(f, g, p){
            var m, x, _, v, N, O, z, P;
            let U = String(g || "").trim().toLowerCase();
            const R = f.length !== 36;
            if (!R && typeof g > "u" && ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.URLSearchParams < "u") {
                const G = new window.URLSearchParams(((m = window == null ? void 0 : window.location) === null || m === void 0 ? void 0 : m.search) || "");
                for (const F of G.entries())F[0] === "xAppToken" && (U = F[1].toLowerCase().trim());
                if (U === "" && !(p != null && p.store) && !(p != null && p.noAutoRetrieve) && typeof ((x = window == null ? void 0 : window.localStorage) === null || x === void 0 ? void 0 : x.XummSdkJwt) == "string") try {
                    const F = (v = (_ = window == null ? void 0 : window.localStorage) === null || _ === void 0 ? void 0 : _.XummSdkJwt) === null || v === void 0 ? void 0 : v.split(":"), H = JSON.parse((N = F == null ? void 0 : F.slice(1)) === null || N === void 0 ? void 0 : N.join(":"));
                    if (H != null && H.jwt) {
                        const B = u.Buffer.from((O = H.jwt.split(".")) === null || O === void 0 ? void 0 : O[1], "base64").toString("utf8"), C = JSON.parse(B);
                        if (C != null && C.exp) {
                            const T = (C == null ? void 0 : C.exp) - Math.floor(/* @__PURE__ */ new Date().getTime() / 1e3);
                            console.log("Restoring OTT " + (F == null ? void 0 : F[0])), T > 60 * 60 ? U = F == null ? void 0 : F[0] : console.log("Skip restore: not valid for one more hour");
                        }
                    }
                } catch (F) {
                    console.log("JWT Restore Error", F);
                }
            }
            super(f, !R && U !== "" ? "xApp:OneTimeToken:" + U : "RAWJWT:" + f), this.resolve = (G)=>{
                c("OTT data resolved", G);
            }, this.reject = (G)=>{
                c("OTT data rejected", G.message);
            }, this.ottResolved = R ? Promise.resolve() : new Promise((G, F)=>{
                this.resolve = G, this.reject = F;
            }), p != null && p.fatalHandler && (this.fatalHandler = p.fatalHandler), this.store = {
                get (G) {
                    var F;
                    if (c("[JwtStore]  Builtin JWT store GET"), ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.localStorage < "u" && typeof window.localStorage.XummSdkJwt == "string") {
                        const H = window.localStorage.XummSdkJwt.split(":");
                        if (H[0] === G) {
                            c("Restoring OTT from localStorage:", G);
                            try {
                                return JSON.parse(H.slice(1).join(":"));
                            } catch (B) {
                                c("Error restoring OTT Data (JWT) from localStorage", (F = B) === null || F === void 0 ? void 0 : F.message);
                            }
                        }
                    }
                },
                set (G, F) {
                    c("[JwtStore]  Builtin JWT store SET", G), ("TURBOPACK compile-time value", "undefined") < "u" && typeof localStorage < "u" && (window.localStorage.XummSdkJwt = G + ":" + JSON.stringify(F));
                }
            }, !((z = p == null ? void 0 : p.store) === null || z === void 0) && z.get && (this.store.get = p.store.get), !((P = p == null ? void 0 : p.store) === null || P === void 0) && P.set && (this.store.set = p.store.set), R ? (this.reject(new Error("Not in OTT flow: in raw JWT (OAuth2-like) flow")), c("Using JWT (Raw, OAuth2) flow")) : c("Using JWT (xApp) flow");
        }
        _jwtStore(f, g) {
            if (f && (f == null ? void 0 : f.constructor) === t.Meta) return {
                get: (p)=>{
                    var m;
                    return c("[JwtStore] Proxy GET"), (m = this.store) === null || m === void 0 ? void 0 : m.get(p);
                },
                set: (p, m)=>{
                    var x;
                    return c("[JwtStore] Proxy SET"), this.resolve(m.ott), g(m.jwt), this.jwt = m.jwt, (x = this.store) === null || x === void 0 ? void 0 : x.set(p, m);
                }
            };
            throw new Error("Invalid _jwtStore invoker");
        }
        getOttData() {
            return r(this, void 0, void 0, function*() {
                const f = yield this.ottResolved;
                if (f) return f;
                throw new Error("Called getOttData on a non OTT-JWT flow");
            });
        }
        getJwt() {
            return r(this, void 0, void 0, function*() {
                return yield this.ottResolved, this.jwt;
            });
        }
        caught(f) {
            this.reject(f);
        }
    }
    return ei.XummSdkJwt = d, ei;
}
var xd = {}, X0 = {
    exports: {}
};
function tv(r) {
    throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var cu = {
    exports: {}
};
const rv = {}, nv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: rv
}, Symbol.toStringTag, {
    value: "Module"
})), iv = /* @__PURE__ */ P0(nv);
var Wh;
function Id() {
    return Wh || (Wh = 1, function(r, e) {
        (function(t, n) {
            r.exports = n();
        })($, function() {
            var t = t || function(n, s) {
                var i;
                if (("TURBOPACK compile-time value", "undefined") < "u" && window.crypto && (i = window.crypto), typeof self < "u" && self.crypto && (i = self.crypto), typeof globalThis < "u" && globalThis.crypto && (i = globalThis.crypto), !i && ("TURBOPACK compile-time value", "undefined") < "u" && window.msCrypto && (i = window.msCrypto), !i && typeof $ < "u" && $.crypto && (i = $.crypto), !i && typeof tv == "function") try {
                    i = iv;
                } catch  {}
                var o = function() {
                    if (i) {
                        if (typeof i.getRandomValues == "function") try {
                            return i.getRandomValues(new Uint32Array(1))[0];
                        } catch  {}
                        if (typeof i.randomBytes == "function") try {
                            return i.randomBytes(4).readInt32LE();
                        } catch  {}
                    }
                    throw new Error("Native crypto module could not be used to get secure random number.");
                }, a = Object.create || /* @__PURE__ */ function() {
                    function _() {}
                    return function(v) {
                        var N;
                        return _.prototype = v, N = new _(), _.prototype = null, N;
                    };
                }(), u = {}, c = u.lib = {}, l = c.Base = /* @__PURE__ */ function() {
                    return {
                        /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */ extend: function(_) {
                            var v = a(this);
                            return _ && v.mixIn(_), (!v.hasOwnProperty("init") || this.init === v.init) && (v.init = function() {
                                v.$super.init.apply(this, arguments);
                            }), v.init.prototype = v, v.$super = this, v;
                        },
                        /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */ create: function() {
                            var _ = this.extend();
                            return _.init.apply(_, arguments), _;
                        },
                        /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */ init: function() {},
                        /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */ mixIn: function(_) {
                            for(var v in _)_.hasOwnProperty(v) && (this[v] = _[v]);
                            _.hasOwnProperty("toString") && (this.toString = _.toString);
                        },
                        /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */ clone: function() {
                            return this.init.prototype.extend(this);
                        }
                    };
                }(), d = c.WordArray = l.extend({
                    /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */ init: function(_, v) {
                        _ = this.words = _ || [], v != s ? this.sigBytes = v : this.sigBytes = _.length * 4;
                    },
                    /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */ toString: function(_) {
                        return (_ || f).stringify(this);
                    },
                    /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */ concat: function(_) {
                        var v = this.words, N = _.words, O = this.sigBytes, z = _.sigBytes;
                        if (this.clamp(), O % 4) for(var P = 0; P < z; P++){
                            var U = N[P >>> 2] >>> 24 - P % 4 * 8 & 255;
                            v[O + P >>> 2] |= U << 24 - (O + P) % 4 * 8;
                        }
                        else for(var R = 0; R < z; R += 4)v[O + R >>> 2] = N[R >>> 2];
                        return this.sigBytes += z, this;
                    },
                    /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */ clamp: function() {
                        var _ = this.words, v = this.sigBytes;
                        _[v >>> 2] &= 4294967295 << 32 - v % 4 * 8, _.length = n.ceil(v / 4);
                    },
                    /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */ clone: function() {
                        var _ = l.clone.call(this);
                        return _.words = this.words.slice(0), _;
                    },
                    /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */ random: function(_) {
                        for(var v = [], N = 0; N < _; N += 4)v.push(o());
                        return new d.init(v, _);
                    }
                }), h = u.enc = {}, f = h.Hex = {
                    /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */ stringify: function(_) {
                        for(var v = _.words, N = _.sigBytes, O = [], z = 0; z < N; z++){
                            var P = v[z >>> 2] >>> 24 - z % 4 * 8 & 255;
                            O.push((P >>> 4).toString(16)), O.push((P & 15).toString(16));
                        }
                        return O.join("");
                    },
                    /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */ parse: function(_) {
                        for(var v = _.length, N = [], O = 0; O < v; O += 2)N[O >>> 3] |= parseInt(_.substr(O, 2), 16) << 24 - O % 8 * 4;
                        return new d.init(N, v / 2);
                    }
                }, g = h.Latin1 = {
                    /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */ stringify: function(_) {
                        for(var v = _.words, N = _.sigBytes, O = [], z = 0; z < N; z++){
                            var P = v[z >>> 2] >>> 24 - z % 4 * 8 & 255;
                            O.push(String.fromCharCode(P));
                        }
                        return O.join("");
                    },
                    /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */ parse: function(_) {
                        for(var v = _.length, N = [], O = 0; O < v; O++)N[O >>> 2] |= (_.charCodeAt(O) & 255) << 24 - O % 4 * 8;
                        return new d.init(N, v);
                    }
                }, p = h.Utf8 = {
                    /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */ stringify: function(_) {
                        try {
                            return decodeURIComponent(escape(g.stringify(_)));
                        } catch  {
                            throw new Error("Malformed UTF-8 data");
                        }
                    },
                    /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */ parse: function(_) {
                        return g.parse(unescape(encodeURIComponent(_)));
                    }
                }, m = c.BufferedBlockAlgorithm = l.extend({
                    /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */ reset: function() {
                        this._data = new d.init(), this._nDataBytes = 0;
                    },
                    /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */ _append: function(_) {
                        typeof _ == "string" && (_ = p.parse(_)), this._data.concat(_), this._nDataBytes += _.sigBytes;
                    },
                    /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */ _process: function(_) {
                        var v, N = this._data, O = N.words, z = N.sigBytes, P = this.blockSize, U = P * 4, R = z / U;
                        _ ? R = n.ceil(R) : R = n.max((R | 0) - this._minBufferSize, 0);
                        var G = R * P, F = n.min(G * 4, z);
                        if (G) {
                            for(var H = 0; H < G; H += P)this._doProcessBlock(O, H);
                            v = O.splice(0, G), N.sigBytes -= F;
                        }
                        return new d.init(v, F);
                    },
                    /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */ clone: function() {
                        var _ = l.clone.call(this);
                        return _._data = this._data.clone(), _;
                    },
                    _minBufferSize: 0
                });
                c.Hasher = m.extend({
                    /**
           * Configuration options.
           */ cfg: l.extend(),
                    /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */ init: function(_) {
                        this.cfg = this.cfg.extend(_), this.reset();
                    },
                    /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */ reset: function() {
                        m.reset.call(this), this._doReset();
                    },
                    /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */ update: function(_) {
                        return this._append(_), this._process(), this;
                    },
                    /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */ finalize: function(_) {
                        _ && this._append(_);
                        var v = this._doFinalize();
                        return v;
                    },
                    blockSize: 16,
                    /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */ _createHelper: function(_) {
                        return function(v, N) {
                            return new _.init(N).finalize(v);
                        };
                    },
                    /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */ _createHmacHelper: function(_) {
                        return function(v, N) {
                            return new x.HMAC.init(_, N).finalize(v);
                        };
                    }
                });
                var x = u.algo = {};
                return u;
            }(Math);
            return t;
        });
    }(cu)), cu.exports;
}
(function(r, e) {
    (function(t, n) {
        r.exports = n(Id());
    })($, function(t) {
        return function(n) {
            var s = t, i = s.lib, o = i.WordArray, a = i.Hasher, u = s.algo, c = [], l = [];
            (function() {
                function f(x) {
                    for(var _ = n.sqrt(x), v = 2; v <= _; v++)if (!(x % v)) return !1;
                    return !0;
                }
                function g(x) {
                    return (x - (x | 0)) * 4294967296 | 0;
                }
                for(var p = 2, m = 0; m < 64;)f(p) && (m < 8 && (c[m] = g(n.pow(p, 1 / 2))), l[m] = g(n.pow(p, 1 / 3)), m++), p++;
            })();
            var d = [], h = u.SHA256 = a.extend({
                _doReset: function() {
                    this._hash = new o.init(c.slice(0));
                },
                _doProcessBlock: function(f, g) {
                    for(var p = this._hash.words, m = p[0], x = p[1], _ = p[2], v = p[3], N = p[4], O = p[5], z = p[6], P = p[7], U = 0; U < 64; U++){
                        if (U < 16) d[U] = f[g + U] | 0;
                        else {
                            var R = d[U - 15], G = (R << 25 | R >>> 7) ^ (R << 14 | R >>> 18) ^ R >>> 3, F = d[U - 2], H = (F << 15 | F >>> 17) ^ (F << 13 | F >>> 19) ^ F >>> 10;
                            d[U] = G + d[U - 7] + H + d[U - 16];
                        }
                        var B = N & O ^ ~N & z, C = m & x ^ m & _ ^ x & _, T = (m << 30 | m >>> 2) ^ (m << 19 | m >>> 13) ^ (m << 10 | m >>> 22), I = (N << 26 | N >>> 6) ^ (N << 21 | N >>> 11) ^ (N << 7 | N >>> 25), y = P + I + B + l[U] + d[U], w = T + C;
                        P = z, z = O, O = N, N = v + y | 0, v = _, _ = x, x = m, m = y + w | 0;
                    }
                    p[0] = p[0] + m | 0, p[1] = p[1] + x | 0, p[2] = p[2] + _ | 0, p[3] = p[3] + v | 0, p[4] = p[4] + N | 0, p[5] = p[5] + O | 0, p[6] = p[6] + z | 0, p[7] = p[7] + P | 0;
                },
                _doFinalize: function() {
                    var f = this._data, g = f.words, p = this._nDataBytes * 8, m = f.sigBytes * 8;
                    return g[m >>> 5] |= 128 << 24 - m % 32, g[(m + 64 >>> 9 << 4) + 14] = n.floor(p / 4294967296), g[(m + 64 >>> 9 << 4) + 15] = p, f.sigBytes = g.length * 4, this._process(), this._hash;
                },
                clone: function() {
                    var f = a.clone.call(this);
                    return f._hash = this._hash.clone(), f;
                }
            });
            s.SHA256 = a._createHelper(h), s.HmacSHA256 = a._createHmacHelper(h);
        }(Math), t.SHA256;
    });
})(X0);
var sv = X0.exports, Z0 = {
    exports: {}
};
(function(r, e) {
    (function(t, n) {
        r.exports = n(Id());
    })($, function(t) {
        return function() {
            var n = t, s = n.lib, i = s.WordArray, o = n.enc;
            o.Base64 = {
                /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */ stringify: function(u) {
                    var c = u.words, l = u.sigBytes, d = this._map;
                    u.clamp();
                    for(var h = [], f = 0; f < l; f += 3)for(var g = c[f >>> 2] >>> 24 - f % 4 * 8 & 255, p = c[f + 1 >>> 2] >>> 24 - (f + 1) % 4 * 8 & 255, m = c[f + 2 >>> 2] >>> 24 - (f + 2) % 4 * 8 & 255, x = g << 16 | p << 8 | m, _ = 0; _ < 4 && f + _ * 0.75 < l; _++)h.push(d.charAt(x >>> 6 * (3 - _) & 63));
                    var v = d.charAt(64);
                    if (v) for(; h.length % 4;)h.push(v);
                    return h.join("");
                },
                /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */ parse: function(u) {
                    var c = u.length, l = this._map, d = this._reverseMap;
                    if (!d) {
                        d = this._reverseMap = [];
                        for(var h = 0; h < l.length; h++)d[l.charCodeAt(h)] = h;
                    }
                    var f = l.charAt(64);
                    if (f) {
                        var g = u.indexOf(f);
                        g !== -1 && (c = g);
                    }
                    return a(u, c, d);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            };
            function a(u, c, l) {
                for(var d = [], h = 0, f = 0; f < c; f++)if (f % 4) {
                    var g = l[u.charCodeAt(f - 1)] << f % 4 * 2, p = l[u.charCodeAt(f)] >>> 6 - f % 4 * 2, m = g | p;
                    d[h >>> 2] |= m << 24 - h % 4 * 8, h++;
                }
                return i.create(d, h);
            }
        }(), t.enc.Base64;
    });
})(Z0);
var ov = Z0.exports, J0 = {
    exports: {}
};
(function(r, e) {
    (function(t, n) {
        r.exports = n(Id());
    })($, function(t) {
        return function() {
            if (typeof ArrayBuffer == "function") {
                var n = t, s = n.lib, i = s.WordArray, o = i.init, a = i.init = function(u) {
                    if (u instanceof ArrayBuffer && (u = new Uint8Array(u)), (u instanceof Int8Array || typeof Uint8ClampedArray < "u" && u instanceof Uint8ClampedArray || u instanceof Int16Array || u instanceof Uint16Array || u instanceof Int32Array || u instanceof Uint32Array || u instanceof Float32Array || u instanceof Float64Array) && (u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength)), u instanceof Uint8Array) {
                        for(var c = u.byteLength, l = [], d = 0; d < c; d++)l[d >>> 2] |= u[d] << 24 - d % 4 * 8;
                        o.call(this, l, c);
                    } else o.apply(this, arguments);
                };
                a.prototype = i;
            }
        }(), t.lib.WordArray;
    });
})(J0);
var av = J0.exports, Ta = $ && $.__assign || function() {
    return Ta = Object.assign || function(r) {
        for(var e, t = 1, n = arguments.length; t < n; t++){
            e = arguments[t];
            for(var s in e)Object.prototype.hasOwnProperty.call(e, s) && (r[s] = e[s]);
        }
        return r;
    }, Ta.apply(this, arguments);
}, Td = $ && $.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    };
};
Object.defineProperty(xd, "__esModule", {
    value: !0
});
var cv = Td(sv), uv = Td(ov), lv = Td(av), dv = /** @class */ function() {
    function r(e) {
        this.state = "", this.codeVerifier = "", this.config = e;
    }
    return r.prototype.authorizeUrl = function(e) {
        var t, n;
        e === void 0 && (e = {});
        var s = new URLSearchParams(Object.assign(Ta({
            response_type: !((t = this.config) === null || t === void 0) && t.implicit ? "token" : "code",
            client_id: this.config.client_id,
            state: this.getState(e.state || null),
            scope: this.config.requested_scopes,
            redirect_uri: this.config.redirect_uri
        }, !((n = this.config) === null || n === void 0) && n.implicit ? {} : {
            code_challenge: this.pkceChallengeFromVerifier(),
            code_challenge_method: "S256"
        }), e)).toString();
        return "".concat(this.config.authorization_endpoint, "?").concat(s);
    }, r.prototype.exchangeForAccessToken = function(e, t) {
        var n = this;
        return t === void 0 && (t = {}), this.parseAuthResponseUrl(e).then(function(s) {
            var i, o;
            if (!((i = n.config) === null || i === void 0) && i.implicit) {
                var a = {
                    access_token: "",
                    expires_in: 0,
                    refresh_expires_in: 0,
                    refresh_token: "",
                    scope: "",
                    token_type: ""
                }, u = new URL(e).searchParams;
                return u.forEach(function(c, l) {
                    Object.keys(a).indexOf(l) > -1 && (a[l] = typeof a[l] == "number" ? Number(c) : String(c));
                }), Promise.resolve(Object.assign(a, t));
            }
            return fetch(n.config.token_endpoint, {
                method: "POST",
                body: new URLSearchParams(Object.assign(Ta({
                    grant_type: "authorization_code",
                    code: s.code,
                    client_id: n.config.client_id,
                    redirect_uri: n.config.redirect_uri
                }, !((o = n.config) === null || o === void 0) && o.implicit ? {} : {
                    code_verifier: n.getCodeVerifier()
                }), t)),
                headers: {
                    Accept: "application/json",
                    "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
                }
            }).then(function(c) {
                return c.json();
            });
        });
    }, r.prototype.getCodeVerifier = function() {
        return this.codeVerifier === "" && (this.codeVerifier = this.randomStringFromStorage("pkce_code_verifier")), this.codeVerifier;
    }, r.prototype.getState = function(e) {
        e === void 0 && (e = null);
        var t = "pkce_state";
        return e !== null && this.getStore().setItem(t, e), this.state === "" && (this.state = this.randomStringFromStorage(t)), this.state;
    }, r.prototype.parseAuthResponseUrl = function(e) {
        var t = new URL(e).searchParams;
        return this.validateAuthResponse({
            error: t.get("error"),
            query: t.get("query"),
            state: t.get("state"),
            code: t.get("code")
        });
    }, r.prototype.pkceChallengeFromVerifier = function() {
        var e = (0, cv.default)(this.getCodeVerifier());
        return uv.default.stringify(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }, r.prototype.randomStringFromStorage = function(e) {
        var t = this.getStore().getItem(e);
        return t === null && this.getStore().setItem(e, lv.default.random(64)), this.getStore().getItem(e) || "";
    }, r.prototype.validateAuthResponse = function(e) {
        var t = this;
        return new Promise(function(n, s) {
            var i;
            return e.error ? s({
                error: e.error
            }) : e.state !== t.getState() && !(!((i = t.config) === null || i === void 0) && i.implicit) ? s({
                error: "Invalid State"
            }) : n(e);
        });
    }, r.prototype.getStore = function() {
        var e;
        return ((e = this.config) === null || e === void 0 ? void 0 : e.storage) || sessionStorage;
    }, r;
}();
xd.default = dv;
var ko = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, hv = $ && $.__importDefault || function(r) {
    return r && r.__esModule ? r : {
        default: r
    };
};
Object.defineProperty(is, "__esModule", {
    value: !0
});
is.XummPkce = is.XummPkceThread = void 0;
const fv = rr, Kh = Ia(), pv = hv(xd), it = function(...r) {
    typeof localStorage < "u" && localStorage != null && localStorage.debug && console.log(...r);
};
("TURBOPACK compile-time value", "undefined") < "u" && it("Xumm OAuth2 PKCE Authorization Code Flow lib.");
const Ds = (r)=>{
    let e = (n)=>{};
    return {
        promise: new Promise((n)=>{
            e = n;
        }),
        resolve: (n)=>e(n)
    };
};
class ey extends fv.EventEmitter {
    constructor(e, t){
        var n, s;
        super(), this.popup = null, this.resolved = !1, this.mobileRedirectFlow = !1, this.eventPromises = {
            retrieved: Ds(),
            error: Ds(),
            success: Ds(),
            loggedout: Ds()
        }, this.options = {
            redirectUrl: document.location.href,
            rememberJwt: !0,
            storage: localStorage,
            implicit: !1
        }, typeof t == "string" ? this.options.redirectUrl = t : typeof t == "object" && t && (typeof t.redirectUrl == "string" && (this.options.redirectUrl = t.redirectUrl), typeof t.rememberJwt == "boolean" && (this.options.rememberJwt = t.rememberJwt), typeof t.storage == "object" && (this.options.storage = t.storage), typeof t.implicit == "boolean" && (this.options.implicit = t.implicit));
        const i = {
            client_id: e,
            redirect_uri: this.options.redirectUrl,
            authorization_endpoint: "https://oauth2.xumm.app/auth",
            token_endpoint: "https://oauth2.xumm.app/token",
            requested_scopes: "XummPkce",
            storage: this.options.storage,
            implicit: this.options.implicit
        };
        if (this.pkce = new pv.default(i), this.options.rememberJwt) {
            it("Remember JWT");
            try {
                const a = JSON.parse(((n = this.options.storage) === null || n === void 0 ? void 0 : n.getItem("XummPkceJwt")) || "{}");
                if (a != null && a.jwt && typeof a.jwt == "string") {
                    const u = new Kh.XummSdkJwt(a.jwt);
                    this.ping = u.ping(), this.ping.then((c)=>ko(this, void 0, void 0, function*() {
                            var l;
                            !((l = c == null ? void 0 : c.jwtData) === null || l === void 0) && l.sub ? (this.autoResolvedFlow = Object.assign(a, {
                                sdk: u
                            }), yield this.authorize(), this.emit("retrieved")) : this.logout();
                        })).catch((c)=>{
                        this.logout();
                    });
                } else this.logout();
            } catch  {}
        }
        window.addEventListener("message", (a)=>{
            var u;
            if (it("Received Event from ", a.origin), String((a == null ? void 0 : a.data) || "").slice(0, 1) === "{" && String((a == null ? void 0 : a.data) || "").slice(-1) === "}" && (it("Got PostMessage with JSON"), a.origin === "https://xumm.app" || a.origin === "https://oauth2.xumm.app")) {
                it("Got PostMessage from https://xumm.app / https://oauth2.xumm.app");
                try {
                    const c = JSON.parse(a.data);
                    (c == null ? void 0 : c.source) === "xumm_sign_request" && c != null && c.payload ? it("Payload opened:", c.payload) : (c == null ? void 0 : c.source) === "xumm_sign_request_resolved" && c != null && c.options ? (it("Payload resolved, mostmessage containing options containing redirect URL: ", c), this.resolved = !0, this.pkce.exchangeForAccessToken(c.options.full_redirect_uri).then((l)=>{
                        if (this.jwt = l.access_token, l != null && l.error_description) throw new Error(l == null ? void 0 : l.error_description);
                        fetch("https://oauth2.xumm.app/userinfo", {
                            headers: {
                                Authorization: "Bearer " + l.access_token
                            }
                        }).then((d)=>d.json()).then((d)=>{
                            var h;
                            if (this.resolvePromise) {
                                if (this.options.rememberJwt) {
                                    it("Remembering JWT");
                                    try {
                                        (h = this.options.storage) === null || h === void 0 || h.setItem("XummPkceJwt", JSON.stringify({
                                            jwt: l.access_token,
                                            me: d
                                        }));
                                    } catch (f) {
                                        it("Could not persist JWT to local storage", f);
                                    }
                                }
                                this.resolvePromise({
                                    jwt: l.access_token,
                                    sdk: new Kh.XummSdkJwt(l.access_token),
                                    me: d
                                });
                            }
                        });
                    }).catch((l)=>{
                        this.rejectPromise && this.rejectPromise(l != null && l.error ? new Error(l.error) : l), it((l == null ? void 0 : l.error) || l);
                    })) : (c == null ? void 0 : c.source) === "xumm_sign_request_rejected" ? (it("Payload rejected", c == null ? void 0 : c.options), this.rejectPromise && this.rejectPromise(new Error(((u = c == null ? void 0 : c.options) === null || u === void 0 ? void 0 : u.error_description) || "Payload rejected"))) : (c == null ? void 0 : c.source) === "xumm_sign_request_popup_closed" ? (it("Popup closed, wait 750ms"), setTimeout(()=>{
                        !this.resolved && this.rejectPromise && this.rejectPromise(new Error("Sign In window closed"));
                    }, 750)) : it("Unexpected message, skipping", c == null ? void 0 : c.source);
                } catch (c) {
                    it("Error parsing message", (c == null ? void 0 : c.message) || c);
                }
            }
        }, !1);
        const o = new URLSearchParams(((s = document == null ? void 0 : document.location) === null || s === void 0 ? void 0 : s.search) || "");
        if (o.get("authorization_code") || o.get("access_token") || o.get("error_description")) {
            this.mobileRedirectFlow = !0, this.urlParams = o;
            let a = !1;
            const u = (c)=>ko(this, void 0, void 0, function*() {
                    it("onDocumentReady", document.readyState), !a && document.readyState === "complete" && (a = !0, it("(readystatechange: [ " + document.readyState + " ])"), this.handleMobileGrant(), yield this.authorize(), this.emit("retrieved"));
                });
            u(), document.addEventListener("readystatechange", u);
        }
    }
    emit(e, ...t) {
        return this.eventPromises[e].promise.then(()=>super.emit(e, ...t)), !0;
    }
    on(e, t) {
        return this.eventPromises[e].resolve(), super.on(e, t);
    }
    off(e, t) {
        return this.eventPromises[e] = Ds(), super.off(e, t);
    }
    // Todo: document, e.g. custom flow, plugin
    authorizeUrl() {
        return this.pkce.authorizeUrl();
    }
    handleMobileGrant() {
        if (this.urlParams && this.mobileRedirectFlow) {
            const e = {
                data: JSON.stringify(this.urlParams.get("authorization_code") || this.urlParams.get("access_token") ? {
                    source: "xumm_sign_request_resolved",
                    options: {
                        full_redirect_uri: document.location.href
                    }
                } : {
                    source: "xumm_sign_request_rejected",
                    options: {
                        error: this.urlParams.get("error"),
                        error_code: this.urlParams.get("error_code"),
                        error_description: this.urlParams.get("error_description")
                    }
                }),
                origin: "https://oauth2.xumm.app"
            }, t = new MessageEvent("message", e);
            return window.dispatchEvent(t), !0;
        }
        return !1;
    }
    authorize() {
        return ko(this, void 0, void 0, function*() {
            if (this.resolvedSuccessfully) return this.promise;
            this.resolved = !1;
            try {
                yield this.ping;
            } catch  {}
            if (!this.mobileRedirectFlow && !this.autoResolvedFlow) {
                const t = this.authorizeUrl(), n = window.open(t, "XummPkceLogin", "directories=no,titlebar=no,toolbar=no,location=no,status=no,menubar=no,scrollbars=no,resizable=no,width=600,height=790");
                this.popup = n, it("Popup opened...", t);
            }
            return this.resolved = !1, (()=>{
                var t;
                const n = new URLSearchParams(((t = document == null ? void 0 : document.location) === null || t === void 0 ? void 0 : t.search) || "");
                n.delete("authorization_code"), n.delete("code"), n.delete("scope"), n.delete("state"), n.delete("access_token"), n.delete("refresh_token"), n.delete("token_type"), n.delete("expires_in");
                const s = n.toString(), i = document.location.href.split("?")[0] + (s !== "" ? "?" : "") + s;
                window.history.replaceState({
                    path: i
                }, "", i);
            })(), this.autoResolvedFlow ? this.resolved || (this.resolved = !0, this.promise = Promise.resolve(this.autoResolvedFlow), this.rejectPromise = this.resolvePromise = ()=>{}, it("Auto resolved"), this.emit("success")) : this.promise = new Promise((t, n)=>{
                this.resolvePromise = (s)=>{
                    const i = t(s);
                    return this.resolved = !0, this.resolvedSuccessfully = !0, it("Xumm Sign in RESOLVED"), this.emit("success"), i;
                }, this.rejectPromise = (s)=>{
                    const i = n(s);
                    return this.resolved = !0, this.emit("error", typeof s == "string" ? new Error(s) : s), it("Xumm Sign in REJECTED"), i;
                };
            }), this.promise;
        });
    }
    state() {
        return ko(this, void 0, void 0, function*() {
            return this.promise;
        });
    }
    logout() {
        var e;
        setTimeout(()=>this.emit("loggedout"), 0);
        try {
            this.resolved = !1, this.resolvedSuccessfully = void 0, this.autoResolvedFlow = void 0, (e = this.options.storage) === null || e === void 0 || e.removeItem("XummPkceJwt"), this.mobileRedirectFlow = !1;
        } catch  {}
    }
    getPopup() {
        return this === null || this === void 0 ? void 0 : this.popup;
    }
}
is.XummPkceThread = ey;
const ri = (r)=>{
    let e = !1;
    r && ("TURBOPACK compile-time value", "undefined") == "object" && typeof window._XummPkce > "u" && (window._XummPkce = r, e = !0);
    const t = window == null ? void 0 : window._XummPkce;
    return t && e && it("XummPkce attached to window"), t;
};
class gv {
    constructor(e, t){
        ("TURBOPACK compile-time value", "undefined") > "u" || typeof document > "u" || ri() || ri(new ey(e, t));
    }
    on(e, t) {
        const n = ri();
        if (n) return n.on(e, t), this;
    }
    off(e, t) {
        const n = ri();
        if (n) return n.off(e, t), this;
    }
    authorize() {
        const e = ri();
        if (e) return e.authorize();
    }
    state() {
        const e = ri();
        if (e) return e.state();
    }
    logout() {
        const e = ri();
        if (e) return e.logout();
    }
}
is.XummPkce = gv;
var uu = {}, lu = {}, Xh;
function Zh() {
    return Xh || (Xh = 1, function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        }), r.xAppEvents = void 0, function(e) {
            e.ready = "ready", e.scanQr = "scanQr", e.payloadResolved = "payloadResolved", e.selectDestination = "selectDestination", e.networkSwitch = "networkSwitch";
        }(r.xAppEvents || (r.xAppEvents = {}));
    }(lu)), lu;
}
var Jh;
function yv() {
    return Jh || (Jh = 1, function(r) {
        var e = $ && $.__createBinding || (Object.create ? function(v, N, O, z) {
            z === void 0 && (z = O);
            var P = Object.getOwnPropertyDescriptor(N, O);
            (!P || ("get" in P ? !N.__esModule : P.writable || P.configurable)) && (P = {
                enumerable: !0,
                get: function() {
                    return N[O];
                }
            }), Object.defineProperty(v, z, P);
        } : function(v, N, O, z) {
            z === void 0 && (z = O), v[z] = N[O];
        }), t = $ && $.__exportStar || function(v, N) {
            for(var O in v)O !== "default" && !Object.prototype.hasOwnProperty.call(N, O) && e(N, v, O);
        }, n = $ && $.__awaiter || function(v, N, O, z) {
            function P(U) {
                return U instanceof O ? U : new O(function(R) {
                    R(U);
                });
            }
            return new (O || (O = Promise))(function(U, R) {
                function G(B) {
                    try {
                        H(z.next(B));
                    } catch (C) {
                        R(C);
                    }
                }
                function F(B) {
                    try {
                        H(z.throw(B));
                    } catch (C) {
                        R(C);
                    }
                }
                function H(B) {
                    B.done ? U(B.value) : P(B.value).then(G, F);
                }
                H((z = z.apply(v, N || [])).next());
            });
        }, s;
        Object.defineProperty(r, "__esModule", {
            value: !0
        }), r.xApp = void 0;
        const i = rr, o = Zh();
        t(Zh(), r);
        const a = 0.25, u = 250, c = 2e3, l = Number(/* @__PURE__ */ new Date());
        let d;
        const h = new Promise((v)=>{
            d = (N)=>{
                console.log("Doc Ready...");
                const O = (Number(/* @__PURE__ */ new Date()) - l) / 1e3;
                O < a ? (console.log("Doc not alive >= " + a + " sec, stalling for " + (a - O)), setTimeout(function() {
                    v(N);
                }, (a - O) * 1e3)) : (console.log("Doc alive " + a + "+ sec, go ahead"), v(N));
            };
        });
        h.then(()=>{
            console.log("documentReadyPromise resolved");
        }).catch((v)=>{
            console.log(v);
        }), typeof document < "u" && document.addEventListener("readystatechange", (v)=>{
            console.log("(readystatechange: [ " + document.readyState + " ])"), document.readyState === "complete" && d();
        }), ("TURBOPACK compile-time value", "undefined") < "u" && console.log("Loading xApp SDK");
        let f = ("TURBOPACK compile-time value", "undefined") < "u" ? window : {}, g = !1;
        f != null && f.parent && ((s = f.parent) === null || s === void 0 || s.postMessage("XAPP_PROXY_INIT", "*"));
        const p = (v, N, O = 0)=>n(void 0, void 0, void 0, function*() {
                var z, P;
                if (yield h, typeof (f == null ? void 0 : f.ReactNativeWebView) < "u" || g) {
                    const U = (Number(/* @__PURE__ */ new Date()) - l) / 1e3;
                    [
                        "close"
                    ].indexOf(v) > -1 && U < 4 && (console.log("xApp close, doc alive < minAliveTimeSec, stall: " + (4 - U)), yield new Promise((F)=>{
                        setTimeout(()=>{
                            F(!0);
                        }, (4 - U) * 1e3);
                    }));
                    const R = JSON.stringify(Object.assign({
                        command: v
                    }, N || {}));
                    return g ? (z = f.parent) === null || z === void 0 || z.postMessage(R, "*") : (P = f.ReactNativeWebView) === null || P === void 0 || P.postMessage(R), console.log("xAppActionAttempt Success", v, N), !0;
                } else return O * u < c ? (console.log("xAppActionAttempt Attempt " + O + "  Retry", v, N), yield new Promise((U)=>{
                    setTimeout(U, u);
                }), p(v, N, O + 1)) : (console.log("xAppActionAttempt Failed after attempt " + O, v, N), new Error("xApp." + v.replace(/^xApp/, "") + ": could not contact Xumm App Host"));
            });
        class m extends i.EventEmitter {
            constructor(){
                super(), document.readyState === "complete" && d();
                const N = (O)=>{
                    const z = O;
                    if (typeof (z == null ? void 0 : z.data) == "string" && z.data === "XAPP_PROXY_INIT_ACK") {
                        console.log("xApp Proxy ACK received, switching to PROXY (SANDBOX) mode"), g = !0;
                        return;
                    }
                    try {
                        const P = JSON.parse((z == null ? void 0 : z.data) || "{}");
                        if (console.log("_event (typeof, {_event}) ", typeof P, {
                            _event: P
                        }), typeof P == "object" && P !== null) if (typeof P.method == "string" && P.method in o.xAppEvents) {
                            console.log("xApp Event received", P.method, P);
                            const U = P.method;
                            switch(delete P.method, U){
                                case String(o.xAppEvents.payloadResolved):
                                    this.emit("payload", P);
                                    break;
                                case String(o.xAppEvents.scanQr):
                                    this.emit("qr", P);
                                    break;
                                case String(o.xAppEvents.networkSwitch):
                                    this.emit("networkswitch", P);
                                    break;
                                case String(o.xAppEvents.selectDestination):
                                    this.emit("destination", P);
                                    break;
                            }
                        } else console.log("xApp Event received, not in xAppEvents:", P.method);
                    } catch (P) {
                        const U = (P == null ? void 0 : P.message) || "";
                        U.match(/XAPP_PROXY_INIT/) || console.log("xApp Event received, cannot parse as JSON", U);
                    }
                };
                typeof window.addEventListener == "function" && window.addEventListener("message", N), typeof document.addEventListener == "function" && document.addEventListener("message", N);
            }
            getEnvironment() {
                const N = x();
                return N ? N.getEnvironment() : {
                    version: "",
                    ott: ""
                };
            }
            navigate(N) {
                return typeof (N == null ? void 0 : N.xApp) != "string" ? Promise.reject(new Error("xApp.navigate: Invalid argument: `xApp`")) : p("xAppNavigate", N);
            }
            openSignRequest(N) {
                return typeof (N == null ? void 0 : N.uuid) != "string" ? Promise.reject(new Error("xApp.openSignRequest: Invalid argument: `uuid`")) : N.uuid.match(/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i) ? p("openSignRequest", N) : Promise.reject(new Error("xApp.openSignRequest: Invalid payload UUID"));
            }
            selectDestination(N) {
                return p("selectDestination", N);
            }
            openBrowser(N) {
                return typeof (N == null ? void 0 : N.url) != "string" ? Promise.reject(new Error("xApp.openBrowser: Invalid argument: `url`")) : p("openBrowser", N);
            }
            share(N) {
                return typeof (N == null ? void 0 : N.text) != "string" ? Promise.reject(new Error("xApp.share: Invalid argument: `text`")) : p("share", N);
            }
            scanQr() {
                return p("scanQr");
            }
            tx(N) {
                return typeof (N == null ? void 0 : N.tx) != "string" ? Promise.reject(new Error("xApp.tx: Invalid argument: `tx`")) : typeof (N == null ? void 0 : N.account) != "string" ? Promise.reject(new Error("xApp.tx: Invalid argument: `account`")) : p("txDetails", N);
            }
            close(N) {
                return p("close", N);
            }
            ready() {
                return p("ready");
            }
            customCommand(N, O) {
                return p(N, O);
            }
        }
        const x = (v)=>{
            let N = !1;
            v && typeof f == "object" && typeof f._xAppSdk > "u" && (f._xAppSdk = v, N = !0);
            const O = f == null ? void 0 : f._xAppSdk;
            return O && N && console.log("xAppSdk attached to window"), O;
        };
        class _ {
            constructor(){
                if (this.xummEnvironment = {
                    version: "",
                    ott: ""
                }, !(("TURBOPACK compile-time value", "undefined") > "u" || typeof document > "u")) {
                    if (typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string") {
                        const N = navigator.userAgent.trim().match(/xumm\/xapp:([0-9]{1,}\.[0-9]{1,}\.[0-9]{1,}).*ott:([0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})/);
                        N && (this.xummEnvironment.version = N[1], this.xummEnvironment.ott = N[2]);
                    }
                    this.xummEnvironment.version === "" && console.log("Warning: Xumm Version could not be retrieved from User Agent, possibly not loaded in xApp context?"), x() || x(new m());
                }
            }
            getEnvironment() {
                return this.xummEnvironment;
            }
            on(N, O) {
                const z = x();
                if (z) return z.on(N, O), this;
            }
            off(N, O) {
                const z = x();
                if (z) return z.off(N, O), this;
            }
            navigate(N) {
                const O = x();
                if (O) return O.navigate(N);
            }
            openSignRequest(N) {
                const O = x();
                if (O && N != null && N.uuid) return O.openSignRequest(N);
            }
            selectDestination(N) {
                const O = x();
                if (O) return O.selectDestination(N);
            }
            openBrowser(N) {
                const O = x();
                if (O) return O.openBrowser(N);
            }
            share(N) {
                const O = x();
                if (O) return O.share(N);
            }
            scanQr() {
                const N = x();
                if (N) return N.scanQr();
            }
            tx(N) {
                const O = x();
                if (O) return O.tx(N);
            }
            close(N) {
                const O = x();
                if (O) return O.close(N);
            }
            ready() {
                const N = x();
                if (N) return N.ready();
            }
            customCommand(N, O) {
                const z = x();
                if (z) return z.customCommand(N, O);
            }
        }
        r.xApp = _;
    }(uu)), uu;
}
var li = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
};
Object.defineProperty(vd, "__esModule", {
    value: !0
});
var gl = vd.Xumm = void 0;
const wv = is, mv = ye, bv = rr, ef = (r)=>mv.Buffer.from(r, "base64").toString("utf8");
var tf;
(function(r) {
    r.cli = "cli", r.browser = "browser", r.xapp = "xapp";
})(tf || (tf = {}));
const ht = {
    cli: !1,
    browser: !1,
    xapp: !1
}, _s = new RegExp("^[0-9(a-f|A-F)]{8}-[0-9(a-f|A-F)]{4}-4[0-9(a-f|A-F)]{3}-[89ab][0-9(a-f|A-F)]{3}-[0-9(a-f|A-F)]{12}$"), de = {}, zo = typeof process == "object" && process ? (process == null ? void 0 : process.env) || {} : {};
Object.assign(ht, {
    cli: Object.keys(zo).indexOf("NODE") > -1 || Object.keys(zo).indexOf("SHELL") > -1 || Object.keys(zo).indexOf("TERM") > -1 || Object.keys(zo).indexOf("PATH") > -1
});
Object.assign(ht, {
    browser: typeof process == "object" && process && (process == null ? void 0 : ("TURBOPACK compile-time value", false)) || typeof document == "object" && document && (document == null ? void 0 : document.location)
});
Object.assign(ht, {
    xapp: ht.browser && (!!navigator.userAgent.match(/xumm\/xapp/i) || !!navigator.userAgent.match(/xAppBuilder/i))
});
const vv = Object.keys(ht).filter((r)=>ht[r]), $r = [], $e = (r)=>li(void 0, void 0, void 0, function*() {
        return yield Promise.all($r), yield r();
    }), As = (r)=>new Proxy(r, {
        get (e, t) {
            return [
                "on",
                "off"
            ].indexOf(String(t)) < 0 && // Events
            (typeof e[t] == "function" || e.constructor.name === "Promise") ? function() {
                return e.constructor.name === "Promise" ? e.then((n)=>$e(()=>n[t](...arguments))) : $e(()=>e[t](...arguments));
            } : e[t];
        }
    }), Ui = {
    XummSdkJwt: !1,
    XummPkce: !1,
    xApp: !1
};
let me, Mr = "", Xe = {}, we = {}, rf = 0;
class nf {
    constructor(){
        this.account = $e(()=>{
            var e, t, n;
            return (t = (e = Xe == null ? void 0 : Xe.sub) !== null && e !== void 0 ? e : we == null ? void 0 : we.sub) !== null && t !== void 0 ? t : (n = me == null ? void 0 : me.account_info) === null || n === void 0 ? void 0 : n.account;
        }), this.picture = $e(()=>{
            var e, t, n, s, i, o, a;
            return (e = we == null ? void 0 : we.picture) !== null && e !== void 0 ? e : ((n = (t = Xe == null ? void 0 : Xe.sub) !== null && t !== void 0 ? t : we == null ? void 0 : we.sub) !== null && n !== void 0 ? n : !((s = me == null ? void 0 : me.account_info) === null || s === void 0) && s.account) ? `https://xumm.app/avatar/${(o = (i = Xe == null ? void 0 : Xe.sub) !== null && i !== void 0 ? i : we == null ? void 0 : we.sub) !== null && o !== void 0 ? o : (a = me == null ? void 0 : me.account_info) === null || a === void 0 ? void 0 : a.account}.png` : void 0;
        }), this.name = $e(()=>{
            var e, t;
            return (e = we == null ? void 0 : we.name) !== null && e !== void 0 ? e : (t = me == null ? void 0 : me.account_info) === null || t === void 0 ? void 0 : t.name;
        }), this.domain = $e(()=>{
            var e, t;
            return (e = we == null ? void 0 : we.domain) !== null && e !== void 0 ? e : (t = me == null ? void 0 : me.account_info) === null || t === void 0 ? void 0 : t.domain;
        }), this.source = $e(()=>{
            var e, t;
            return (e = we == null ? void 0 : we.source) !== null && e !== void 0 ? e : (t = me == null ? void 0 : me.account_info) === null || t === void 0 ? void 0 : t.source;
        }), this.networkType = $e(()=>{
            var e, t;
            return (t = (e = we == null ? void 0 : we.networkType) !== null && e !== void 0 ? e : Xe.network_type) !== null && t !== void 0 ? t : me == null ? void 0 : me.nodetype;
        }), this.networkEndpoint = $e(()=>{
            var e, t;
            return (t = (e = we == null ? void 0 : we.networkEndpoint) !== null && e !== void 0 ? e : Xe.network_endpoint) !== null && t !== void 0 ? t : me == null ? void 0 : me.nodewss;
        }), this.networkId = $e(()=>{
            var e, t;
            return (t = (e = we == null ? void 0 : we.networkId) !== null && e !== void 0 ? e : Xe.network_id) !== null && t !== void 0 ? t : me == null ? void 0 : me.networkid;
        }), this.blocked = $e(()=>{
            var e, t;
            return (e = we == null ? void 0 : we.blocked) !== null && e !== void 0 ? e : (t = me == null ? void 0 : me.account_info) === null || t === void 0 ? void 0 : t.blocked;
        }), this.kycApproved = $e(()=>{
            var e, t;
            return (e = we == null ? void 0 : we.kycApproved) !== null && e !== void 0 ? e : (t = me == null ? void 0 : me.account_info) === null || t === void 0 ? void 0 : t.kycApproved;
        }), this.proSubscription = $e(()=>{
            var e, t;
            return (e = we == null ? void 0 : we.proSubscription) !== null && e !== void 0 ? e : (t = me == null ? void 0 : me.account_info) === null || t === void 0 ? void 0 : t.proSubscription;
        }), this.profile = $e(()=>{
            var e, t, n;
            return (e = we == null ? void 0 : we.profile) !== null && e !== void 0 ? e : !((n = (t = me == null ? void 0 : me.account_info) === null || t === void 0 ? void 0 : t.profile) === null || n === void 0) && n.slug ? me.account_info.profile : void 0;
        }), this.token = $e(()=>{
            var e;
            return (e = Xe == null ? void 0 : Xe.usertoken_uuidv4) !== null && e !== void 0 ? e : null;
        });
    }
}
class Ev extends bv.EventEmitter {
    constructor(e, t){
        var n, s, i, o;
        super(), this.instance = "0", this.jwtCredential = !1, this.runtime = ht, this.apiKeyOrJwt = "", this.apiKeyOrJwt = e, this.apiSecretOrOtt = t, rf++, this.instance = String(rf), typeof (console == null ? void 0 : console.log) < "u" && (ht.cli || console.log("Constructed Xumm", {
            runtime: vv
        }));
        let a = !1;
        if (typeof this.apiKeyOrJwt == "string" && this.apiKeyOrJwt.split(".").length === 3) {
            let c;
            try {
                c = JSON.parse(ef((n = this.apiKeyOrJwt.split(".")) === null || n === void 0 ? void 0 : n[1]));
            } catch  {}
            if (Date.now() >= c.exp * 1e3) {
                a = !0;
                const l = (o = (i = (s = c == null ? void 0 : c.app_uuidv4) !== null && s !== void 0 ? s : c == null ? void 0 : c.client_id) !== null && i !== void 0 ? i : c == null ? void 0 : c.aud) !== null && o !== void 0 ? o : "";
                if (this.apiKeyOrJwt = l, ht.cli || console.log("JWT expired, falling back to API KEY: " + l), ht.cli || ht.xapp) {
                    const d = new Error("JWT Expired, cannot fall back to API credential: in CLI/xApp environment");
                    throw this.emit("error", d), d;
                }
            }
            a || (this.jwtCredential = !0, Mr = this.apiKeyOrJwt);
        }
        this.initialize(), this.user = new nf(), this.environment = {
            jwt: $e(()=>Xe),
            ott: $e(()=>me),
            openid: $e(()=>we),
            bearer: $e(()=>Mr),
            ready: new Promise((c)=>this.on("ready", ()=>c(void 0))),
            success: new Promise((c)=>this.on("success", ()=>c(void 0))),
            retrieved: new Promise((c)=>this.on("retrieved", ()=>c(void 0))),
            retrieving: new Promise((c)=>this.on("retrieving", ()=>c(void 0)))
        }, this.state = {
            account: "",
            signedIn: !1
        }, this.helpers = As($e(()=>de.XummSdk || de.XummSdkJwt)), this.push = As($e(()=>(de.XummSdk || de.XummSdkJwt).Push)), this.payload = As($e(()=>(de.XummSdk || de.XummSdkJwt).payload)), this.userstore = As($e(()=>(de.XummSdk || de.XummSdkJwt).jwtUserdata)), this.backendstore = As($e(()=>(de.XummSdk || de.XummSdkJwt).storage));
        const u = de == null ? void 0 : de.xApp;
        u && (this.xapp = u), setTimeout(()=>Promise.all([
                ...$r.filter((c)=>(c == null ? void 0 : c.promiseType) !== "pkceRetrieverResolver"),
                /**
         * If PKCE flow: wait for `ready` till account is known
         */ ht.xapp ? Promise.resolve() : new Promise((c)=>{
                    var l;
                    de != null && de.XummPkce ? (this.user.account.then(()=>c()), (l = de.XummPkce) === null || l === void 0 || l.on("loggedout", ()=>c())) : c();
                })
            ]).then(()=>this.emit("ready")), // Constructor ready
        0);
    }
    initialize() {
        me = void 0, typeof this.apiKeyOrJwt == "string" && this.apiKeyOrJwt.split(".").length === 3 && Mr === this.apiKeyOrJwt || (Mr = "", Xe = {}), we = {}, Ui.XummSdkJwt = !1;
        const e = ()=>li(this, void 0, void 0, function*() {
                de != null && de.xApp && (Ui.xApp = !0, de.xApp.on("qr", (s)=>{
                    this.emit("qr", s, this.instance);
                }), de.xApp.on("payload", (s)=>{
                    this.emit("payload", s, this.instance);
                }), de.xApp.on("networkswitch", (s)=>{
                    this.emit("networkswitch", s, this.instance);
                }), de.xApp.on("destination", (s)=>{
                    this.emit("destination", s, this.instance);
                }));
            });
        this.handlePkceEvents();
        const t = ()=>li(this, void 0, void 0, function*() {
                var s;
                if (de != null && de.XummSdkJwt && !Ui.XummSdkJwt) {
                    Ui.XummSdkJwt = !0;
                    const i = this.jwtCredential || Mr !== "";
                    i || ($r.push(de.XummSdkJwt.getOttData()), $r.push(de.XummSdkJwt.getJwt()));
                    const o = i ? null : yield de.XummSdkJwt.getOttData(), a = i ? Mr : yield de.XummSdkJwt.getJwt();
                    if (o && (me = o, me != null && me.account && (this.state.account = me.account, this.state.signedIn = !0), this.emit("retrieved"), this.emit("success")), a) {
                        Mr = a;
                        try {
                            Xe = JSON.parse(ef((s = Mr.split(".")) === null || s === void 0 ? void 0 : s[1])), i && this.jwtCredential && (setTimeout(()=>this.emit("retrieved"), 0), setTimeout(()=>this.emit("success"), 0));
                        } catch (u) {
                            typeof (console == null ? void 0 : console.log) < "u" && (ht.cli || console.log("Error decoding JWT", (u == null ? void 0 : u.message) || ""));
                        }
                    }
                }
            }), n = ()=>{
            var s, i, o;
            de != null && de.XummSdkJwt || (Object.assign(de, {
                XummSdkJwt: new (Ia()).XummSdkJwt(this.apiKeyOrJwt, // Get OTT from UA if present, otherwise fall back to default behaviour
                typeof ((s = de == null ? void 0 : de.xApp) === null || s === void 0 ? void 0 : s.getEnvironment) < "u" && ((o = (i = de == null ? void 0 : de.xApp) === null || i === void 0 ? void 0 : i.getEnvironment()) === null || o === void 0 ? void 0 : o.ott) || void 0)
            }), $r.push(t()));
        };
        if (ht.xapp) {
            if (typeof this.apiKeyOrJwt != "string" || !(_s.test(this.apiKeyOrJwt) || this.jwtCredential)) throw new Error("Running in xApp, constructor requires first param. to be Xumm API Key or JWT");
            de != null && de.xApp || Object.assign(de, {
                xApp: new (yv()).xApp()
            }), $r.push(e()), n();
        } else if (ht.browser) {
            if (typeof this.apiKeyOrJwt != "string" || !(_s.test(this.apiKeyOrJwt) || this.jwtCredential)) throw new Error("Running in browser, constructor requires first param. to be Xumm API Key or JWT");
            if (!(de != null && de.XummPkce) && !ht.xapp && (Object.assign(de, {
                XummPkce: new wv.XummPkce(this.apiKeyOrJwt, {
                    implicit: !0
                })
            }), de.XummPkce)) if (this.jwtCredential) n();
            else {
                setTimeout(()=>this.emit("retrieving"), 0);
                const s = (o)=>{
                    var a, u;
                    (u = (a = de.XummPkce) === null || a === void 0 ? void 0 : a.state()) === null || u === void 0 || u.then((c)=>{
                        var l;
                        c != null && c.sdk && !(de != null && de.XummSdkJwt) && (Object.assign(de, {
                            XummSdkJwt: c.sdk
                        }), Object.assign(we, Object.assign({}, (c == null ? void 0 : c.me) || {})), !((l = c == null ? void 0 : c.me) === null || l === void 0) && l.account && (this.state.account = c.me.account, this.state.signedIn = !0)), c != null && c.jwt && Mr === "" && (Mr = c.jwt, t()), o(c);
                    });
                };
                $r.push(this.handlePkceEvents());
                const i = new Promise((o)=>{
                    var a, u;
                    (a = de.XummPkce) === null || a === void 0 || a.on("retrieved", ()=>{
                        s(o);
                    }), (u = de.XummPkce) === null || u === void 0 || u.on("success", ()=>{
                        s(o);
                    });
                });
                $r.push(Object.assign(i, {
                    promiseType: "pkceRetrieverResolver"
                }));
            }
        } else if (ht.cli) {
            if (typeof this.apiKeyOrJwt != "string") throw new Error("Running CLI, constructor needs first param. to be Xumm API Key / raw JWT");
            if (_s.test(this.apiKeyOrJwt) && (typeof this.apiSecretOrOtt != "string" || !_s.test(this.apiSecretOrOtt))) throw new Error("Running CLI, constructor first param. is API Key, but second param. isn't a valid API Secret");
            if (!_s.test(this.apiKeyOrJwt) && this.apiKeyOrJwt.split(".").length !== 3) throw new Error("Running CLI, constructor first param. not a valid JWT, nor a valid API Key");
            this.jwtCredential ? n() : de != null && de.XummSdk || Object.assign(de, {
                XummSdk: new (Ia()).XummSdk(this.apiKeyOrJwt, this.apiSecretOrOtt)
            });
        }
    }
    /**
   * PKCE
   */ authorize() {
        var e;
        return li(this, void 0, void 0, function*() {
            try {
                return yield (e = de == null ? void 0 : de.XummPkce) === null || e === void 0 ? void 0 : e.authorize();
            } catch (t) {
                return t;
            }
        });
    }
    /**
   * TODO: CHECK IF EVENTS ARE NOT REGISTERED AND FIRING TWICE
   */ handlePkceEvents() {
        return li(this, void 0, void 0, function*() {
            if (de != null && de.XummPkce && !Ui.XummPkce) {
                Ui.XummPkce = !0;
                const e = ()=>this.emit("retrieved"), t = ()=>this.emit("success"), n = (s)=>this.emit("error", s);
                de.XummPkce.on("retrieved", e), de.XummPkce.on("success", t), de.XummPkce.on("error", n);
            }
        });
    }
    logout() {
        var e;
        return li(this, void 0, void 0, function*() {
            if (ht.xapp) return;
            let t = !1;
            this.state.account = "", this.state.signedIn = !1, typeof this.apiKeyOrJwt == "string" && this.apiKeyOrJwt.split(".").length === 3 && Xe != null && Xe.app_uuidv4 && this.jwtCredential && (this.apiKeyOrJwt = Xe.app_uuidv4, this.jwtCredential = !1, t = !0, window._XummPkce = void 0), ht.browser && (we != null && we.sub || t) && ((e = de == null ? void 0 : de.XummPkce) === null || e === void 0 || e.logout(), Object.assign(de, {
                XummSdk: void 0,
                XummSdkJwt: void 0,
                XummPkce: void 0
            }), $r.length = 0, this.jwtCredential = !1, this.initialize(), this.user = new nf(), this.environment = {
                jwt: $e(()=>Xe),
                ott: $e(()=>me),
                openid: $e(()=>we),
                bearer: $e(()=>Mr),
                ready: new Promise((n)=>this.on("ready", ()=>n(void 0))),
                success: new Promise((n)=>this.on("success", ()=>n(void 0))),
                retrieved: new Promise((n)=>this.on("retrieved", ()=>n(void 0))),
                retrieving: new Promise((n)=>this.on("retrieving", ()=>n(void 0)))
            }, this.emit("logout"));
        });
    }
    /**
   * SDK
   */ ping() {
        var e;
        return li(this, void 0, void 0, function*() {
            return yield Promise.all($r), (e = (de == null ? void 0 : de.XummSdkJwt) || (de == null ? void 0 : de.XummSdk)) === null || e === void 0 ? void 0 : e.ping();
        });
    }
}
gl = vd.Xumm = Ev;
const wn = rc("[Xaman]");
class Mv {
    constructor(e = {}){
        this.id = "xaman", this.name = "Xaman", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8zMTE2Xzk1OCkiPgo8cGF0aCBkPSJNMjU2IDBIMFYyNTZIMjU2VjBaIiBmaWxsPSIjMDAzMENGIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTUyLjc4MiAtMjM3LjMzOEMyMDguMyAtMjE3LjMyMyAyNjIuMTgzIC0xNzIuNjk0IDI5My45MTQgLTEzNi4zNTlDMzI1LjczIC05OS45MjM4IDM0OC4yMTMgLTU3LjAyMDEgMzUzLjI2MSAtNy41MjA3NEMzNTguMzEgNDEuOTkwOSAzNDUuODg1IDk3LjgwNTEgMzA4LjQwMyAxNTkuOTkzQzI3MS4wMDMgMjIyLjA0NiAxOTMuNjYyIDMxNS4zMDYgMTE3Ljc2OSAzODQuMDM3Qzc5LjgzNDQgNDE4LjM5IDQyLjA4NzkgNDQ2Ljc3NyA5LjczNjk0IDQ2Mi4wMzZDLTYuNDMyNzggNDY5LjY2MyAtMjEuNDU1MSA0NzQuMTA3IC0zNC41OTU4IDQ3NC4yNDFDLTQ3LjgzOCA0NzQuMzc3IC01OS4yMTg5IDQ3MC4xMjIgLTY3LjcyMDQgNDYwLjM4NkMtNzYuMDY2NiA0NTAuODI5IC04Mi4xODggNDM1LjMzMSAtODYuNTM0MyA0MTUuNzE3Qy05MC44OTg4IDM5Ni4wMjEgLTkzLjU0NTMgMzcxLjgyNyAtOTQuNzA0NiAzNDQuNTU3Qy05Ny4wMjM0IDI5MC4wMDggLTkzLjQwMjIgMjIyLjg2MSAtODUuNDg1OCAxNTQuMTc0Qy03Ny41Njg0IDg1LjQ3NzMgLTY1LjM0NTMgMTUuMTU5NiAtNTAuNDMxNSAtNDUuNzQzMUMtMzUuNTM2MiAtMTA2LjU3IC0xNy44OTc0IC0xNTguMjYgMC45NDc1NDggLTE4OS41MjdDMTkuODk1MyAtMjIwLjk2NCA0My44NjY3IC0yMzguMDgyIDcwLjI2OTYgLTI0NC42OTNDOTYuNTg3MiAtMjUxLjI4MyAxMjQuOTk3IC0yNDcuMzU1IDE1Mi43ODIgLTIzNy4zMzhaTTcxLjYwNTUgLTIzOS4zNThDNDYuNzgwMiAtMjMzLjE0MiAyMy45NDg5IC0yMTcuMDM1IDUuNjU4MDkgLTE4Ni42ODhDLTEyLjczNTUgLTE1Ni4xNyAtMzAuMjE5IC0xMDUuMTYgLTQ1LjA4OTMgLTQ0LjQzNUMtNTkuOTQxMiAxNi4yMTUxIC03Mi4xMjcyIDg2LjMwMzQgLTgwLjAyMiAxNTQuODA0Qy04Ny45MTc5IDIyMy4zMTMgLTkxLjUxMjIgMjkwLjE1NSAtODkuMjA5NSAzNDQuMzIzQy04OC4wNTggMzcxLjQxMSAtODUuNDM0NSAzOTUuMjU4IC04MS4xNjQ2IDQxNC41MjdDLTc2Ljg3NjYgNDMzLjg3OCAtNzAuOTk5NCA0NDguMjcgLTYzLjU3NzcgNDU2Ljc2OUMtNTYuMzExMSA0NjUuMDkgLTQ2LjU3NzkgNDY4Ljg2MyAtMzQuNjUxOSA0NjguNzQyQy0yMi42MjQzIDQ2OC42MTkgLTguNDI0MTkgNDY0LjUyMSA3LjM5MDY3IDQ1Ny4wNjFDMzkuMDA4OSA0NDIuMTQ4IDc2LjI4MDEgNDE0LjE4OSAxMTQuMDc3IDM3OS45NkMxODkuNjQ0IDMxMS41MjQgMjY2LjYxNiAyMTguNjcgMzAzLjY5MiAxNTcuMTU0QzM0MC42ODggOTUuNzczNiAzNTIuNjk1IDQxLjEzODkgMzQ3Ljc4OSAtNi45NjI3NUMzNDIuODgzIC01NS4wNzY3IDMyMS4wMjUgLTk2Ljk1MDUgMjg5Ljc3MSAtMTMyLjc0MUMyNTguNDI5IC0xNjguNjMxIDIwNS4yODEgLTIxMi41NjQgMTUwLjkxNyAtMjMyLjE2NEMxMjMuNzYgLTI0MS45NTQgOTYuNTE2MSAtMjQ1LjU5NiA3MS42MDU1IC0yMzkuMzU4WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MC4zOTcgLTIwMS4wNjNDMjAwLjQyMSAtMTgzLjAyOCAyNDguOTUyIC0xNDIuODI4IDI3Ny41MjkgLTExMC4xMDRDMzA2LjE5MyAtNzcuMjggMzI2LjQ1OSAtMzguNjE1MiAzMzEuMDA5IDYuMDAzNDZDMzM1LjU2IDUwLjYzNDQgMzI0LjM1NiAxMDAuOTI2IDI5MC41OTggMTU2LjkzNkMyNTYuOTIyIDIxMi44MSAxODcuMjk3IDI5Ni43NjQgMTE4Ljk3NiAzNTguNjM3Qzg0LjgyODggMzg5LjU2MSA1MC44MzMyIDQxNS4xMzEgMjEuNjgwNyA0MjguODgxQzcuMTEwMjEgNDM1Ljc1NCAtNi40NTA5NiA0MzkuNzcxIC0xOC4zMzMyIDQzOS44OTJDLTMwLjMxNzEgNDQwLjAxNSAtNDAuNjQyMyA0MzYuMTYxIC00OC4zNTUzIDQyNy4zMjlDLTU1LjkxMzIgNDE4LjY3NCAtNjEuNDM0NyA0MDQuNjcxIC02NS4zNDkzIDM4Ny4wMDVDLTY5LjI4MiAzNjkuMjU3IC03MS42NjUxIDM0Ny40NjUgLTcyLjcwODggMzIyLjkxM0MtNzQuNzk2NiAyNzMuOCAtNzEuNTM2MiAyMTMuMzUzIC02NC40MTA0IDE1MS41MjVDLTU3LjI4MzUgODkuNjg4NCAtNDYuMjgwOCAyNi4zOTEgLTMyLjg1NTMgLTI4LjQzNDFDLTE5LjQ0ODMgLTgzLjE4MzkgLTMuNTY1NjQgLTEyOS43MzkgMTMuNDE3NCAtMTU3LjkxNkMzMC41MDMyIC0xODYuMjY0IDUyLjEzNDQgLTIwMS43MjEgNzUuOTc1OSAtMjA3LjY5MUM5OS43MzIxIC0yMTMuNjM5IDEyNS4zNTkgLTIxMC4wODkgMTUwLjM5NyAtMjAxLjA2M1pNNzcuMzExOSAtMjAyLjM1NUM1NS4wNDc5IC0xOTYuNzgxIDM0LjU1NjggLTE4Mi4zMzUgMTguMTI3OSAtMTU1LjA3N0MxLjU5NjI2IC0xMjcuNjQ4IC0xNC4xMzExIC04MS43NzM3IC0yNy41MTMyIC0yNy4xMjZDLTQwLjg3NjggMjcuNDQ2NSAtNTEuODQyMyA5MC41MTQ1IC01OC45NDY1IDE1Mi4xNTVDLTY2LjA1MTggMjEzLjgwNSAtNjkuMjg1NCAyNzMuOTQ3IC02Ny4yMTM3IDMyMi42NzlDLTY2LjE3NzggMzQ3LjA1IC02My44MTc3IDM2OC40OTQgLTU5Ljk3OTYgMzg1LjgxNUMtNTYuMTIzMiA0MDMuMjE4IC01MC44NDYgNDE2LjExNSAtNDQuMjEyNiA0MjMuNzExQy0zNy43MzQ1IDQzMS4xMjkgLTI5LjA1NyA0MzQuNTAyIC0xOC4zODk0IDQzNC4zOTNDLTcuNjIwMjEgNDM0LjI4MyA1LjExODc5IDQzMC42MTIgMTkuMzM0NCA0MjMuOTA3QzQ3Ljc1NDIgNDEwLjUwMiA4MS4yNzQ1IDM4NS4zNiAxMTUuMjg0IDM1NC41NkMxODMuMjc5IDI5Mi45ODIgMjUyLjUzNSAyMDkuNDM0IDI4NS44ODcgMTU0LjA5NkMzMTkuMTU5IDk4Ljg5NDYgMzI5Ljk0NSA0OS43ODI0IDMyNS41MzcgNi41NjE0M0MzMjEuMTI5IC0zNi42NzE4IDMwMS40ODcgLTc0LjMwNjcgMjczLjM4NiAtMTA2LjQ4NkMyNDUuMTk4IC0xMzguNzY0IDE5Ny40MDIgLTE3OC4yNyAxNDguNTMyIC0xOTUuODg5QzEyNC4xMjMgLTIwNC42ODkgOTkuNjYxMSAtMjA3Ljk1MiA3Ny4zMTE5IC0yMDIuMzU1WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0OC4wMTIgLTE2NC43ODhDMTkyLjU0MSAtMTQ4LjczNCAyMzUuNzIxIC0xMTIuOTYxIDI2MS4xNDQgLTgzLjg0ODZDMjg2LjY1NCAtNTQuNjM2NCAzMDQuNzAzIC0yMC4yMTA1IDMwOC43NTYgMTkuNTI3NUMzMTIuODEgNTkuMjc3OCAzMDIuODI3IDEwNC4wNDcgMjcyLjc5MyAxNTMuODc4QzI0Mi44NDEgMjAzLjU3NCAxODAuOTMxIDI3OC4yMjMgMTIwLjE4NCAzMzMuMjM3Qzg5LjgyMjkgMzYwLjczMiA1OS41NzgxIDM4My40ODUgMzMuNjI0MSAzOTUuNzI2QzIwLjY1MjkgNDAxLjg0NSA4LjU1MjgxIDQwNS40MzUgLTIuMDcxMDQgNDA1LjU0NEMtMTIuNzk2NSA0MDUuNjUzIC0yMi4wNjYgNDAyLjIwMSAtMjguOTkwNiAzOTQuMjcxQy0zNS43NiAzODYuNTIgLTQwLjY4MTYgMzc0LjAxMSAtNDQuMTY0NSAzNTguMjkzQy00Ny42NjU2IDM0Mi40OTQgLTQ5Ljc4NTEgMzIzLjEwNCAtNTAuNzEzMyAzMDEuMjY5Qy01Mi41NyAyNTcuNTkyIC00OS42NzAzIDIwMy44NDQgLTQzLjMzNTIgMTQ4Ljg3NkMtMzYuOTk4OSA5My44OTk0IC0yNy4yMTY3IDM3LjYyMjMgLTE1LjI3OTUgLTExLjEyNTJDLTMuMzYwNzIgLTU5Ljc5NzQgMTAuNzY1OCAtMTAxLjIxNyAyNS44ODcgLTEyNi4zMDVDNDEuMTEwOCAtMTUxLjU2NCA2MC40MDIgLTE2NS4zNiA4MS42ODIgLTE3MC42ODhDMTAyLjg3NyAtMTc1Ljk5NSAxMjUuNzIxIC0xNzIuODI0IDE0OC4wMTIgLTE2NC43ODhaTTgzLjAxOCAtMTY1LjM1M0M2My4zMTU1IC0xNjAuNDE5IDQ1LjE2NDUgLTE0Ny42MzUgMzAuNTk3NSAtMTIzLjQ2NkMxNS45Mjc3IC05OS4xMjcgMS45NTY0NyAtNTguMzg3MiAtOS45MzczMiAtOS44MTcwNEMtMjEuODEyNyAzOC42Nzc3IC0zMS41NTc3IDk0LjcyNTUgLTM3Ljg3MTMgMTQ5LjUwNkMtNDQuMTg2IDIwNC4yOTYgLTQ3LjA1ODggMjU3LjczOSAtNDUuMjE4MiAzMDEuMDM2Qy00NC4yOTc4IDMyMi42ODggLTQyLjIwMTIgMzQxLjczMSAtMzguNzk0OCAzNTcuMTAzQy0zNS4zNzAyIDM3Mi41NTggLTMwLjY5MjkgMzgzLjk2MSAtMjQuODQ3OSAzOTAuNjU0Qy0xOS4xNTgyIDM5Ny4xNjkgLTExLjUzNjQgNDAwLjE0IC0yLjEyNzIyIDQwMC4wNDRDNy4zODM1NCAzOTkuOTQ3IDE4LjY2MTQgMzk2LjcwMyAzMS4yNzc4IDM5MC43NTJDNTYuNDk5MSAzNzguODU2IDg2LjI2ODYgMzU2LjUzMSAxMTYuNDkyIDMyOS4xNkMxNzYuOTE0IDI3NC40NDEgMjM4LjQ1NCAyMDAuMTk4IDI2OC4wODIgMTUxLjAzOUMyOTcuNjMgMTAyLjAxNiAzMDcuMTk0IDU4LjQyNTggMzAzLjI4NCAyMC4wODU1QzI5OS4zNzMgLTE4LjI2NyAyODEuOTQ5IC01MS42NjMgMjU3LjAwMSAtODAuMjMwOUMyMzEuOTY3IC0xMDguODk4IDE4OS41MjMgLTE0My45NzYgMTQ2LjE0NiAtMTU5LjYxNEMxMjQuNDg0IC0xNjcuNDIzIDEwMi44MDYgLTE3MC4zMDggODMuMDE4IC0xNjUuMzUzWiIgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0NS42MjcgLTEyOC41MTNDMTg0LjY2MiAtMTE0LjQ0IDIyMi40OTEgLTgzLjA5NTIgMjQ0Ljc2IC01Ny41OTM2QzI2Ny4xMTcgLTMxLjk5MjcgMjgyLjk0OSAtMS44MDU2MyAyODYuNTA0IDMzLjA1MTdDMjkwLjA2IDY3LjkyMTIgMjgxLjMgMTA3LjE2OCAyNTQuOTkgMTUwLjgyMUMyMjguNzYxIDE5NC4zMzggMTc0LjU2NiAyNTkuNjgxIDEyMS4zOTIgMzA3LjgzN0M5NC44MTc0IDMzMS45MDQgNjguMzIzNCAzNTEuODM5IDQ1LjU2NzkgMzYyLjU3MkMzNC4xOTU4IDM2Ny45MzYgMjMuNTU2OSAzNzEuMDk5IDE0LjE5MTQgMzcxLjE5NUM0LjcyNDQxIDM3MS4yOTEgLTMuNDg5MzggMzY4LjI0MSAtOS42MjU2NCAzNjEuMjE0Qy0xNS42MDY3IDM1NC4zNjUgLTE5LjkyODMgMzQzLjM1IC0yMi45Nzk1IDMyOS41ODFDLTI2LjA0ODggMzE1LjczIC0yNy45MDQ4IDI5OC43NDIgLTI4LjcxNzUgMjc5LjYyNUMtMzAuMzQzMSAyNDEuMzg0IC0yNy44MDQzIDE5NC4zMzYgLTIyLjI1OTcgMTQ2LjIyOEMtMTYuNzE0MSA5OC4xMTA1IC04LjE1MjM2IDQ4Ljg1MzYgMi4yOTY1NyA2LjE4Mzc1QzEyLjcyNyAtMzYuNDEwOCAyNS4wOTc1IC03Mi42OTU3IDM4LjM1NjYgLTk0LjY5NDZDNTEuNzE4NiAtMTE2Ljg2NCA2OC42Njk2IC0xMjguOTk4IDg3LjM4ODIgLTEzMy42ODZDMTA2LjAyMiAtMTM4LjM1MiAxMjYuMDgzIC0xMzUuNTU4IDE0NS42MjcgLTEyOC41MTNaTTg4LjcyNDIgLTEyOC4zNUM3MS41ODMxIC0xMjQuMDU4IDU1Ljc3MjIgLTExMi45MzUgNDMuMDY3MiAtOTEuODU1NEMzMC4yNTk0IC03MC42MDU0IDE4LjA0NDIgLTM1LjAwMDYgNy42Mzg3MyA3LjQ5MTkzQy0yLjc0ODMxIDQ5LjkwOTEgLTExLjI3MjkgOTguOTM2NiAtMTYuNzk1OSAxNDYuODU3Qy0yMi4zMTk5IDE5NC43ODggLTI0LjgzMTkgMjQxLjUzMSAtMjMuMjIyNCAyNzkuMzkyQy0yMi40MTc1IDI5OC4zMjYgLTIwLjU4NDUgMzE0Ljk2NyAtMTcuNjA5OCAzMjguMzkxQy0xNC42MTY5IDM0MS44OTcgLTEwLjUzOTUgMzUxLjgwNiAtNS40ODI5MiAzNTcuNTk2Qy0wLjU4MTU4MSAzNjMuMjA5IDUuOTg0NTIgMzY1Ljc3OCAxNC4xMzUzIDM2NS42OTVDMjIuMzg3NiAzNjUuNjExIDMyLjIwNDQgMzYyLjc5NCA0My4yMjE2IDM1Ny41OTdDNjUuMjQ0NCAzNDcuMjEgOTEuMjYzMSAzMjcuNzAyIDExNy43IDMwMy43NkMxNzAuNTQ5IDI1NS45IDIyNC4zNzQgMTkwLjk2MiAyNTAuMjggMTQ3Ljk4MkMyNzYuMTAyIDEwNS4xMzcgMjg0LjQ0NSA2Ny4wNjkzIDI4MS4wMzIgMzMuNjA5N0MyNzcuNjE5IDAuMTM3Nzg3IDI2Mi40MTIgLTI5LjAxOTMgMjQwLjYxOCAtNTMuOTc1OUMyMTguNzM3IC03OS4wMzE4IDE4MS42NDQgLTEwOS42ODEgMTQzLjc2MiAtMTIzLjMzOUMxMjQuODQ3IC0xMzAuMTU4IDEwNS45NTEgLTEzMi42NjQgODguNzI0MiAtMTI4LjM1WiIgZmlsbD0idXJsKCNwYWludDNfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0My4yNDIgLTkyLjIzNzVDMTc2Ljc4MyAtODAuMTQ1MiAyMDkuMjYgLTUzLjIyOSAyMjguMzc2IC0zMS4zMzg3QzI0Ny41NzkgLTkuMzQ4OTIgMjYxLjE5NCAxNi41OTkzIDI2NC4yNTEgNDYuNTc2QzI2Ny4zMDkgNzYuNTY0OSAyNTkuNzcxIDExMC4yODkgMjM3LjE4NCAxNDcuNzY0QzIxNC42NzkgMTg1LjEwMyAxNjguMjAxIDI0MS4xNCAxMjIuNiAyODIuNDM4Qzk5LjgxMTUgMzAzLjA3NSA3Ny4wNjg1IDMyMC4xOTMgNTcuNTExNSAzMjkuNDE3QzQ3LjczODcgMzM0LjAyNyAzOC41NjA5IDMzNi43NjMgMzAuNDUzOSAzMzYuODQ2QzIyLjI0NTIgMzM2LjkyOSAxNS4wODcyIDMzNC4yOCA5LjczOTM0IDMyOC4xNTZDNC41NDY3MiAzMjIuMjEgMC44MjQ5NzYgMzEyLjY5IC0xLjc5NDQ4IDMwMC44NjlDLTQuNDMyMDcgMjg4Ljk2NiAtNi4wMjQ1OSAyNzQuMzggLTYuNzIxNyAyNTcuOTgyQy04LjExNjI1IDIyNS4xNzYgLTUuOTM4MTggMTg0LjgyNyAtMS4xODQyNCAxNDMuNTc5QzMuNTcwNzYgMTAyLjMyMiAxMC45MTIxIDYwLjA4NSAxOS44NzI3IDIzLjQ5MjdDMjguODE0OSAtMTMuMDI0MiAzOS40MjkyIC00NC4xNzQyIDUwLjgyNjUgLTYzLjA4MzlDNjIuMzI2NSAtODIuMTY0IDc2LjkzNzMgLTkyLjYzNzIgOTMuMDk0NiAtOTYuNjgzQzEwOS4xNjcgLTEwMC43MDcgMTI2LjQ0NSAtOTguMjkzIDE0My4yNDIgLTkyLjIzNzVaTTk0LjQzMDUgLTkxLjM0NzhDNzkuODUwOCAtODcuNjk3IDY2LjM4MDEgLTc4LjIzNSA1NS41MzcgLTYwLjI0NDdDNDQuNTkxMSAtNDIuMDgzOSAzNC4xMzIxIC0xMS42MTQxIDI1LjIxNDkgMjQuODAwOUMxNi4zMTYxIDYxLjE0MDQgOS4wMTE5NiAxMDMuMTQ4IDQuMjc5NTkgMTQ0LjIwOUMtMC40NTM4NTIgMTg1LjI3OSAtMi42MDUwNiAyMjUuMzIzIC0xLjIyNjY2IDI1Ny43NDhDLTAuNTM3Mjg2IDI3My45NjUgMS4wMzIyMyAyODguMjAzIDMuNTc1MjYgMjk5LjY3OUM2LjEzNjQzIDMxMS4yMzcgOS42MTM4OSAzMTkuNjUxIDEzLjg4MjEgMzI0LjUzOUMxNy45OTUgMzI5LjI0OCAyMy41MDU0IDMzMS40MTYgMzAuMzk3NyAzMzEuMzQ2QzM3LjM5MTYgMzMxLjI3NCA0NS43NDcyIDMyOC44ODUgNTUuMTY1MiAzMjQuNDQzQzczLjk4OTUgMzE1LjU2NCA5Ni4yNTcyIDI5OC44NzQgMTE4LjkwOCAyNzguMzYxQzE2NC4xODMgMjM3LjM1OCAyMTAuMjkyIDE4MS43MjYgMjMyLjQ3NCAxNDQuOTI0QzI1NC41NzMgMTA4LjI1OCAyNjEuNjk0IDc1LjcxMjkgMjU4Ljc3OSA0Ny4xMzRDMjU1Ljg2NCAxOC41NDI3IDI0Mi44NzQgLTYuMzc1NTggMjI0LjIzNCAtMjcuNzIwOUMyMDUuNTA3IC00OS4xNjU2IDE3My43NjUgLTc1LjM4NyAxNDEuMzc3IC04Ny4wNjM0QzEyNS4yMDkgLTkyLjg5MjMgMTA5LjA5NiAtOTUuMDE5OSA5NC40MzA1IC05MS4zNDc4WiIgZmlsbD0idXJsKCNwYWludDRfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0MC44NTcgLTU1Ljk2MjVDMTY4LjkwNCAtNDUuODUxIDE5Ni4wMjkgLTIzLjM2MjkgMjExLjk5MiAtNS4wODM3M0MyMjguMDQxIDEzLjI5NDggMjM5LjQzOSAzNS4wMDQxIDI0MS45OTkgNjAuMTAwMUMyNDQuNTU5IDg1LjIwODQgMjM4LjI0MiAxMTMuNDEgMjE5LjM4IDE0NC43MDZDMjAwLjU5OCAxNzUuODY3IDE2MS44MzUgMjIyLjU5OSAxMjMuODA3IDI1Ny4wMzhDMTA0LjgwNiAyNzQuMjQ2IDg1LjgxMzggMjg4LjU0NyA2OS40NTUxIDI5Ni4yNjNDNjEuMjgxNiAzMDAuMTE4IDUzLjU2NDkgMzAyLjQyNyA0Ni43MTYzIDMwMi40OTdDMzkuNzY2MSAzMDIuNTY4IDMzLjY2MzggMzAwLjMyIDI5LjEwNDQgMjk1LjA5OUMyNC43MDAxIDI5MC4wNTYgMjEuNTc4MyAyODIuMDMgMTkuMzkwNiAyNzIuMTU3QzE3LjE4NDcgMjYyLjIwMiAxNS44NTU3IDI1MC4wMTggMTUuMjc0MSAyMzYuMzM4QzE0LjExMDYgMjA4Ljk2OCAxNS45Mjc5IDE3NS4zMTkgMTkuODkxMiAxNDAuOTNDMjMuODU1NiAxMDYuNTMzIDI5Ljk3NjQgNzEuMzE2MyAzNy40NDg4IDQwLjgwMTZDNDQuOTAyNyAxMC4zNjI0IDUzLjc2MDkgLTE1LjY1MjYgNjMuMjk2MiAtMzEuNDczMUM3Mi45MzQyIC00Ny40NjQxIDg1LjIwNSAtNTYuMjc2MSA5OC44MDA4IC01OS42ODA1QzExMi4zMTEgLTYzLjA2MzYgMTI2LjgwOCAtNjEuMDI3NyAxNDAuODU3IC01NS45NjI1Wk0xMDAuMTM3IC01NC4zNDUzQzg4LjExODUgLTUxLjMzNTggNzYuOTg3OSAtNDMuNTM1MSA2OC4wMDY3IC0yOC42MzM5TDY1LjY1MTUgLTMwLjA1MzVMNjguMDA2NyAtMjguNjMzOUM1OC45MjI4IC0xMy41NjI0IDUwLjIxOTkgMTEuNzcyNSA0Mi43OTA5IDQyLjEwOThDMzUuMzgwNSA3Mi4zNzE4IDI5LjI5NjggMTA3LjM1OSAyNS4zNTUgMTQxLjU2QzIxLjQxMjIgMTc1Ljc3IDE5LjYyMTggMjA5LjExNSAyMC43NjkxIDIzNi4xMDRDMjEuMzQzIDI0OS42MDMgMjIuNjQ5IDI2MS40MzkgMjQuNzYwMyAyNzAuOTY3QzI2Ljg4OTggMjgwLjU3NyAyOS43NjczIDI4Ny40OTYgMzMuMjQ3MSAyOTEuNDgxTDMxLjE3NTcgMjkzLjI5TDMzLjI0NzEgMjkxLjQ4MUMzNi41NzE2IDI5NS4yODggNDEuMDI2MiAyOTcuMDU1IDQ2LjY2MDEgMjk2Ljk5N0M1Mi4zOTU2IDI5Ni45MzggNTkuMjkwMSAyOTQuOTc2IDY3LjEwODggMjkxLjI4OEM4Mi43MzQ3IDI4My45MTggMTAxLjI1MiAyNzAuMDQ1IDEyMC4xMTUgMjUyLjk2MUMxNTcuODE4IDIxOC44MTcgMTk2LjIxMSAxNzIuNDkxIDIxNC42NjkgMTQxLjg2N0MyMzMuMDQ1IDExMS4zNzkgMjM4Ljk0NCA4NC4zNTY0IDIzNi41MjcgNjAuNjU4MUMyMzQuMTA5IDM2Ljk0NzUgMjIzLjMzNiAxNi4yNjgxIDIwNy44NDkgLTEuNDY2MDJDMTkyLjI3NiAtMTkuMjk5NSAxNjUuODg2IC00MS4wOTI4IDEzOC45OTIgLTUwLjc4ODVDMTI1LjU3MSAtNTUuNjI3IDExMi4yNCAtNTcuMzc2IDEwMC4xMzcgLTU0LjM0NTNaIiBmaWxsPSJ1cmwoI3BhaW50NV9saW5lYXJfMzExNl85NTgpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTM4LjQ3MiAtMTkuNjg3NUMxNjEuMDI1IC0xMS41NTY3IDE4Mi43OTkgNi41MDMzOCAxOTUuNjA4IDIxLjE3MTJDMjA4LjUwNCAzNS45Mzg0IDIxNy42ODQgNTMuNDA4OSAyMTkuNzQ2IDczLjYyNDJDMjIxLjgwOSA5My44NTE4IDIxNi43MTMgMTE2LjUzMSAyMDEuNTc0IDE0MS42NDlDMTg2LjUxNyAxNjYuNjMxIDE1NS40NyAyMDQuMDU2IDEyNS4wMTUgMjMxLjYzN0MxMDkuOCAyNDUuNDE2IDk0LjU1ODggMjU2Ljg5OSA4MS4zOTg2IDI2My4xMDZDNzQuODI0MyAyNjYuMjA3IDY4LjU2ODcgMjY4LjA4OCA2Mi45Nzg1IDI2OC4xNDVDNTcuMjg2NyAyNjguMjAzIDUyLjI0MDEgMjY2LjM1NyA0OC40NjkgMjYyLjAzOUM0NC44NTMyIDI1Ny44OTggNDIuMzMxMyAyNTEuMzY3IDQwLjU3NTMgMjQzLjQ0M0MzOC44MDEyIDIzNS40MzcgMzcuNzM1NiAyMjUuNjU1IDM3LjI2OTYgMjE0LjY5MkMzNi4zMzcyIDE5Mi43NTkgMzcuNzkzNyAxNjUuODA5IDQwLjk2NjQgMTM4LjI4MUM0NC4xNDAyIDExMC43NDMgNDkuMDQwNiA4Mi41NDcyIDU1LjAyNDcgNTguMTEwM0M2MC45OTAzIDMzLjc0ODggNjguMDkyNCAxMi44Njg4IDc1Ljc2NTggMC4xMzc1MzNDODMuNTQyIC0xMi43NjQyIDkzLjQ3MjYgLTE5LjkxNSAxMDQuNTA3IC0yMi42NzhDMTE1LjQ1NiAtMjUuNDE5NyAxMjcuMTcgLTIzLjc2MjIgMTM4LjQ3MiAtMTkuNjg3NVpNMTA1Ljg0MyAtMTcuMzQyOEM5Ni4zODYxIC0xNC45NzQ3IDg3LjU5NTYgLTguODM1MjUgODAuNDc2NCAyLjk3NjY3TDc4LjEyMTEgMS41NTcxTDgwLjQ3NjQgMi45NzY2OEM3My4yNTQzIDE0Ljk1OTEgNjYuMzA3NSAzNS4xNTg5IDYwLjM2NjggNTkuNDE4NUM1NC40NDQ2IDgzLjYwMjcgNDkuNTgxNCAxMTEuNTY5IDQ2LjQzMDMgMTM4LjkxQzQzLjI3ODEgMTY2LjI2MSA0MS44NDg0IDE5Mi45MDUgNDIuNzY0NiAyMTQuNDU5QzQzLjIyMjkgMjI1LjIzOSA0NC4yNjU1IDIzNC42NzQgNDUuOTQ1MSAyNDIuMjUzQzQ3LjY0MjggMjQ5LjkxNSA0OS45MjA0IDI1NS4zMzkgNTIuNjExNyAyNTguNDIxQzU1LjE0NzkgMjYxLjMyNSA1OC41NDY5IDI2Mi42OSA2Mi45MjI0IDI2Mi42NDZDNjcuMzk5NSAyNjIuNiA3Mi44MzI5IDI2MS4wNjUgNzkuMDUyNCAyNTguMTMxQzkxLjQ3OTggMjUyLjI3IDEwNi4yNDYgMjQxLjIxNCAxMjEuMzIzIDIyNy41NkMxNTEuNDUzIDIwMC4yNzUgMTgyLjEzIDE2My4yNTUgMTk2Ljg2NCAxMzguODFDMjExLjUxNiAxMTQuNSAyMTYuMTkzIDkyLjk5OTggMjE0LjI3NCA3NC4xODIyQzIxMi4zNTQgNTUuMzUyMyAyMDMuNzk4IDM4LjkxMTggMTkxLjQ2NSAyNC43ODg5QzE3OS4wNDUgMTAuNTY2NyAxNTguMDA3IC02Ljc5ODQgMTM2LjYwNyAtMTQuNTEzNEMxMjUuOTMzIC0xOC4zNjE2IDExNS4zODUgLTE5LjczMjEgMTA1Ljg0MyAtMTcuMzQyOFoiIGZpbGw9InVybCgjcGFpbnQ2X2xpbmVhcl8zMTE2Xzk1OCkiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMzYuMDg3IDE2LjU4NzZDMTUzLjE0NiAyMi43Mzc3IDE2OS41NjggMzYuMzY5NSAxNzkuMjI0IDQ3LjQyNjFDMTg4Ljk2NiA1OC41ODIgMTk1LjkzIDcxLjgxMzYgMTk3LjQ5NCA4Ny4xNDgzQzE5OS4wNTkgMTAyLjQ5NSAxOTUuMTg1IDExOS42NTIgMTgzLjc3IDEzOC41OTJDMTcyLjQzNiAxNTcuMzk1IDE0OS4xMDUgMTg1LjUxNSAxMjYuMjIzIDIwNi4yMzhDMTE0Ljc5NCAyMTYuNTg3IDEwMy4zMDQgMjI1LjI1MyA5My4zNDIzIDIyOS45NTJDODguMzY3MiAyMzIuMjk4IDgzLjU3MjggMjMzLjc1MyA3OS4yNDEgMjMzLjc5N0M3NC44MDc3IDIzMy44NDIgNzAuODE2NyAyMzIuMzk4IDY3LjgzNDEgMjI4Ljk4Mkw2OS45MDU0IDIyNy4xNzNMNjcuODM0MSAyMjguOTgyQzY1LjAwNjYgMjI1Ljc0NCA2My4wODQ3IDIyMC43MDggNjEuNzYwNCAyMTQuNzMyQzYwLjQxNzkgMjA4LjY3MyA1OS42MTU5IDIwMS4yOTMgNTkuMjY1NCAxOTMuMDQ5QzU4LjU2NDEgMTc2LjU1MSA1OS42NTk4IDE1Ni4zIDYyLjA0MTkgMTM1LjYzMkM2NC40MjUxIDExNC45NTQgNjguMTA1IDkzLjc3ODQgNzIuNjAwOCA3NS40MTkxQzc3LjA3ODIgNTcuMTM1MiA4Mi40MjQyIDQxLjM5MDIgODguMjM1NyAzMS43NDgxQzk0LjE0OTkgMjEuOTM1NiAxMDEuNzQgMTYuNDQ2MiAxMTAuMjEzIDE0LjMyNDVDMTE4LjYwMSAxMi4yMjQyIDEyNy41MzIgMTMuNTAzMiAxMzYuMDg3IDE2LjU4NzZaTTExMS41NDkgMTkuNjU5OEMxMDQuNjU0IDIxLjM4NjQgOTguMjAzNSAyNS44NjQ2IDkyLjk0NjIgMzQuNTg3M0w5MC41OTA5IDMzLjE2NzdMOTIuOTQ2MiAzNC41ODczQzg3LjU4NjEgNDMuNDgwNSA4Mi4zOTU0IDU4LjU0NTMgNzcuOTQzIDc2LjcyNzNDNzMuNTA5IDk0LjgzMzkgNjkuODY2MyAxMTUuNzggNjcuNTA1NyAxMzYuMjYxQzY1LjE0NDEgMTU2Ljc1MiA2NC4wNzUyIDE3Ni42OTggNjQuNzYwNCAxOTIuODE1QzY1LjEwMzIgMjAwLjg3OCA2NS44ODIyIDIwNy45MSA2Ny4xMzAxIDIxMy41NDJDNjguMzk2MSAyMTkuMjU1IDcwLjA3MzggMjIzLjE4NSA3MS45NzY4IDIyNS4zNjRMNjkuOTIyNCAyMjcuMTU4TDcxLjk3NjggMjI1LjM2NEM3My43MjQ1IDIyNy4zNjYgNzYuMDY3OCAyMjguMzI5IDc5LjE4NDkgMjI4LjI5OEM4Mi40MDM2IDIyOC4yNjUgODYuMzc1OCAyMjcuMTU3IDkwLjk5NjEgMjI0Ljk3N0MxMDAuMjI1IDIyMC42MjQgMTExLjI0IDIxMi4zODYgMTIyLjUzMSAyMDIuMTYxQzE0NS4wODcgMTgxLjczMyAxNjguMDQ5IDE1NC4wMTkgMTc5LjA1OSAxMzUuNzUyQzE4OS45ODcgMTE3LjYyMSAxOTMuNDQzIDEwMS42NDMgMTkyLjAyMiA4Ny43MDYzQzE5MC41OTkgNzMuNzU3IDE4NC4yNiA2MS41NTU0IDE3NS4wODEgNTEuMDQzOEMxNjUuODE1IDQwLjQzMjkgMTUwLjEyOCAyNy40OTU5IDEzNC4yMjIgMjEuNzYxN0MxMjYuMjk1IDE4LjkwMzkgMTE4LjUzIDE3LjkxMTggMTExLjU0OSAxOS42NTk4WiIgZmlsbD0idXJsKCNwYWludDdfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzMy43MDIgNTIuODYyOUMxNDUuMjY3IDU3LjAzMjMgMTU2LjMzOCA2Ni4yMzYgMTYyLjg0IDczLjY4MTRDMTY5LjQyOCA4MS4yMjYgMTc0LjE3NSA5MC4yMTg4IDE3NS4yNDEgMTAwLjY3M0MxNzYuMzA4IDExMS4xMzkgMTczLjY1NiAxMjIuNzc0IDE2NS45NjUgMTM1LjUzNEMxNTguMzU1IDE0OC4xNiAxNDIuNzM5IDE2Ni45NzQgMTI3LjQzIDE4MC44MzhDMTE5Ljc4OCAxODcuNzU5IDExMi4wNDkgMTkzLjYwNyAxMDUuMjg2IDE5Ni43OTdDMTAxLjkxIDE5OC4zODkgOTguNTc2NiAxOTkuNDE3IDk1LjUwMzIgMTk5LjQ0OEM5Mi4zMjgzIDE5OS40ODEgODkuMzkzIDE5OC40MzcgODcuMTk4OCAxOTUuOTI1Qzg1LjE1OTcgMTkzLjU5IDgzLjgzNzcgMTkwLjA0OCA4Mi45NDUxIDE4Ni4wMkM4Mi4wMzQ0IDE4MS45MSA4MS40OTU5IDE3Ni45MzIgODEuMjYwOSAxNzEuNDA1QzgwLjc5MDcgMTYwLjM0MyA4MS41MjU2IDE0Ni43OTIgODMuMTE3MSAxMzIuOTgzQzg0LjcwOTYgMTE5LjE2NSA4Ny4xNjkxIDEwNS4wMSA5MC4xNzY2IDkyLjcyODJDOTMuMTY1NyA4MC41MjIgOTYuNzU1NiA2OS45MTE5IDEwMC43MDUgNjMuMzU5MUMxMDQuNzU3IDU2LjYzNTggMTEwLjAwOCA1Mi44MDc2IDExNS45MTkgNTEuMzI3M0MxMjEuNzQ2IDQ5Ljg2ODQgMTI3Ljg5NCA1MC43Njg5IDEzMy43MDIgNTIuODYyOVpNMTE3LjI1NSA1Ni42NjI2QzExMi45MjEgNTcuNzQ3OCAxMDguODExIDYwLjU2NDggMTA1LjQxNiA2Ni4xOTgzTDEwMy4wNiA2NC43Nzg3TDEwNS40MTYgNjYuMTk4M0MxMDEuOTE3IDcyLjAwMjIgOTguNDgyOSA4MS45MzIxIDk1LjUxODggOTQuMDM2NEM5Mi41NzMyIDEwNi4wNjUgOTAuMTUwOCAxMTkuOTkxIDg4LjU4MDkgMTMzLjYxM0M4Ny4wMSAxNDcuMjQ0IDg2LjMwMTkgMTYwLjQ5IDg2Ljc1NiAxNzEuMTcxQzg2Ljk4MzIgMTc2LjUxNiA4Ny40OTg3IDE4MS4xNDcgODguMzE0OSAxODQuODNDODkuMTQ5MiAxODguNTk1IDkwLjIyNjkgMTkxLjAzMSA5MS4zNDE1IDE5Mi4zMDdDOTIuMzAwOCAxOTMuNDA1IDkzLjU4ODQgMTkzLjk2OCA5NS40NDcxIDE5My45NDlDOTcuNDA3MyAxOTMuOTI5IDk5LjkxODUgMTkzLjI0OCAxMDIuOTM5IDE5MS44MjNDMTA4Ljk3IDE4OC45NzggMTE2LjIzNCAxODMuNTU3IDEyMy43MzggMTc2Ljc2MUMxMzguNzIyIDE2My4xOTIgMTUzLjk2OCAxNDQuNzg0IDE2MS4yNTQgMTMyLjY5NUwxNjMuNjA5IDEzNC4xMTVMMTYxLjI1NCAxMzIuNjk1QzE2OC40NTggMTIwLjc0MiAxNzAuNjkzIDExMC4yODcgMTY5Ljc2OSAxMDEuMjMxQzE2OC44NDQgOTIuMTYyMiAxNjQuNzIzIDg0LjE5OTQgMTU4LjY5NyA3Ny4yOTkxTDE2MC43NjggNzUuNDkwMkwxNTguNjk3IDc3LjI5OTFDMTUyLjU4NCA3MC4yOTk0IDE0Mi4yNDkgNjEuNzkwNSAxMzEuODM3IDU4LjAzNjlDMTI2LjY1NyA1Ni4xNjk1IDEyMS42NzUgNTUuNTU2IDExNy4yNTUgNTYuNjYyNloiIGZpbGw9InVybCgjcGFpbnQ4X2xpbmVhcl8zMTE2Xzk1OCkiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMzEuMzE4IDg5LjEzNzlDMTM3LjM4OCA5MS4zMjY1IDE0My4xMDcgOTYuMTAyMSAxNDYuNDU2IDk5LjkzNjJDMTQ5Ljg5MSAxMDMuODcgMTUyLjQyIDEwOC42MjMgMTUyLjk4OCAxMTQuMTk3QzE1My41NTggMTE5Ljc4MiAxNTIuMTI3IDEyNS44OTUgMTQ4LjE2IDEzMi40NzdMMTQ1LjgwNSAxMzEuMDU3TDE0OC4xNiAxMzIuNDc3QzE0NC4yNzUgMTM4LjkyNCAxMzYuMzc0IDE0OC40MzIgMTI4LjYzOCAxNTUuNDM4QzEyNC43ODMgMTU4LjkzIDEyMC43OTQgMTYxLjk2MSAxMTcuMjMgMTYzLjY0MkMxMTUuNDUzIDE2NC40OCAxMTMuNTgxIDE2NS4wODEgMTExLjc2NiAxNjUuMDk5QzEwOS44NDkgMTY1LjExOSAxMDcuOTcgMTY0LjQ3NyAxMDYuNTY0IDE2Mi44NjdDMTA1LjMxMyAxNjEuNDM1IDEwNC41OTEgMTU5LjM4NyAxMDQuMTMgMTU3LjMwN0MxMDMuNjUxIDE1NS4xNDYgMTAzLjM3NiAxNTIuNTcgMTAzLjI1NyAxNDkuNzYxQzEwMy4wMTggMTQ0LjEzNSAxMDMuMzkyIDEzNy4yODMgMTA0LjE5MyAxMzAuMzM0QzEwNC45OTUgMTIzLjM3NiAxMDYuMjM0IDExNi4yNDEgMTA3Ljc1MyAxMTAuMDM3QzEwOS4yNTQgMTAzLjkwOCAxMTEuMDg3IDk4LjQzMzMgMTEzLjE3NSA5NC45Njk3QzExNS4zNjUgOTEuMzM1NiAxMTguMjc2IDg5LjE2ODcgMTIxLjYyNiA4OC4zMjk4QzEyNC44OTEgODcuNTEyMyAxMjguMjU2IDg4LjAzNDIgMTMxLjMxOCA4OS4xMzc5Wk0xMjIuOTYyIDkzLjY2NTFDMTIxLjE4OSA5NC4xMDkgMTE5LjQxOSA5NS4yNjQ2IDExNy44ODUgOTcuODA4OUMxMTYuMjQ5IDEwMC41MjQgMTE0LjU3MSAxMDUuMzE5IDExMy4wOTUgMTExLjM0NUMxMTEuNjM4IDExNy4yOTYgMTEwLjQzNiAxMjQuMjAyIDEwOS42NTcgMTMwLjk2NEMxMDguODc2IDEzNy43MzUgMTA4LjUyOSAxNDQuMjgxIDEwOC43NTIgMTQ5LjUyN0MxMDguODY0IDE1Mi4xNTQgMTA5LjExNiAxNTQuMzgyIDEwOS41IDE1Ni4xMTdDMTA5LjkwMyAxNTcuOTM0IDExMC4zOCAxNTguODc1IDExMC43MDcgMTU5LjI0OUwxMTAuNzA3IDE1OS4yNDlDMTEwLjg3OCAxNTkuNDQ1IDExMS4xMDkgMTU5LjYwNSAxMTEuNzEgMTU5LjU5OUMxMTIuNDExIDE1OS41OTIgMTEzLjQ2MSAxNTkuMzM4IDExNC44ODMgMTU4LjY2OEMxMTcuNzE1IDE1Ny4zMzIgMTIxLjIyOSAxNTQuNzI4IDEyNC45NDYgMTUxLjM2MUMxMzIuMzU3IDE0NC42NTEgMTM5Ljg4OCAxMzUuNTQ4IDE0My40NSAxMjkuNjM4QzE0Ni45MyAxMjMuODYzIDE0Ny45NDMgMTE4LjkzIDE0Ny41MTcgMTE0Ljc1NUMxNDcuMDkgMTEwLjU2NyAxNDUuMTg1IDEwNi44NDMgMTQyLjMxMyAxMDMuNTU0QzEzOS4zNTQgMTAwLjE2NSAxMzQuMzcgOTYuMDg0OCAxMjkuNDUyIDk0LjMxMkMxMjcuMDIgOTMuNDM0OSAxMjQuODIgOTMuMTk5OSAxMjIuOTYyIDkzLjY2NTFaIiBmaWxsPSJ1cmwoI3BhaW50OV9saW5lYXJfMzExNl85NTgpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjMwLjg3NCAxMTEuNzY0QzIzNi42MTMgMTA1LjUyOCAyMzYuMTQzIDk1Ljg4IDIyOS44MjggOTAuMjE0M0MyMjMuNTEzIDg0LjU0ODggMjEzLjc0MSA4NS4wMTEgMjA4LjAwNSA5MS4yNDczTDE2Ni44NTQgMTM1Ljk3MUwxNTAuMjE3IDExOC43MjJDMTQ0LjMzMyAxMTIuNjIxIDEzNC41NTMgMTEyLjM4NSAxMjguMzc0IDExOC4xOTZDMTIyLjE5NSAxMjQuMDA3IDEyMS45NTcgMTMzLjY2MyAxMjcuODQxIDEzOS43NjRMMTU1LjkzMyAxNjguODg5QzE1OC44OTIgMTcxLjk1NyAxNjMuMDExIDE3My42NzIgMTY3LjMwMyAxNzMuNjIyQzE3MS41OTMgMTczLjU3MiAxNzUuNjcxIDE3MS43NjMgMTc4LjU1NSAxNjguNjI2TDIzMC44NzQgMTExLjc2NFpNMTE0LjQwMyAxNTAuMDU3TDk2LjQ3OCAxMzIuMTk4TDExNC40MDMgMTE0LjM0QzExOC4yNzggMTEwLjUxMyAxMjAuMjE2IDEwNy4yNzEgMTIwLjIxNiAxMDQuNjEzQzEyMC4yMTYgMTAxLjg0OSAxMTguMjc4IDk4LjU1MzggMTE0LjQwMyA5NC43MjdDMTEwLjUyNyA5MC45MDAzIDEwNy4yNDQgODguOTg2OCAxMDQuNTUyIDg4Ljk4NjhDMTAxLjg2MSA4OC45ODY4IDk4LjU3NzMgOTAuOTAwMyA5NC43MDE4IDk0LjcyN0w3Ni45Mzg4IDExMi41ODZMNTkuMDE0MyA5NC43MjdDNTUuMTM4OCA5MC45MDAzIDUxLjg1NTIgODguOTg2OCA0OS4xNjM3IDg4Ljk4NjhDNDYuNTggODguOTg2OCA0My4yOTY1IDkwLjkwMDMgMzkuMzEzMyA5NC43MjdDMzUuNDM3OCA5OC41NTM4IDMzLjUgMTAxLjg0OSAzMy41IDEwNC42MTNDMzMuNSAxMDcuMjcxIDM1LjQzNzggMTEwLjUxMyAzOS4zMTMzIDExNC4zNEw1Ny4yMzggMTMyLjE5OEwzOS4zMTMzIDE1MC4wNTdDMzUuNDM3OCAxNTMuODg0IDMzLjUgMTU3LjE3OSAzMy41IDE1OS45NDNDMzMuNSAxNjIuNiAzNS40Mzc4IDE2NS44NDMgMzkuMzEzMyAxNjkuNjY5QzQzLjI5NjUgMTczLjM5IDQ2LjU4IDE3NS4yNSA0OS4xNjM3IDE3NS4yNUM1MS44NTUyIDE3NS4yNSA1NS4xMzg4IDE3My4zMzcgNTkuMDE0MyAxNjkuNTFMNzYuOTM4OCAxNTEuODExTDk0LjcwMTggMTY5LjUxQzk4LjU3NzMgMTczLjMzNyAxMDEuODYxIDE3NS4yNSAxMDQuNTUyIDE3NS4yNUMxMDcuMjQ0IDE3NS4yNSAxMTAuNTI3IDE3My4zOSAxMTQuNDAzIDE2OS42NjlDMTE4LjI3OCAxNjUuODQzIDEyMC4yMTYgMTYyLjYgMTIwLjIxNiAxNTkuOTQzQzEyMC4yMTYgMTU3LjE3OSAxMTguMjc4IDE1My44ODQgMTE0LjQwMyAxNTAuMDU3WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTg1LjE2NyIgeTE9Ii0yMzIuOTM4IiB4Mj0iNzAuODMyOSIgeTI9IjQ4OC45MzciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MV9saW5lYXJfMzExNl85NTgiIHgxPSIxNzkuNDUiIHkxPSItMTk2Ljg0NCIgeDI9Ijc2LjU0OTgiIHkyPSI0NTIuODQ1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTczLjczMyIgeTE9Ii0xNjAuNzUiIHgyPSI4Mi4yNjYyIiB5Mj0iNDE2Ljc1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDNfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTY4LjAxNyIgeTE9Ii0xMjQuNjU3IiB4Mj0iODcuOTgzMSIgeTI9IjM4MC42NTgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NF9saW5lYXJfMzExNl85NTgiIHgxPSIxNjIuMyIgeTE9Ii04OC41NjI4IiB4Mj0iOTMuNjk5NyIgeTI9IjM0NC41NjIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NV9saW5lYXJfMzExNl85NTgiIHgxPSIxNTYuNTgzIiB5MT0iLTUyLjQ2OSIgeDI9Ijk5LjQxNjUiIHkyPSIzMDguNDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Nl9saW5lYXJfMzExNl85NTgiIHgxPSIxNTAuODY3IiB5MT0iLTE2LjM3NTMiIHgyPSIxMDUuMTMzIiB5Mj0iMjcyLjM3NSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuNDUiIHN0b3AtY29sb3I9IiMyMjQ3RkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMEQxQzY1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ3X2xpbmVhcl8zMTE2Xzk1OCIgeDE9IjE0NS4xNSIgeTE9IjE5LjcxODUiIHgyPSIxMTAuODUiIHkyPSIyMzYuMjgxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDhfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTM5LjQzMyIgeTE9IjU1LjgxMjUiIHgyPSIxMTYuNTY2IiB5Mj0iMjAwLjE4OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuNDUiIHN0b3AtY29sb3I9IiMyMjQ3RkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMEQxQzY1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ5X2xpbmVhcl8zMTE2Xzk1OCIgeDE9IjEzMy43MTciIHkxPSI5MS45MDYzIiB4Mj0iMTIyLjI4MyIgeTI9IjE2NC4wOTQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzMxMTZfOTU4Ij4KPHJlY3Qgd2lkdGg9IjI1NiIgaGVpZ2h0PSIyNTYiIHJ4PSI2MCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K", this.url = "https://xaman.app", this.client = null, this.currentAccount = null, this.options = e;
    }
    /**
   * Xaman is always available (uses OAuth flow, no extension needed)
   */ async isAvailable() {
        return !0;
    }
    async checkXamanState(e) {
        const t = (e == null ? void 0 : e.apiKey) || this.options.apiKey;
        let n = e == null ? void 0 : e.network;
        if (!t) throw ge.connectionFailed(this.name, new Error("API key is required for Xaman. Please provide it in connect options or adapter constructor."));
        this.client = new gl(t);
        const s = await this.client.user.account;
        if (!s) return this.client.logout(), null;
        let i;
        if (n) i = this.resolveNetwork(n);
        else {
            const o = await this.client.user.networkType;
            if (!o) throw ge.connectionFailed(this.name, new Error("Unable to determine network from Xaman. Make sure the API key and network are correct."));
            i = this.parseNetwork(o);
        }
        return this.currentAccount = {
            address: s,
            publicKey: void 0,
            // Xaman doesn't expose public key
            network: i
        }, this.currentAccount;
    }
    /**
   * Connect to Xaman wallet
   */ async connect(e) {
        var i;
        const t = (e == null ? void 0 : e.apiKey) || this.options.apiKey;
        if (!t) throw ge.connectionFailed(this.name, new Error("API key is required for Xaman. Please provide it in connect options or adapter constructor."));
        const n = (e == null ? void 0 : e.onQRCode) || this.options.onQRCode, s = (e == null ? void 0 : e.onDeepLink) || this.options.onDeepLink;
        n && (this.options.onQRCode = n), s && (this.options.onDeepLink = s);
        try {
            this.client = new gl(t), wn.debug("Starting authorization flow");
            const o = await this.client.authorize();
            if (wn.debug("Authorization result:", {
                hasResult: !!o,
                isError: o instanceof Error,
                hasMe: o && !(o instanceof Error) ? !!o.me : !1
            }), !o || o instanceof Error) throw o || new Error("Authorization failed");
            wn.debug("Authorization successful", {
                account: (i = o.me) == null ? void 0 : i.account
            });
            const a = o.me.account, u = this.parseNetwork(o.me.networkEndpoint || "");
            return this.currentAccount = {
                address: a,
                publicKey: void 0,
                // Xaman doesn't expose public key in authorize response
                network: u
            }, this.currentAccount;
        } catch (o) {
            throw wn.error("Authorization failed:", o), ge.connectionFailed(this.name, o);
        }
    }
    /**
   * Disconnect from Xaman
   */ async disconnect() {
        if (this.client) try {
            await this.client.logout(), this.cleanup();
        } catch  {
            this.cleanup();
        }
    }
    /**
   * Get current account
   */ async getAccount() {
        return this.currentAccount;
    }
    /**
   * Get current network
   */ async getNetwork() {
        if (!this.currentAccount) throw ge.notConnected();
        return this.currentAccount.network;
    }
    /**
   * Sign and optionally submit a transaction
   * Note: Xaman only supports signing via popup flow. The submit parameter is ignored.
   * Users must submit the signed transaction separately or use Xaman's auto-submit feature.
   */ async signAndSubmit(e, t) {
        var n;
        if (!this.client || !this.currentAccount) throw ge.notConnected();
        try {
            const s = await ((n = this.client.payload) == null ? void 0 : n.createAndSubscribe(e));
            if (!s) throw new Error("Failed to create payload");
            this.openSignWindow(s.created.next.always);
            const i = await this.waitForSignature(s.websocket.url);
            if (!i.signed) throw ge.signRejected();
            return {
                hash: i.txid || "",
                tx_blob: i.tx_blob,
                signature: i.signature
            };
        } catch (s) {
            throw s instanceof Error && s.message.includes("rejected") ? ge.signRejected() : ge.signFailed(s);
        }
    }
    /**
   * Sign a message (for authentication/verification)
   */ async signMessage(e) {
        var t;
        if (!this.client || !this.currentAccount) throw ge.notConnected();
        try {
            const n = typeof e == "string" ? e : new TextDecoder().decode(e), s = await ((t = this.client.payload) == null ? void 0 : t.create({
                TransactionType: "SignIn"
            }));
            if (!s) throw new Error("Failed to create sign message payload");
            return this.openSignWindow(s.next.always), {
                message: n,
                signature: "",
                // Would need to extract from Xaman response
                publicKey: this.currentAccount.publicKey || ""
            };
        } catch (n) {
            throw ge.signFailed(n);
        }
    }
    /**
   * Parse network from endpoint URL
   */ parseNetwork(e) {
        const t = e.toLowerCase();
        return t.includes("testnet") || t.includes("altnet") ? {
            id: "testnet",
            name: "Testnet",
            wss: e,
            walletConnectId: "xrpl:1"
        } : t.includes("devnet") ? {
            id: "devnet",
            name: "Devnet",
            wss: e,
            walletConnectId: "xrpl:2"
        } : {
            id: "mainnet",
            name: "Mainnet",
            wss: e || "wss://xrplcluster.com",
            walletConnectId: "xrpl:0"
        };
    }
    /**
   * Open popup window for signing or trigger QR code callback
   */ openSignWindow(e) {
        if (wn.debug("openSignWindow called with URL:", e.substring(0, 50) + "..."), wn.debug("onQRCode callback exists:", !!this.options.onQRCode), this.options.onQRCode) {
            wn.debug("Calling onQRCode callback"), this.options.onQRCode(e);
            return;
        }
        wn.debug("Opening popup window");
        const t = 500, n = 600, s = window.screen.width / 2 - t / 2, i = window.screen.height / 2 - n / 2;
        window.open(e, "Xaman Sign", `width=${t},height=${n},left=${s},top=${i},resizable=yes,scrollbars=yes`);
    }
    /**
   * Get deep link URI for mobile (Xaman app)
   */ getDeepLinkURI(e) {
        return this.options.onDeepLink ? this.options.onDeepLink(e) : `xumm://xumm.app/sign/${e.split("/").pop()}`;
    }
    /**
   * Wait for signature via WebSocket
   */ waitForSignature(e) {
        return new Promise((t, n)=>{
            const s = new WebSocket(e), i = setTimeout(()=>{
                s.close(), n(new Error("Signing timeout - user did not respond"));
            }, 5 * 60 * 1e3);
            s.onmessage = (o)=>{
                try {
                    const a = JSON.parse(o.data);
                    a.signed === !0 ? (clearTimeout(i), s.close(), t({
                        signed: !0,
                        txid: a.txid,
                        tx_blob: a.tx_blob,
                        signature: a.signature,
                        account: a.account
                    })) : a.signed === !1 && (clearTimeout(i), s.close(), n(new Error("Transaction signing was rejected by user")));
                } catch (a) {
                    clearTimeout(i), s.close(), n(a);
                }
            }, s.onerror = (o)=>{
                clearTimeout(i), n(new Error("WebSocket error: " + o));
            }, s.onclose = ()=>{
                clearTimeout(i);
            };
        });
    }
    /**
   * Cleanup adapter state
   */ cleanup() {
        this.client = null, this.currentAccount = null;
    }
    /**
   * Resolve network configuration
   */ resolveNetwork(e) {
        if (!e) return Hr.mainnet;
        if (typeof e == "string") {
            const t = Hr[e];
            if (!t) throw ge.unknown(`Unknown network: ${e}`);
            return t;
        }
        return e;
    }
}
var ty = {
    exports: {}
};
(function(r, e) {
    (function(t, n) {
        r.exports = n();
    })($, ()=>(()=>{
            var t = {
                7531: (s)=>{
                    var i = typeof Reflect == "object" ? Reflect : null, o = i && typeof i.apply == "function" ? i.apply : function(v, N, O) {
                        return Function.prototype.apply.call(v, N, O);
                    }, a = i && typeof i.ownKeys == "function" ? i.ownKeys : Object.getOwnPropertySymbols ? function(v) {
                        return Object.getOwnPropertyNames(v).concat(Object.getOwnPropertySymbols(v));
                    } : function(v) {
                        return Object.getOwnPropertyNames(v);
                    }, u = Number.isNaN || function(v) {
                        return v != v;
                    };
                    function c() {
                        c.init.call(this);
                    }
                    s.exports = c, s.exports.once = function(v, N) {
                        return new Promise(function(O, z) {
                            function P(H) {
                                v.removeListener(N, U), z(H);
                            }
                            function U() {
                                typeof v.removeListener == "function" && v.removeListener("error", P), O([].slice.call(arguments));
                            }
                            var R, G, F;
                            _(v, N, U, {
                                once: !0
                            }), N !== "error" && (G = P, F = {
                                once: !0
                            }, typeof (R = v).on == "function") && _(R, "error", G, F);
                        });
                    }, (c.EventEmitter = c).prototype._events = void 0, c.prototype._eventsCount = 0, c.prototype._maxListeners = void 0;
                    var l = 10;
                    function d(v) {
                        if (typeof v != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof v);
                    }
                    function h(v) {
                        return v._maxListeners === void 0 ? c.defaultMaxListeners : v._maxListeners;
                    }
                    function f(v, N, O, z) {
                        var P, U;
                        return d(O), (P = v._events) === void 0 ? (P = v._events = /* @__PURE__ */ Object.create(null), v._eventsCount = 0) : (P.newListener !== void 0 && (v.emit("newListener", N, O.listener || O), P = v._events), U = P[N]), U === void 0 ? (U = P[N] = O, ++v._eventsCount) : (typeof U == "function" ? U = P[N] = z ? [
                            O,
                            U
                        ] : [
                            U,
                            O
                        ] : z ? U.unshift(O) : U.push(O), 0 < (P = h(v)) && U.length > P && !U.warned && (U.warned = !0, (z = new Error("Possible EventEmitter memory leak detected. " + U.length + " " + String(N) + " listeners added. Use emitter.setMaxListeners() to increase limit")).name = "MaxListenersExceededWarning", z.emitter = v, z.type = N, z.count = U.length, O = z, console) && console.warn && console.warn(O)), v;
                    }
                    function g(v, N, O) {
                        return v = {
                            fired: !1,
                            wrapFn: void 0,
                            target: v,
                            type: N,
                            listener: O
                        }, N = (function() {
                            if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
                        }).bind(v), N.listener = O, v.wrapFn = N;
                    }
                    function p(v, N, O) {
                        if (v = v._events, v === void 0) return [];
                        if (v = v[N], v === void 0) return [];
                        if (typeof v == "function") return O ? [
                            v.listener || v
                        ] : [
                            v
                        ];
                        if (O) {
                            for(var z = v, P = new Array(z.length), U = 0; U < P.length; ++U)P[U] = z[U].listener || z[U];
                            return P;
                        }
                        return x(v, v.length);
                    }
                    function m(v) {
                        var N = this._events;
                        if (N !== void 0) {
                            if (N = N[v], typeof N == "function") return 1;
                            if (N !== void 0) return N.length;
                        }
                        return 0;
                    }
                    function x(v, N) {
                        for(var O = new Array(N), z = 0; z < N; ++z)O[z] = v[z];
                        return O;
                    }
                    function _(v, N, O, z) {
                        if (typeof v.on == "function") z.once ? v.once(N, O) : v.on(N, O);
                        else {
                            if (typeof v.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof v);
                            v.addEventListener(N, function P(U) {
                                z.once && v.removeEventListener(N, P), O(U);
                            });
                        }
                    }
                    Object.defineProperty(c, "defaultMaxListeners", {
                        enumerable: !0,
                        get: function() {
                            return l;
                        },
                        set: function(v) {
                            if (typeof v != "number" || v < 0 || u(v)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + v + ".");
                            l = v;
                        }
                    }), c.init = function() {
                        this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
                    }, c.prototype.setMaxListeners = function(v) {
                        if (typeof v != "number" || v < 0 || u(v)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + v + ".");
                        return this._maxListeners = v, this;
                    }, c.prototype.getMaxListeners = function() {
                        return h(this);
                    }, c.prototype.emit = function(v) {
                        for(var N = [], O = 1; O < arguments.length; O++)N.push(arguments[O]);
                        var z = v === "error", P = this._events;
                        if (P !== void 0) z = z && P.error === void 0;
                        else if (!z) return !1;
                        if (z) throw (U = 0 < N.length ? N[0] : U) instanceof Error ? U : (z = new Error("Unhandled error." + (U ? " (" + U.message + ")" : "")), z.context = U, z);
                        var U = P[v];
                        if (U === void 0) return !1;
                        if (typeof U == "function") o(U, this, N);
                        else for(var R = U.length, G = x(U, R), O = 0; O < R; ++O)o(G[O], this, N);
                        return !0;
                    }, c.prototype.on = c.prototype.addListener = function(v, N) {
                        return f(this, v, N, !1);
                    }, c.prototype.prependListener = function(v, N) {
                        return f(this, v, N, !0);
                    }, c.prototype.once = function(v, N) {
                        return d(N), this.on(v, g(this, v, N)), this;
                    }, c.prototype.prependOnceListener = function(v, N) {
                        return d(N), this.prependListener(v, g(this, v, N)), this;
                    }, c.prototype.off = c.prototype.removeListener = function(v, N) {
                        var O, z, P, U, R;
                        if (d(N), (z = this._events) !== void 0 && (O = z[v]) !== void 0) {
                            if (O === N || O.listener === N) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete z[v], z.removeListener && this.emit("removeListener", v, O.listener || N));
                            else if (typeof O != "function") {
                                for(P = -1, U = O.length - 1; 0 <= U; U--)if (O[U] === N || O[U].listener === N) {
                                    R = O[U].listener, P = U;
                                    break;
                                }
                                if (P < 0) return this;
                                if (P === 0) O.shift();
                                else {
                                    for(var G = O, F = P; F + 1 < G.length; F++)G[F] = G[F + 1];
                                    G.pop();
                                }
                                O.length === 1 && (z[v] = O[0]), z.removeListener !== void 0 && this.emit("removeListener", v, R || N);
                            }
                        }
                        return this;
                    }, c.prototype.removeAllListeners = function(v) {
                        var N, O = this._events;
                        if (O !== void 0) {
                            if (O.removeListener === void 0) arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : O[v] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete O[v]);
                            else if (arguments.length === 0) {
                                for(var z, P = Object.keys(O), U = 0; U < P.length; ++U)(z = P[U]) !== "removeListener" && this.removeAllListeners(z);
                                this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0;
                            } else if (typeof (N = O[v]) == "function") this.removeListener(v, N);
                            else if (N !== void 0) for(U = N.length - 1; 0 <= U; U--)this.removeListener(v, N[U]);
                        }
                        return this;
                    }, c.prototype.listeners = function(v) {
                        return p(this, v, !0);
                    }, c.prototype.rawListeners = function(v) {
                        return p(this, v, !1);
                    }, c.listenerCount = function(v, N) {
                        return typeof v.listenerCount == "function" ? v.listenerCount(N) : m.call(v, N);
                    }, c.prototype.listenerCount = m, c.prototype.eventNames = function() {
                        return 0 < this._eventsCount ? a(this._events) : [];
                    };
                },
                9616: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(g, p, m, x) {
                        x === void 0 && (x = m);
                        var _ = Object.getOwnPropertyDescriptor(p, m);
                        _ && ("get" in _ ? p.__esModule : !_.writable && !_.configurable) || (_ = {
                            enumerable: !0,
                            get: function() {
                                return p[m];
                            }
                        }), Object.defineProperty(g, x, _);
                    } : function(g, p, m, x) {
                        g[x = x === void 0 ? m : x] = p[m];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(g, p) {
                        Object.defineProperty(g, "default", {
                            enumerable: !0,
                            value: p
                        });
                    } : function(g, p) {
                        g.default = p;
                    }), c = this && this.__importStar || function(g) {
                        if (g && g.__esModule) return g;
                        var p = {};
                        if (g != null) for(var m in g)m !== "default" && Object.prototype.hasOwnProperty.call(g, m) && a(p, g, m);
                        return u(p, g), p;
                    };
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Sdk = void 0;
                    const l = c(o(5149)), d = c(o(9386));
                    var h = c(o(9815));
                    class f extends l.CustomEmitter {
                        constructor(m){
                            super();
                            S(this, "mount");
                            S(this, "api");
                            S(this, "session");
                            S(this, "env");
                            S(this, "async");
                            S(this, "sync");
                            S(this, "methods");
                            S(this, "app", h.Projects.titles.crossmark);
                            m != null && m.project && (this.app = m == null ? void 0 : m.project), this.env = new l.Env(), this.api = new l.Api(this), this.session = new l.Session(this), this.mount = new l.Mount(this), this.async = new d.Async(this), this.sync = new d.Sync(this), this.methods = Object.assign({}, this.async, this.sync), new l.CustomEvents(this);
                        }
                    }
                    i.Sdk = f;
                },
                614: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(d, h, f, g) {
                        g === void 0 && (g = f);
                        var p = Object.getOwnPropertyDescriptor(h, f);
                        p && ("get" in p ? h.__esModule : !p.writable && !p.configurable) || (p = {
                            enumerable: !0,
                            get: function() {
                                return h[f];
                            }
                        }), Object.defineProperty(d, g, p);
                    } : function(d, h, f, g) {
                        d[g = g === void 0 ? f : g] = h[f];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(d, h) {
                        Object.defineProperty(d, "default", {
                            enumerable: !0,
                            value: h
                        });
                    } : function(d, h) {
                        d.default = h;
                    }), c = this && this.__importStar || function(d) {
                        if (d && d.__esModule) return d;
                        var h = {};
                        if (d != null) for(var f in d)f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && a(h, d, f);
                        return u(h, d), h;
                    };
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Async = void 0;
                    const l = c(o(9815));
                    i.Async = class {
                        constructor(d){
                            S(this, "sdk");
                            S(this, "api");
                            S(this, "session");
                            S(this, "mount");
                            S(this, "signInAndWait", (d)=>this.api.awaitRequest({
                                    command: l.COMMANDS.SIGN,
                                    data: {
                                        tx: {
                                            TransactionType: "SignIn"
                                        },
                                        hex: d
                                    }
                                }));
                            S(this, "signAndWait", (d, h)=>this.api.awaitRequest({
                                    command: l.COMMANDS.SIGN,
                                    data: {
                                        tx: d,
                                        opts: h
                                    }
                                }));
                            S(this, "submitAndWait", (d, h, f)=>this.api.awaitRequest({
                                    command: l.COMMANDS.SUBMIT,
                                    data: {
                                        address: d,
                                        txblob: h,
                                        opts: f
                                    }
                                }));
                            S(this, "signAndSubmitAndWait", (d, h)=>this.api.awaitRequest({
                                    command: l.COMMANDS.SIGNANDSUBMIT,
                                    data: {
                                        tx: d,
                                        opts: h
                                    }
                                }));
                            S(this, "bulkSignAndWait", (d, h)=>this.api.awaitRequest({
                                    command: l.COMMANDS.BULKSIGN,
                                    data: {
                                        txns: d,
                                        opts: h
                                    }
                                }));
                            S(this, "bulkSubmitAndWait", (d, h, f)=>this.api.awaitRequest({
                                    command: l.COMMANDS.BULKSUBMIT,
                                    data: {
                                        address: d,
                                        txblobs: h,
                                        opts: f
                                    }
                                }));
                            S(this, "bulkSignAndSubmitAndWait", (d, h)=>this.api.awaitRequest({
                                    command: l.COMMANDS.BULK,
                                    data: {
                                        txns: d,
                                        opts: h
                                    }
                                }));
                            S(this, "encryptAndWait", {
                                aes: (d, h, f)=>this.api.awaitRequest({
                                        command: l.COMMANDS.ENCRYPT,
                                        data: {
                                            address: d,
                                            data: h,
                                            opts: f
                                        }
                                    })
                            });
                            S(this, "decryptAndAwait", {
                                aes: (d, h, f)=>this.api.awaitRequest({
                                        command: l.COMMANDS.DECRYPT,
                                        data: {
                                            address: d,
                                            hex: h,
                                            opts: f
                                        }
                                    })
                            });
                            S(this, "isLockedAndWait", ()=>this.api.awaitRequest({
                                    command: l.COMMANDS.IS_LOCKED
                                }));
                            S(this, "versionAndWait", ()=>this.api.awaitRequest({
                                    command: l.COMMANDS.VERSION
                                }));
                            S(this, "verifyAndWait", (d)=>this.api.awaitRequest({
                                    command: l.COMMANDS.VERIFY,
                                    data: {
                                        hex: d
                                    }
                                }));
                            S(this, "connect", (d)=>this.mount.loop(d));
                            S(this, "detect", (d)=>this.mount.loop(d));
                            this.sdk = d, this.api = d.api, this.session = d.session, this.mount = d.mount;
                        }
                    };
                },
                9386: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Sync = i.Async = void 0;
                    var a = o(614), u = (Object.defineProperty(i, "Async", {
                        enumerable: !0,
                        get: function() {
                            return a.Async;
                        }
                    }), o(8258));
                    Object.defineProperty(i, "Sync", {
                        enumerable: !0,
                        get: function() {
                            return u.Sync;
                        }
                    });
                },
                8258: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(d, h, f, g) {
                        g === void 0 && (g = f);
                        var p = Object.getOwnPropertyDescriptor(h, f);
                        p && ("get" in p ? h.__esModule : !p.writable && !p.configurable) || (p = {
                            enumerable: !0,
                            get: function() {
                                return h[f];
                            }
                        }), Object.defineProperty(d, g, p);
                    } : function(d, h, f, g) {
                        d[g = g === void 0 ? f : g] = h[f];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(d, h) {
                        Object.defineProperty(d, "default", {
                            enumerable: !0,
                            value: h
                        });
                    } : function(d, h) {
                        d.default = h;
                    }), c = this && this.__importStar || function(d) {
                        if (d && d.__esModule) return d;
                        var h = {};
                        if (d != null) for(var f in d)f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && a(h, d, f);
                        return u(h, d), h;
                    };
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Sync = void 0;
                    const l = c(o(9815));
                    i.Sync = class {
                        constructor(d){
                            S(this, "sdk");
                            S(this, "api");
                            S(this, "session");
                            S(this, "mount");
                            S(this, "signIn", (d)=>this.api.request({
                                    command: l.COMMANDS.SIGN,
                                    data: {
                                        tx: {
                                            TransactionType: "SignIn"
                                        },
                                        hex: d
                                    }
                                }));
                            S(this, "sign", (d, h)=>this.api.request({
                                    command: l.COMMANDS.SIGN,
                                    data: {
                                        tx: d,
                                        opts: h
                                    }
                                }));
                            S(this, "submit", (d, h, f)=>this.api.request({
                                    command: l.COMMANDS.SUBMIT,
                                    data: {
                                        address: d,
                                        txblob: h,
                                        opts: f
                                    }
                                }));
                            S(this, "signAndSubmit", (d, h)=>this.api.request({
                                    command: l.COMMANDS.SIGNANDSUBMIT,
                                    data: {
                                        tx: d,
                                        opts: h
                                    }
                                }));
                            S(this, "bulkSign", (d, h)=>this.api.request({
                                    command: l.COMMANDS.BULKSIGN,
                                    data: {
                                        txns: d,
                                        opts: h
                                    }
                                }));
                            S(this, "bulkSubmit", (d, h, f)=>this.api.request({
                                    command: l.COMMANDS.BULKSUBMIT,
                                    data: {
                                        address: d,
                                        txblobs: h,
                                        opts: f
                                    }
                                }));
                            S(this, "encrypt", {
                                aes: (d, h, f)=>this.api.request({
                                        command: l.COMMANDS.ENCRYPT,
                                        data: {
                                            address: d,
                                            data: h,
                                            opts: f
                                        }
                                    })
                            });
                            S(this, "decrypt", {
                                aes: (d, h, f)=>this.api.request({
                                        command: l.COMMANDS.DECRYPT,
                                        data: {
                                            address: d,
                                            hex: h,
                                            opts: f
                                        }
                                    })
                            });
                            S(this, "bulkSignAndSubmit", (d, h)=>this.api.request({
                                    command: l.COMMANDS.BULK,
                                    data: {
                                        txns: d,
                                        opts: h
                                    }
                                }));
                            S(this, "getResponse", (d)=>this.session.responses.get(d));
                            S(this, "isConnected", ()=>this.mount.isDetected);
                            S(this, "isInstalled", ()=>this.mount.isDetected);
                            S(this, "isLocked", ()=>this.api.request({
                                    command: l.COMMANDS.IS_LOCKED
                                }));
                            S(this, "isOpen", ()=>this.session.isOpen);
                            S(this, "version", ()=>this.api.request({
                                    command: l.COMMANDS.VERSION
                                }));
                            S(this, "verify", (d)=>this.api.request({
                                    command: l.COMMANDS.VERIFY,
                                    data: {
                                        hex: d
                                    }
                                }));
                            S(this, "getAddress", ()=>this.session.address);
                            S(this, "getNetwork", ()=>this.session.network);
                            S(this, "getUser", ()=>this.session.user);
                            this.sdk = d, this.api = d.api, this.session = d.session, this.mount = d.mount;
                        }
                    };
                },
                6515: function(s, i, o) {
                    var g, p, m;
                    var a = this && this.__createBinding || (Object.create ? function(x, _, v, N) {
                        N === void 0 && (N = v);
                        var O = Object.getOwnPropertyDescriptor(_, v);
                        O && ("get" in O ? _.__esModule : !O.writable && !O.configurable) || (O = {
                            enumerable: !0,
                            get: function() {
                                return _[v];
                            }
                        }), Object.defineProperty(x, N, O);
                    } : function(x, _, v, N) {
                        x[N = N === void 0 ? v : N] = _[v];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(x, _) {
                        Object.defineProperty(x, "default", {
                            enumerable: !0,
                            value: _
                        });
                    } : function(x, _) {
                        x.default = _;
                    }), c = this && this.__importStar || function(x) {
                        if (x && x.__esModule) return x;
                        var _ = {};
                        if (x != null) for(var v in x)v !== "default" && Object.prototype.hasOwnProperty.call(x, v) && a(_, x, v);
                        return u(_, x), _;
                    }, l = this && this.__importDefault || function(x) {
                        return x && x.__esModule ? x : {
                            default: x
                        };
                    }, l = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Api = void 0, l(o(7531)));
                    const d = c(o(9815)), h = o(266);
                    class f extends l.default {
                        constructor(v){
                            super();
                            S(this, "sdk");
                            S(this, "active", /* @__PURE__ */ new Map());
                            S(this, "uuid");
                            S(this, "connected");
                            S(this, "target");
                            S(this, "timestamp");
                            Ao(this, g, (v)=>{
                                var P, U, R, G;
                                try {
                                    if (window && (!window || v.source === window && v.source && v.origin === window.location.origin) && v.data) {
                                        var N = ((P = v.data) == null ? void 0 : P.type) || void 0, O = ((U = v.data) == null ? void 0 : U.response) || void 0, z = ((R = v.data) == null ? void 0 : R.app) || void 0;
                                        if ((N !== "request" || z === this.sdk.app) && N !== d.TYPES.UPDATE) return N === d.TYPES.EVENT && "type" in v.data ? bs(this, p).call(this, v.data) : (O && O.type === d.TYPES.RESPONSE && this.emit(d.EVENTS.RESPONSE, v.data), O && O.type === d.EVENTS.RESPONSE && this.active.get(O.id) ? (G = this.active.get(O.id)) == null ? void 0 : G.resolve(v.data) : void 0);
                                    }
                                } catch  {}
                            });
                            Ao(this, p, (v)=>{
                                v.event === d.EVENTS.PING && this.emit(d.EVENTS.PING), v.event === d.EVENTS.CLOSE && this.emit(d.EVENTS.CLOSE), v.event === d.EVENTS.OPEN && this.emit(d.EVENTS.OPEN), v.event === d.EVENTS.SIGNOUT && this.emit(d.EVENTS.SIGNOUT), v.event === d.EVENTS.USER_CHANGE && this.emit(d.EVENTS.USER_CHANGE, v.data), v.event === d.EVENTS.NETWORK_CHANGE && this.emit(d.EVENTS.NETWORK_CHANGE, v.data);
                            });
                            Ao(this, m, async (v)=>{
                                var N = await new Promise((O, z)=>{
                                    this.active.set(v.id, {
                                        resolve: O,
                                        reject: z
                                    }), window && window.postMessage(v);
                                });
                                return this.active.delete(v.id), N;
                            });
                            S(this, "awaitRequest", async (v)=>{
                                try {
                                    return await bs(this, m).call(this, {
                                        app: this.sdk.app,
                                        type: d.TYPES.REQUEST,
                                        id: (0, h.uuid)(),
                                        ...v
                                    });
                                } catch (N) {
                                    throw N;
                                }
                            });
                            S(this, "request", (v)=>{
                                try {
                                    var N = (0, h.uuid)();
                                    return bs(this, m).call(this, {
                                        app: this.sdk.app,
                                        type: d.TYPES.REQUEST,
                                        id: N,
                                        ...v
                                    }), N;
                                } catch (O) {
                                    throw O;
                                }
                            });
                            this.sdk = v, this.uuid = (0, h.uuid)(), this.connected = !1, this.timestamp = Date.now(), ("TURBOPACK compile-time value", "undefined") < "u" && (this.target = window.origin, window.addEventListener("message", bs(this, g)));
                        }
                    }
                    g = new WeakMap(), p = new WeakMap(), m = new WeakMap(), i.Api = f;
                },
                2585: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Env = void 0;
                    class o {
                        constructor(){
                            S(this, "isAndroid", !1);
                            S(this, "isIos", !1);
                            S(this, "isOpera", !1);
                            S(this, "isWindows", !1);
                            S(this, "isSSR", !1);
                            S(this, "isXApp", !1);
                            S(this, "isMobile", !1);
                            S(this, "isDesktop", !1);
                            ("TURBOPACK compile-time value", "undefined") < "u" && (this.isAndroid = !!(window != null && window.navigator.userAgent.match(/Android/i)), this.isIos = !!(window != null && window.navigator.userAgent.match(/iPhone|iPad|iPod/i)), this.isOpera = !!(window != null && window.navigator.userAgent.match(/Opera Mini/i)), this.isWindows = !!(window != null && window.navigator.userAgent.match(/IEMobile/i)), this.isSSR = !!(window != null && window.navigator.userAgent.match(/SSR/i)), this.isXApp = !!(window != null && window.navigator.userAgent.match(/xumm/i)), this.isMobile = !!(this.isAndroid || this.isIos || this.isOpera || this.isWindows), this.isDesktop = !this.isMobile && !this.isSSR);
                        }
                    }
                    i.Env = o, i.default = new o();
                },
                6962: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(f, g, p, m) {
                        m === void 0 && (m = p);
                        var x = Object.getOwnPropertyDescriptor(g, p);
                        x && ("get" in x ? g.__esModule : !x.writable && !x.configurable) || (x = {
                            enumerable: !0,
                            get: function() {
                                return g[p];
                            }
                        }), Object.defineProperty(f, m, x);
                    } : function(f, g, p, m) {
                        f[m = m === void 0 ? p : m] = g[p];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(f, g) {
                        Object.defineProperty(f, "default", {
                            enumerable: !0,
                            value: g
                        });
                    } : function(f, g) {
                        f.default = g;
                    }), c = this && this.__importStar || function(f) {
                        if (f && f.__esModule) return f;
                        var g = {};
                        if (f != null) for(var p in f)p !== "default" && Object.prototype.hasOwnProperty.call(f, p) && a(g, f, p);
                        return u(g, f), g;
                    }, l = this && this.__importDefault || function(f) {
                        return f && f.__esModule ? f : {
                            default: f
                        };
                    }, l = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.CustomEvents = i.CustomEmitter = void 0, l(o(7531)));
                    const d = c(o(9815));
                    class h extends l.default {
                    }
                    i.CustomEmitter = h, i.CustomEvents = class extends h {
                        constructor(g){
                            super();
                            S(this, "sdk");
                            S(this, "api");
                            this.sdk = g, this.api = this.sdk.api, this.api.on(d.EVENTS.PING, ()=>this.sdk.emit(d.EVENTS.PING)), this.api.on(d.EVENTS.RESPONSE, (p)=>{
                                this.sdk.emit(d.EVENTS.RESPONSE, p), this.sdk.emit(d.EVENTS.ALL, {
                                    type: d.EVENTS.RESPONSE,
                                    resp: p
                                });
                            }), this.api.on(d.EVENTS.USER_CHANGE, (p)=>{
                                this.sdk.emit(d.EVENTS.USER_CHANGE, p), this.sdk.emit(d.EVENTS.ALL, {
                                    type: d.EVENTS.USER_CHANGE,
                                    user: p
                                });
                            }), this.api.on(d.EVENTS.NETWORK_CHANGE, (p)=>{
                                this.sdk.emit(d.EVENTS.NETWORK_CHANGE, p), this.sdk.emit(d.EVENTS.ALL, {
                                    type: d.EVENTS.NETWORK_CHANGE,
                                    network: p
                                });
                            }), this.api.on(d.EVENTS.OPEN, ()=>{
                                this.sdk.emit(d.EVENTS.OPEN), this.sdk.emit(d.EVENTS.ALL, {
                                    type: d.EVENTS.OPEN
                                });
                            }), this.api.on(d.EVENTS.CLOSE, ()=>{
                                this.sdk.emit(d.EVENTS.CLOSE), this.sdk.emit(d.EVENTS.ALL, {
                                    type: d.EVENTS.CLOSE
                                });
                            }), this.api.on(d.EVENTS.SIGNOUT, ()=>{
                                this.sdk.emit(d.EVENTS.SIGNOUT), this.sdk.emit(d.EVENTS.ALL, {
                                    type: d.EVENTS.SIGNOUT
                                });
                            });
                        }
                    };
                },
                5149: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Session = i.Scheme = i.Mount = i.CustomEvents = i.CustomEmitter = i.Env = i.Api = void 0;
                    var a = o(6515), u = (Object.defineProperty(i, "Api", {
                        enumerable: !0,
                        get: function() {
                            return a.Api;
                        }
                    }), o(2585)), c = (Object.defineProperty(i, "Env", {
                        enumerable: !0,
                        get: function() {
                            return u.Env;
                        }
                    }), o(6962)), l = (Object.defineProperty(i, "CustomEmitter", {
                        enumerable: !0,
                        get: function() {
                            return c.CustomEmitter;
                        }
                    }), Object.defineProperty(i, "CustomEvents", {
                        enumerable: !0,
                        get: function() {
                            return c.CustomEvents;
                        }
                    }), o(288)), d = (Object.defineProperty(i, "Mount", {
                        enumerable: !0,
                        get: function() {
                            return l.Mount;
                        }
                    }), o(2821)), h = (Object.defineProperty(i, "Scheme", {
                        enumerable: !0,
                        get: function() {
                            return d.Scheme;
                        }
                    }), o(2413));
                    Object.defineProperty(i, "Session", {
                        enumerable: !0,
                        get: function() {
                            return h.Session;
                        }
                    });
                },
                288: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(g, p, m, x) {
                        x === void 0 && (x = m);
                        var _ = Object.getOwnPropertyDescriptor(p, m);
                        _ && ("get" in _ ? p.__esModule : !_.writable && !_.configurable) || (_ = {
                            enumerable: !0,
                            get: function() {
                                return p[m];
                            }
                        }), Object.defineProperty(g, x, _);
                    } : function(g, p, m, x) {
                        g[x = x === void 0 ? m : x] = p[m];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(g, p) {
                        Object.defineProperty(g, "default", {
                            enumerable: !0,
                            value: p
                        });
                    } : function(g, p) {
                        g.default = p;
                    }), c = this && this.__importStar || function(g) {
                        if (g && g.__esModule) return g;
                        var p = {};
                        if (g != null) for(var m in g)m !== "default" && Object.prototype.hasOwnProperty.call(g, m) && a(p, g, m);
                        return u(p, g), p;
                    }, l = this && this.__importDefault || function(g) {
                        return g && g.__esModule ? g : {
                            default: g
                        };
                    }, l = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Mount = void 0, l(o(7531)));
                    const d = o(266), h = c(o(9815));
                    class f extends l.default {
                        constructor(m){
                            super();
                            S(this, "isDetected");
                            S(this, "sdk");
                            S(this, "loop", async (m)=>new Promise(async (x, _)=>{
                                    this.isDetected && x(!0);
                                    var v = Date.now();
                                    if (this.sdk.app === h.Projects.titles.embark) for(;;){
                                        if (("TURBOPACK compile-time value", "undefined") < "u" && window.xrpl && window.xrpl.isEmbark) {
                                            this.isDetected = window.xrpl.isEmbark, window.embark = Object.assign({}, window == null ? void 0 : window.embark, this.sdk), this.emit("detected"), this.sdk.emit("detected"), x(!0);
                                            break;
                                        }
                                        if (await (0, d.sleep)(500), Date.now() > v + (m ?? 1e4)) {
                                            x(!1);
                                            break;
                                        }
                                    }
                                    else for(;;){
                                        if (("TURBOPACK compile-time value", "undefined") < "u" && window.xrpl && window.xrpl.isCrossmark) {
                                            this.isDetected = window.xrpl.isCrossmark, window.crossmark = Object.assign({}, window == null ? void 0 : window.crossmark, this.sdk), this.emit("detected"), this.sdk.emit("detected"), x(!0);
                                            break;
                                        }
                                        if (await (0, d.sleep)(500), Date.now() > v + (m ?? 1e4)) {
                                            x(!1);
                                            break;
                                        }
                                    }
                                }));
                            this.sdk = m, this.loop(1e4);
                        }
                    }
                    i.Mount = f;
                },
                2821: function(s, i, o) {
                    var a = this && this.__importDefault || function(c) {
                        return c && c.__esModule ? c : {
                            default: c
                        };
                    };
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Scheme = void 0;
                    const u = a(o(2585));
                    i.Scheme = {
                        get: (c, l)=>{
                            if (l.startsWith("_")) throw new Error("Access denied");
                            if (u.default.isMobile) throw new Error("Crossmark only available from desktop");
                            return l = c[l], typeof l == "function" ? l.bind(c) : l;
                        },
                        set: (c, l, d)=>{
                            if (l.startsWith("_")) throw new Error("Access denied");
                            return c[l] = d, !0;
                        },
                        deleteProperty: (c, l)=>{
                            if (l.startsWith("_")) throw new Error("Access denied");
                            return delete c[l], !0;
                        },
                        ownKeys: (c)=>Object.keys(c).filter((l)=>!l.startsWith("_"))
                    };
                },
                2413: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
                        p === void 0 && (p = g);
                        var m = Object.getOwnPropertyDescriptor(f, g);
                        m && ("get" in m ? f.__esModule : !m.writable && !m.configurable) || (m = {
                            enumerable: !0,
                            get: function() {
                                return f[g];
                            }
                        }), Object.defineProperty(h, p, m);
                    } : function(h, f, g, p) {
                        h[p = p === void 0 ? g : p] = f[g];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
                        Object.defineProperty(h, "default", {
                            enumerable: !0,
                            value: f
                        });
                    } : function(h, f) {
                        h.default = f;
                    }), c = this && this.__importStar || function(h) {
                        if (h && h.__esModule) return h;
                        var f = {};
                        if (h != null) for(var g in h)g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
                        return u(f, h), f;
                    };
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Session = void 0;
                    const l = c(o(9815));
                    class d {
                        constructor(f){
                            S(this, "sdk");
                            S(this, "user");
                            S(this, "network");
                            S(this, "address");
                            S(this, "isOpen", !1);
                            S(this, "lastPing");
                            S(this, "state", "unactive");
                            S(this, "responses", /* @__PURE__ */ new Map());
                            S(this, "handleDetect", async ()=>{
                                this.network = (await this.sdk.api.awaitRequest({
                                    command: l.COMMANDS.NETWORK
                                })).response.data.network, this.user = (await this.sdk.api.awaitRequest({
                                    command: l.COMMANDS.USER
                                })).response.data.user, this.address = (await this.sdk.api.awaitRequest({
                                    command: l.COMMANDS.ADDRESS
                                })).response.data.address, this.network && this.user && this.address && (this.state = "active");
                            });
                            S(this, "handlePing", ()=>this.lastPing = Date.now());
                            S(this, "handleClose", ()=>this.isOpen = !1);
                            S(this, "handleOpen", ()=>this.isOpen = !0);
                            S(this, "handleSignOut", ()=>{
                                this.state = "unactive", this.address = void 0, this.network = void 0, this.user = void 0;
                            });
                            S(this, "handleNetworkChange", (f)=>{
                                this.network = f.network;
                            });
                            S(this, "handleUserChange", (f)=>{
                                this.user = f.user, this.address = void 0;
                            });
                            S(this, "handleResponse", (f)=>{
                                "address" in f.response.data && (this.state = "active", this.address = f.response.data.address), "network" in f.response.data && (this.network = f.response.data.network), "user" in f.response.data && (this.user = f.response.data.user), this.responses.set(f.request.id, f);
                            });
                            this.sdk = f, this.sdk.on(l.EVENTS.PING, this.handlePing), this.sdk.on(l.EVENTS.RESPONSE, this.handleResponse), this.sdk.on(l.EVENTS.USER_CHANGE, this.handleUserChange), this.sdk.on(l.EVENTS.NETWORK_CHANGE, this.handleNetworkChange), this.sdk.on(l.EVENTS.OPEN, this.handleOpen), this.sdk.on(l.EVENTS.CLOSE, this.handleClose), this.sdk.on(l.EVENTS.SIGNOUT, this.handleSignOut), this.sdk.on("detected", this.handleDetect);
                        }
                    }
                    (i.Session = d).prototype.user = void 0, d.prototype.network = void 0, d.prototype.address = void 0;
                },
                4240: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
                        p === void 0 && (p = g);
                        var m = Object.getOwnPropertyDescriptor(f, g);
                        m && ("get" in m ? f.__esModule : !m.writable && !m.configurable) || (m = {
                            enumerable: !0,
                            get: function() {
                                return f[g];
                            }
                        }), Object.defineProperty(h, p, m);
                    } : function(h, f, g, p) {
                        h[p = p === void 0 ? g : p] = f[g];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
                        Object.defineProperty(h, "default", {
                            enumerable: !0,
                            value: f
                        });
                    } : function(h, f) {
                        h.default = f;
                    }), d = this && this.__importStar || function(h) {
                        if (h && h.__esModule) return h;
                        var f = {};
                        if (h != null) for(var g in h)g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
                        return u(f, h), f;
                    };
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.typings = i.modules = i.vanilla = void 0;
                    const c = o(9616);
                    Object.defineProperty(i, "vanilla", {
                        enumerable: !0,
                        get: function() {
                            return c.Sdk;
                        }
                    });
                    var l = d(o(40)), d = (i.modules = l, d(o(9815)));
                    i.typings = d, i.default = l.xmark;
                },
                2898: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
                        p === void 0 && (p = g);
                        var m = Object.getOwnPropertyDescriptor(f, g);
                        m && ("get" in m ? f.__esModule : !m.writable && !m.configurable) || (m = {
                            enumerable: !0,
                            get: function() {
                                return f[g];
                            }
                        }), Object.defineProperty(h, p, m);
                    } : function(h, f, g, p) {
                        h[p = p === void 0 ? g : p] = f[g];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
                        Object.defineProperty(h, "default", {
                            enumerable: !0,
                            value: f
                        });
                    } : function(h, f) {
                        h.default = f;
                    }), d = this && this.__importStar || function(h) {
                        if (h && h.__esModule) return h;
                        var f = {};
                        if (h != null) for(var g in h)g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
                        return u(f, h), f;
                    }, c = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), o(9616)), l = d(o(5149)), d = d(o(9815));
                    i.default = new Proxy(new c.Sdk({
                        project: d.Projects.titles.crossmark
                    }), l.Scheme);
                },
                477: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
                        p === void 0 && (p = g);
                        var m = Object.getOwnPropertyDescriptor(f, g);
                        m && ("get" in m ? f.__esModule : !m.writable && !m.configurable) || (m = {
                            enumerable: !0,
                            get: function() {
                                return f[g];
                            }
                        }), Object.defineProperty(h, p, m);
                    } : function(h, f, g, p) {
                        h[p = p === void 0 ? g : p] = f[g];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
                        Object.defineProperty(h, "default", {
                            enumerable: !0,
                            value: f
                        });
                    } : function(h, f) {
                        h.default = f;
                    }), d = this && this.__importStar || function(h) {
                        if (h && h.__esModule) return h;
                        var f = {};
                        if (h != null) for(var g in h)g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
                        return u(f, h), f;
                    }, c = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), o(9616)), l = d(o(5149)), d = d(o(9815));
                    i.default = new Proxy(new c.Sdk({
                        project: d.Projects.titles.embark
                    }), l.Scheme);
                },
                40: function(s, i, o) {
                    var a = this && this.__importDefault || function(l) {
                        return l && l.__esModule ? l : {
                            default: l
                        };
                    }, u = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.embark = i.xmark = void 0, o(2898)), c = (Object.defineProperty(i, "xmark", {
                        enumerable: !0,
                        get: function() {
                            return a(u).default;
                        }
                    }), o(477));
                    Object.defineProperty(i, "embark", {
                        enumerable: !0,
                        get: function() {
                            return a(c).default;
                        }
                    });
                },
                5007: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.uuid = void 0, i.uuid = ()=>{
                        let o = "", a;
                        for(a = 0; a < 32; a += 1)switch(a){
                            case 8:
                            case 20:
                                o = (o += "-") + (16 * Math.random() | 0).toString(16);
                                break;
                            case 12:
                                o = o + "-4";
                                break;
                            case 16:
                                o = (o += "-") + (4 * Math.random() | 8).toString(16);
                                break;
                            default:
                                o += (16 * Math.random() | 0).toString(16);
                        }
                        return o;
                    };
                },
                266: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.uuid = i.sleep = void 0;
                    var a = o(2200), u = (Object.defineProperty(i, "sleep", {
                        enumerable: !0,
                        get: function() {
                            return a.sleep;
                        }
                    }), o(5007));
                    Object.defineProperty(i, "uuid", {
                        enumerable: !0,
                        get: function() {
                            return u.uuid;
                        }
                    });
                },
                2200: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.sleep = void 0, i.sleep = async (o)=>{
                        await new Promise((a)=>{
                            setTimeout(a, o);
                        });
                    };
                },
                2025: (s, i)=>{
                    var o;
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Config = void 0, i.Config = (o = class {
                    }, S(o, "config"), o);
                },
                7268: (s, i)=>{
                    var o;
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Events = void 0, i.Events = (o = class {
                    }, S(o, "GenericEvent"), S(o, "BaseEvent"), S(o, "EventMessage"), S(o, "NetworkEvent"), S(o, "UserEvent"), S(o, "StateEvent"), S(o, "SignoutEvent"), o);
                },
                9291: (s, i)=>{
                    var o;
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Models = void 0, i.Models = (o = class {
                    }, S(o, "Request"), S(o, "Response"), S(o, "FullResponse"), S(o, "IsConnectedRequest"), S(o, "IsLockedRequest"), S(o, "SignInRequest"), S(o, "IsOpenRequest"), S(o, "SignRequest"), S(o, "VersionRequest"), S(o, "NetworkRequest"), S(o, "UserRequest"), S(o, "AddressRequest"), S(o, "VerifyRequest"), S(o, "SignAndSubmitRequest"), S(o, "SubmitRequest"), S(o, "EncryptRequest"), S(o, "DecryptRequest"), S(o, "IsConnectedResponse"), S(o, "IsLockedResponse"), S(o, "SignInResponse"), S(o, "IsOpenResponse"), S(o, "SignResponse"), S(o, "VersionResponse"), S(o, "AddressResponse"), S(o, "NetworkResponse"), S(o, "UserResponse"), S(o, "VerifyResponse"), S(o, "SignAndSubmitResponse"), S(o, "SubmitResponse"), S(o, "IsConnectedFullResponse"), S(o, "IsLockedFullResponse"), S(o, "SignInFullResponse"), S(o, "IsOpenFullResponse"), S(o, "SignFullResponse"), S(o, "VersionFullResponse"), S(o, "AddressFullResponse"), S(o, "NetworkFullResponse"), S(o, "UserFullResponse"), S(o, "VerifyFullResponse"), S(o, "SignAndSubmitFullResponse"), S(o, "SubmitFullResponse"), S(o, "BulkSubmitRequest"), S(o, "BulkSignRequest"), S(o, "BulkSignAndSubmitRequest"), S(o, "BulkSubmitFullResponse"), S(o, "BulkSignFullResponse"), S(o, "BulkSignAndSubmitFullResponse"), S(o, "BulkSubmitResponse"), S(o, "BulkSignResponse"), S(o, "BulkSignAndSubmitResponse"), S(o, "EncryptResponse"), S(o, "EncryptFullResponse"), S(o, "DecryptResponse"), S(o, "DecryptFullResponse"), S(o, "SenderFullResponse"), S(o, "SenderRequest"), S(o, "SenderResponse"), S(o, "ManagerFullResponse"), S(o, "ManagerRequest"), S(o, "ManagerResponse"), S(o, "AllTransactionRequest"), S(o, "AllTransactionResponse"), S(o, "AllTransactionMetadata"), S(o, "AllTxResponse"), S(o, "AllSubmitResponse"), S(o, "AllTransactionStream"), S(o, "AllTransaction"), S(o, "AllFullTransaction"), S(o, "IndexedTransactionRequest"), S(o, "SignTransaction"), S(o, "SignOpts"), S(o, "CryptOpts"), S(o, "ExtendedSignOpts"), S(o, "Status"), o);
                },
                4151: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.CatchAllEvent = i.TYPES = i.EVENTS = i.COMMANDS = i.Extension = void 0;
                    class o {
                    }
                    S(o, "CatchAllEvent"), S(o, "BasicUser"), S(o, "BasicNetwork"), S(o, "CleanExtMessage"), S(o, "CommResponse"), S(o, "CleanResponse"), S(o, "PostMessage"), S(o, "PortMessage"), S(o, "Payload"), S(o, "AppStatus"), S(o, "AllExtMessage"), S(o, "ExtMessage"), S(o, "RequestMessage"), S(o, "ResponseMessage"), S(o, "Targets"), S(o, "Events"), S(o, "Commands"), S(o, "Types");
                    var a, u;
                    i.Extension = o, a = o || (i.Extension = o = {}), (u = a.TYPES || (a.TYPES = {})).INIT = "init", u.REFRESH = "refresh", u.DISCONNECT = "disconnect", u.PING = "ping", u.REQUEST = "request", u.RESPONSE = "response", u.UPDATE = "update", u.EVENT = "event", (u = a.COMMANDS || (a.COMMANDS = {})).VERSION = "version", u.IS_CONNECTED = "isConnected", u.IS_LOCKED = "isLocked", u.OPEN = "open", u.SIGN = "sign", u.SIGNANDSUBMIT = "sign-and-submit", u.BULKSUBMIT = "bulk-submit", u.BULKSIGN = "bulk-sign", u.BULK = "bulk", u.SUBMIT = "submit", u.MANAGER = "manager", u.ADDRESS = "address", u.NETWORK = "network", u.USER = "user", u.VERIFY = "verify", u.SENDER = "sender", u.CHANGENODE = "change-node", u.CHANGEUSER = "change-user", u.DECRYPT = "decrypt", u.ENCRYPT = "encrypt", (u = a.EVENTS || (a.EVENTS = {})).ACCOUNTS_CHANGED = "accountsChanged", u.CHAIN_CHANGED = "chainChanged", u.CONNECT = "connect", u.DISCONNECT = "disconnect", u.MESSAGE = "message", u.POPUP_MODE = "popup-mode", u.STATE_UPDATE = "state-update", u.NETWORK_CHANGE = "network-change", u.USER_CHANGE = "user-change", u.OPEN = "open", u.CLOSE = "close", u.PING = "ping", u.SIGNIN = "signin", u.SIGNOUT = "signout", u.RESPONSE = "response", u.ALL = "all", (u = a.TARGETS || (a.TARGETS = {})).CONTENT = "content", u.BG = "bg", u.POP = "pop", i.COMMANDS = o.COMMANDS, i.EVENTS = o.EVENTS, i.TYPES = o.TYPES, i.CatchAllEvent = o.CatchAllEvent;
                },
                9312: (s, i)=>{
                    var o;
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Types = void 0, i.Types = (o = class {
                    }, S(o, "AgreementsSchema"), S(o, "GeneralSchema"), S(o, "NetworkSchema"), S(o, "CardSchema"), S(o, "ContactSchema"), S(o, "ProfileSchema"), S(o, "SecuritySchema"), S(o, "StateSchema"), S(o, "UserSchema"), S(o, "AppSchema"), S(o, "PreferenceSchema"), S(o, "VaultSchema"), S(o, "MountedUserSchema"), S(o, "Blank"), o);
                },
                7579: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(d, h, f, g) {
                        g === void 0 && (g = f);
                        var p = Object.getOwnPropertyDescriptor(h, f);
                        p && ("get" in p ? h.__esModule : !p.writable && !p.configurable) || (p = {
                            enumerable: !0,
                            get: function() {
                                return h[f];
                            }
                        }), Object.defineProperty(d, g, p);
                    } : function(d, h, f, g) {
                        d[g = g === void 0 ? f : g] = h[f];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(d, h) {
                        Object.defineProperty(d, "default", {
                            enumerable: !0,
                            value: h
                        });
                    } : function(d, h) {
                        d.default = h;
                    }), c = this && this.__importStar || function(d) {
                        if (d && d.__esModule) return d;
                        var h = {};
                        if (d != null) for(var f in d)f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && a(h, d, f);
                        return u(h, d), h;
                    }, c = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Types = void 0, c(o(9312)));
                    class l {
                    }
                    S(l, "Api", c), i.Types = l, o = l || (i.Types = l = {}), (c = o.TWCardColor || (o.TWCardColor = {})).color1 = "tw-bg-cardGradient1", c.color2 = "tw-bg-cardGradient2", c.color3 = "tw-bg-cardGradient3", c.color4 = "tw-bg-cardGradient4", c.color5 = "tw-bg-cardGradient5", c.color6 = "tw-bg-cardGradient6", c.color7 = "tw-bg-cardGradient7", c.color8 = "tw-bg-cardGradient8", c.color9 = "tw-bg-cardGradient9", c.color10 = "tw-bg-cardGradient10", (c = o.CardColor || (o.CardColor = {})).color1 = "color1", c.color2 = "color2", c.color3 = "color3", c.color4 = "color4", c.color5 = "color5", c.color6 = "color6", c.color7 = "color7", c.color8 = "color8", c.color9 = "color9", c.color10 = "color10", (c = o.NetworkTypes || (o.NetworkTypes = {})).main = "main", c.live = "live", c.test = "test", c.dev = "dev", c.hooks = "hooks", c.experimental = "experimental", c.sidechain = "sidechain", c.xls30 = "xls-30d", c.xls38 = "xls-38d", c.xahautest = "xahau-test", (c = o.Protocol || (o.Protocol = {})).xrpl = "XRPL", c.evm = "EVM", c.btc = "BTC", c.bsc = "BSC", c.ada = "ADA", c.sol = "SOL", c.usd = "USD", (c = o.XRPLExplorers || (o.XRPLExplorers = {})).bithomp = "bithomp", c.xrplorg = "xrpl.org", c.xrplf = "xrplf", c.xrpscan = "xrpscan", (o.EVMExplorers || (o.EVMExplorers = {})).evmSideChain = "evm-sidechain", o.networkColorMap = {
                        [o.NetworkTypes.main]: "tw-bg-[#38DBFF]",
                        [o.NetworkTypes.live]: "tw-bg-[#38FFDB]",
                        [o.NetworkTypes.test]: "tw-bg-[#DE7EFF]",
                        [o.NetworkTypes.dev]: "tw-bg-[#FFB648]",
                        [o.NetworkTypes.experimental]: "tw-bg-[#FF7B9B]",
                        [o.NetworkTypes.sidechain]: "tw-bg-[#7CFF99]",
                        [o.NetworkTypes.xls30]: "tw-bg-[#FF9C7C]",
                        [o.NetworkTypes.xls38]: "tw-bg-[#C34D27]",
                        [o.NetworkTypes.hooks]: "tw-bg-[#CF4C27]",
                        [o.NetworkTypes.xahautest]: "tw-bg-[#CF4C27]"
                    }, o.BithompHost = {
                        [o.NetworkTypes.main]: "https://bithomp.com/explorer",
                        [o.NetworkTypes.test]: "https://test.bithomp.com/explorer",
                        [o.NetworkTypes.dev]: "https://dev.bithomp.com/explorer",
                        [o.NetworkTypes.xls30]: "https://amm.bithomp.com/explorer",
                        [o.NetworkTypes.hooks]: "https://beta.bithomp.com/explorer",
                        [o.NetworkTypes.live]: "https://bithomp.com/explorer",
                        [o.NetworkTypes.experimental]: "",
                        [o.NetworkTypes.sidechain]: "",
                        [o.NetworkTypes.xls38]: "",
                        [o.NetworkTypes.xahautest]: "https://test.xahauexplorer.com/explorer"
                    }, o.XrplfHost = {
                        [o.NetworkTypes.main]: "https://explorer.xrplf.org",
                        [o.NetworkTypes.test]: "https://explorer-testnet.xrplf.org",
                        [o.NetworkTypes.hooks]: "https://hooks-testnet-v3-explorer.xrpl-labs.com",
                        [o.NetworkTypes.dev]: "",
                        [o.NetworkTypes.xls30]: "",
                        [o.NetworkTypes.live]: "",
                        [o.NetworkTypes.experimental]: "",
                        [o.NetworkTypes.sidechain]: "",
                        [o.NetworkTypes.xls38]: "",
                        [o.NetworkTypes.xahautest]: "https://explorer.xahau-test.net"
                    }, o.XrplOrgHost = {
                        [o.NetworkTypes.main]: "https://livenet.xrpl.org",
                        [o.NetworkTypes.test]: "https://testnet.xrpl.org",
                        [o.NetworkTypes.dev]: "https://devnet.xrpl.org",
                        [o.NetworkTypes.xls30]: "",
                        [o.NetworkTypes.hooks]: "",
                        [o.NetworkTypes.live]: "",
                        [o.NetworkTypes.experimental]: "",
                        [o.NetworkTypes.sidechain]: "",
                        [o.NetworkTypes.xls38]: "",
                        [o.NetworkTypes.xahautest]: ""
                    }, o.XRPScanHost = {
                        [o.NetworkTypes.main]: "https://xrpscan.com",
                        [o.NetworkTypes.test]: "",
                        [o.NetworkTypes.dev]: "",
                        [o.NetworkTypes.xls30]: "",
                        [o.NetworkTypes.hooks]: "",
                        [o.NetworkTypes.live]: "",
                        [o.NetworkTypes.experimental]: "",
                        [o.NetworkTypes.sidechain]: "",
                        [o.NetworkTypes.xls38]: "",
                        [o.NetworkTypes.xahautest]: ""
                    }, o.EvmSideChainHost = {
                        [o.NetworkTypes.dev]: "https://evm-sidechain.xrpl.org",
                        [o.NetworkTypes.main]: "",
                        [o.NetworkTypes.test]: "",
                        [o.NetworkTypes.xls30]: "",
                        [o.NetworkTypes.hooks]: "",
                        [o.NetworkTypes.live]: "",
                        [o.NetworkTypes.experimental]: "",
                        [o.NetworkTypes.sidechain]: "",
                        [o.NetworkTypes.xls38]: "",
                        [o.NetworkTypes.xahautest]: ""
                    }, o.ExplorerAddressPath = {
                        [o.XRPLExplorers.bithomp]: "",
                        [o.XRPLExplorers.xrplorg]: "/address",
                        [o.XRPLExplorers.xrplf]: "",
                        [o.XRPLExplorers.xrpscan]: "/account",
                        [o.EVMExplorers.evmSideChain]: "/address"
                    }, o.ExplorerTxPath = {
                        [o.XRPLExplorers.bithomp]: "",
                        [o.XRPLExplorers.xrplorg]: "/transactions",
                        [o.XRPLExplorers.xrplf]: "/tx",
                        [o.XRPLExplorers.xrpscan]: "/tx",
                        [o.EVMExplorers.evmSideChain]: "/tx"
                    }, o.availableProtocols = [
                        o.Protocol.xrpl,
                        o.Protocol.evm
                    ];
                },
                2083: (s, i, o)=>{
                    var a;
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Types = void 0, o(7579).Types.Api.Types, i.Types = (a = class {
                    }, S(a, "AgreementsSchema"), S(a, "GeneralSchema"), S(a, "NodeSchema"), S(a, "CardSchema"), S(a, "ContactSchema"), S(a, "ProfileSchema"), S(a, "SecuritySchema"), S(a, "StateSchema"), S(a, "UserSchema"), S(a, "AppSchema"), S(a, "PreferenceSchema"), S(a, "VaultSchema"), S(a, "MountedUserSchema"), S(a, "SecurityTypes"), S(a, "SecurityLevel"), S(a, "Blank"), a);
                },
                4855: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Card = void 0;
                    class o {
                    }
                    S(o, "MappedAddresses"), S(o, "ThemeArray"), S(o, "Color");
                    var a, u;
                    i.Card = o, i = o || (i.Card = o = {}), (a = i.TWCardColor || (i.TWCardColor = {})).color1 = "tw-bg-cardGradient1", a.color2 = "tw-bg-cardGradient2", a.color3 = "tw-bg-cardGradient3", a.color4 = "tw-bg-cardGradient4", a.color5 = "tw-bg-cardGradient5", a.color6 = "tw-bg-cardGradient6", a.color7 = "tw-bg-cardGradient7", a.color8 = "tw-bg-cardGradient8", a.color9 = "tw-bg-cardGradient9", a.color10 = "tw-bg-cardGradient10", (u = a = i.cardColorTheme || (i.cardColorTheme = {})).dark = "Dark", u.light = "Light", i.cardColorBg = {
                        [a.light]: "tw-bg-black",
                        [a.dark]: "tw-bg-white"
                    }, i.cardColorStroke = {
                        [a.light]: "tw-stroke-black",
                        [a.dark]: "tw-stroke-white"
                    }, i.cardColorText = {
                        [a.light]: "tw-text-black",
                        [a.dark]: "tw-text-white"
                    }, i.cardColorFill = {
                        [a.light]: "tw-fill-black",
                        [a.dark]: "tw-fill-white"
                    }, (u = i.CardColor || (i.CardColor = {})).color1 = "color1", u.color2 = "color2", u.color3 = "color3", u.color4 = "color4", u.color5 = "color5", u.color6 = "color6", u.color7 = "color7", u.color8 = "color8", u.color9 = "color9", u.color10 = "color10";
                },
                4284: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.AES_CBC = void 0;
                    var a = o(6914);
                    i.AES_CBC = class {
                        constructor(){
                            S(this, "algo");
                            S(this, "type", a.AlgoTypes.aes_cbc);
                            S(this, "iv");
                            S(this, "derivation");
                            S(this, "encrypt");
                            S(this, "decrypt");
                        }
                    };
                },
                410: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.AES_GCM = void 0;
                    var a = o(6914);
                    i.AES_GCM = class {
                        constructor(){
                            S(this, "algo");
                            S(this, "type", a.AlgoTypes.aes_gcm);
                            S(this, "iv");
                            S(this, "tag");
                            S(this, "derivation");
                            S(this, "encrypt");
                            S(this, "decrypt");
                        }
                    };
                },
                6914: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.AlgoTypes = void 0, i.AlgoTypes = {
                        standard: "sha512",
                        pbkdf2: "pbkdf2-sha512",
                        aes_cbc: "aes-512-cbc",
                        aes_gcm: "aes-512-gcm"
                    };
                },
                2625: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Standard = i.PBKDF2 = i.AES_CBC = i.AES_GCM = void 0;
                    var a = o(410), u = (Object.defineProperty(i, "AES_GCM", {
                        enumerable: !0,
                        get: function() {
                            return a.AES_GCM;
                        }
                    }), o(4284)), c = (Object.defineProperty(i, "AES_CBC", {
                        enumerable: !0,
                        get: function() {
                            return u.AES_CBC;
                        }
                    }), o(1055)), l = (Object.defineProperty(i, "PBKDF2", {
                        enumerable: !0,
                        get: function() {
                            return c.PBKDF2;
                        }
                    }), o(8633));
                    Object.defineProperty(i, "Standard", {
                        enumerable: !0,
                        get: function() {
                            return l.Standard;
                        }
                    });
                },
                1055: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.PBKDF2 = void 0;
                    var a = o(6914);
                    i.PBKDF2 = class {
                        constructor(){
                            S(this, "type", a.AlgoTypes.pbkdf2);
                            S(this, "iterations");
                            S(this, "keylet");
                            S(this, "iv");
                            S(this, "encrypt");
                        }
                    };
                },
                8633: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Standard = void 0;
                    var a = o(6914);
                    i.Standard = class {
                        constructor(){
                            S(this, "type", a.AlgoTypes.standard);
                            S(this, "encrypt");
                        }
                    };
                },
                4575: function(s, i, f) {
                    var a = this && this.__createBinding || (Object.create ? function(p, m, x, _) {
                        _ === void 0 && (_ = x);
                        var v = Object.getOwnPropertyDescriptor(m, x);
                        v && ("get" in v ? m.__esModule : !v.writable && !v.configurable) || (v = {
                            enumerable: !0,
                            get: function() {
                                return m[x];
                            }
                        }), Object.defineProperty(p, _, v);
                    } : function(p, m, x, _) {
                        p[_ = _ === void 0 ? x : _] = m[x];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(p, m) {
                        Object.defineProperty(p, "default", {
                            enumerable: !0,
                            value: m
                        });
                    } : function(p, m) {
                        p.default = m;
                    }), h = this && this.__importStar || function(p) {
                        if (p && p.__esModule) return p;
                        var m = {};
                        if (p != null) for(var x in p)x !== "default" && Object.prototype.hasOwnProperty.call(p, x) && a(m, p, x);
                        return u(m, p), m;
                    }, c = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Types = void 0, f(1437)), l = h(f(2083)), d = h(f(4855)), h = h(f(2789)), f = f(2164);
                    class g {
                    }
                    S(g, "AllNetworks", c.AllNetworks), S(g, "AllNodeTypes", c.AllNetworks.AllNodeTypes), S(g, "AllNodeExplorers", c.AllNetworks.AllNodeExplorers), S(g, "AllProtocols", f.Protocols), S(g, "Api", l), S(g, "Card", d.Card), S(g, "Security", h.Security), S(g, "BasicNetwork"), S(g, "BasicUser"), S(g, "NodeTypes"), S(g, "NodeExplorers"), S(g, "Protocols"), S(g, "Networks"), S(g, "Icons"), S(g, "EncryptionTypes"), S(g, "EncryptTypes"), S(g, "CardEncryptionTypes"), S(g, "PasscodeEncryptionTypes"), S(g, "availableProtocols", [
                        f.Protocols.xrpl,
                        f.Protocols.evm
                    ]), S(g, "NetworkIdentifiers", {
                        [c.AllNetworks.NetworkLabels.xrpl]: c.AllNetworks.XrplLedger,
                        [c.AllNetworks.NetworkLabels.xevm]: c.AllNetworks.Xevm,
                        [c.AllNetworks.NetworkLabels.xahau]: c.AllNetworks.Xahau
                    }), i.Types = g;
                },
                8950: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.NetworkIcons = void 0, i.NetworkIcons = {
                        xrpl: "/assets/chains/xrpl/info/logo.png",
                        xevm: "/assets/chains/xevm/info/logo.jpg",
                        xahau: "/assets/chains/xahau/info/logo.jpg"
                    };
                },
                7782: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.NetworkLabels = void 0, i.NetworkLabels = {
                        xrpl: "xrp ledger",
                        xevm: "xevm sidechain",
                        xahau: "xahau"
                    };
                },
                1437: (s, i, d)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.AllNetworks = void 0;
                    var a = d(1396), u = d(1743), c = d(4942), l = d(8950), d = d(7782), h = a.XahauNetwork.NetworkTypes, f = u.XrplLedgerNetwork.NetworkTypes, g = c.XevmNetwork.NetworkTypes, p = a.XahauNetwork.Explorers, m = u.XrplLedgerNetwork.Explorers, x = c.XevmNetwork.Explorers;
                    class _ {
                    }
                    S(_, "Xahau", a.XahauNetwork), S(_, "XrplLedger", u.XrplLedgerNetwork), S(_, "Xevm", c.XevmNetwork), S(_, "AllNodeTypes", {
                        xahau: h,
                        xrpl: f,
                        xevm: g
                    }), S(_, "AllNodeExplorers", {
                        xahauExpl: p,
                        xrplExpl: m,
                        xevmExpl: x
                    }), S(_, "NetworkLabels", d.NetworkLabels), S(_, "NetworkIcons", l.NetworkIcons), i.AllNetworks = _;
                },
                1396: (s, i, l)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.XahauNetwork = void 0;
                    var a, u = l(2164), c = l(8950), l = l(7782);
                    class d {
                    }
                    S(d, "protocol", u.Protocols.xrpl), S(d, "Types"), S(d, "label", l.NetworkLabels.xahau), S(d, "icon", c.NetworkIcons.xahau), S(d, "asset", "XAH"), S(d, "active", !0), S(d, "defaultReserves", {
                        base: "1",
                        inc: "0.2"
                    }), i.XahauNetwork = d, a = d || (i.XahauNetwork = d = {}), (u = a.NetworkTypes || (a.NetworkTypes = {})).mainnet = "mainnet", u.testnet = "testnet", u.devnet = "devnet", (u = a.Explorers || (a.Explorers = {})).bithomp = "bithomp", u.xrplf = "xrplf", u.xrplorg = "xrpl.org", a.colors = {
                        [a.NetworkTypes.mainnet]: "tw-bg-[#38DBFF]",
                        [a.NetworkTypes.devnet]: "tw-bg-[#38FFDB]",
                        [a.NetworkTypes.testnet]: "tw-bg-[#DE7EFF]"
                    }, a.BithompHost = {
                        [a.NetworkTypes.mainnet]: "https://xahauexplorer.com",
                        [a.NetworkTypes.testnet]: "https://test.xahauexplorer.com",
                        [a.NetworkTypes.devnet]: ""
                    }, a.XrplfHost = {
                        [a.NetworkTypes.mainnet]: "https://explorer.xahau.network",
                        [a.NetworkTypes.testnet]: "https://explorer.xahau-test.net",
                        [a.NetworkTypes.devnet]: ""
                    }, a.XrplOrgHost = {
                        [a.NetworkTypes.mainnet]: "https://xahau.xrpl.org",
                        [a.NetworkTypes.testnet]: "https://xahau-testnet.xrpl.org",
                        [a.NetworkTypes.devnet]: ""
                    }, a.Hosts = {
                        [a.Explorers.bithomp]: a.BithompHost,
                        [a.Explorers.xrplf]: a.XrplfHost,
                        [a.Explorers.xrplorg]: a.XrplOrgHost
                    }, a.ExplorerAddressPath = {
                        [a.Explorers.bithomp]: "",
                        [a.Explorers.xrplf]: "/address",
                        [a.Explorers.xrplorg]: "/accounts"
                    }, a.ExplorerTxPath = {
                        [a.Explorers.bithomp]: "",
                        [a.Explorers.xrplf]: "/tx",
                        [a.Explorers.xrplorg]: "/transactions"
                    }, a.getExplorerHost = (h, f)=>h === a.Explorers.bithomp ? a.BithompHost[f] : h === a.Explorers.xrplf ? a.XrplfHost[f] : h === a.Explorers.xrplorg ? a.XrplOrgHost[f] : void 0, a.getExplorerPath = (h, f)=>f === "address" ? a.ExplorerAddressPath[h] : f === "tx" ? a.ExplorerTxPath[h] : void 0;
                },
                4942: (s, i, l)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.XevmNetwork = void 0;
                    var a, u = l(2164), c = l(8950), l = l(7782);
                    class d {
                    }
                    S(d, "protocol", u.Protocols.evm), S(d, "Types"), S(d, "label", l.NetworkLabels.xevm), S(d, "icon", c.NetworkIcons.xevm), S(d, "asset", "EXRP"), S(d, "active", !1), S(d, "defaultReserves", {
                        base: "0",
                        inc: "0"
                    }), i.XevmNetwork = d, a = d || (i.XevmNetwork = d = {}), (u = a.NetworkTypes || (a.NetworkTypes = {})).mainnet = "mainnet", u.testnet = "testnet", u.devnet = "devnet", (a.Explorers || (a.Explorers = {})).peersyst = "peersyst", a.colors = {
                        [a.NetworkTypes.mainnet]: "tw-bg-[#38DBFF]",
                        [a.NetworkTypes.testnet]: "tw-bg-[#DE7EFF]",
                        [a.NetworkTypes.devnet]: "tw-bg-[#FFB648]"
                    }, a.PeersysHost = {
                        [a.NetworkTypes.mainnet]: "",
                        [a.NetworkTypes.testnet]: "",
                        [a.NetworkTypes.devnet]: "https://evm-sidechain.xrpl.org"
                    }, a.Hosts = {
                        [a.Explorers.peersyst]: a.PeersysHost
                    }, a.ExplorerAddressPath = {
                        [a.Explorers.peersyst]: "/address"
                    }, a.ExplorerTxPath = {
                        [a.Explorers.peersyst]: "/tx"
                    }, a.getExplorerHost = (h, f)=>{
                        if (h === a.Explorers.peersyst) return a.PeersysHost[f];
                    }, a.getExplorerPath = (h, f)=>f === "address" ? a.ExplorerAddressPath[h] : f === "tx" ? a.ExplorerTxPath[h] : void 0;
                },
                1743: (s, i, l)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.XrplLedgerNetwork = void 0;
                    var a, u = l(2164), c = l(8950), l = l(7782);
                    class d {
                    }
                    S(d, "protocol", u.Protocols.xrpl), S(d, "Types"), S(d, "label", l.NetworkLabels.xrpl), S(d, "icon", c.NetworkIcons.xrpl), S(d, "asset", "XRP"), S(d, "active", !0), S(d, "defaultReserves", {
                        base: "10",
                        inc: "2"
                    }), i.XrplLedgerNetwork = d, a = d || (i.XrplLedgerNetwork = d = {}), (u = a.NetworkTypes || (a.NetworkTypes = {})).mainnet = "mainnet", u.testnet = "testnet", u.devnet = "devnet", u.xls30d = "xls30d", u.xls38d = "xls38d", (u = a.Explorers || (a.Explorers = {})).bithomp = "bithomp", u.xrplorg = "xrpl.org", u.xrplf = "xrplf", u.xrpscan = "xrpscan", a.colors = {
                        [a.NetworkTypes.mainnet]: "tw-bg-[#38DBFF]",
                        [a.NetworkTypes.testnet]: "tw-bg-[#DE7EFF]",
                        [a.NetworkTypes.devnet]: "tw-bg-[#FFB648]",
                        [a.NetworkTypes.xls30d]: "tw-bg-[#FF9C7C]",
                        [a.NetworkTypes.xls38d]: "tw-bg-[#C34D27]"
                    }, a.BithompHost = {
                        [a.NetworkTypes.mainnet]: "https://bithomp.com/explorer",
                        [a.NetworkTypes.testnet]: "https://test.bithomp.com/explorer",
                        [a.NetworkTypes.devnet]: "https://dev.bithomp.com/explorer",
                        [a.NetworkTypes.xls30d]: "https://amm.bithomp.com/explorer",
                        [a.NetworkTypes.xls38d]: ""
                    }, a.XrplfHost = {
                        [a.NetworkTypes.mainnet]: "https://explorer.xrplf.org",
                        [a.NetworkTypes.testnet]: "https://explorer-testnet.xrplf.org",
                        [a.NetworkTypes.devnet]: "",
                        [a.NetworkTypes.xls30d]: "",
                        [a.NetworkTypes.xls38d]: ""
                    }, a.XrplOrgHost = {
                        [a.NetworkTypes.mainnet]: "https://livenet.xrpl.org",
                        [a.NetworkTypes.testnet]: "https://testnet.xrpl.org",
                        [a.NetworkTypes.devnet]: "https://devnet.xrpl.org",
                        [a.NetworkTypes.xls30d]: "",
                        [a.NetworkTypes.xls38d]: ""
                    }, a.XRPScanHost = {
                        [a.NetworkTypes.mainnet]: "https://xrpscan.com",
                        [a.NetworkTypes.testnet]: "",
                        [a.NetworkTypes.devnet]: "",
                        [a.NetworkTypes.xls30d]: "",
                        [a.NetworkTypes.xls38d]: ""
                    }, a.Hosts = {
                        [a.Explorers.bithomp]: a.BithompHost,
                        [a.Explorers.xrplf]: a.XrplfHost,
                        [a.Explorers.xrplorg]: a.XrplOrgHost,
                        [a.Explorers.xrpscan]: a.XRPScanHost
                    }, a.ExplorerAddressPath = {
                        [a.Explorers.bithomp]: "",
                        [a.Explorers.xrplorg]: "/address",
                        [a.Explorers.xrplf]: "",
                        [a.Explorers.xrpscan]: "/account"
                    }, a.ExplorerTxPath = {
                        [a.Explorers.bithomp]: "",
                        [a.Explorers.xrplorg]: "/transactions",
                        [a.Explorers.xrplf]: "/tx",
                        [a.Explorers.xrpscan]: "/tx"
                    }, a.getExplorerHost = (h, f)=>h === a.Explorers.bithomp ? a.BithompHost[f] : h === a.Explorers.xrplf ? a.XrplfHost[f] : h === a.Explorers.xrplorg ? a.XrplOrgHost[f] : h === a.Explorers.xrpscan ? a.XRPScanHost[f] : void 0, a.getExplorerPath = (h, f)=>f === "address" ? a.ExplorerAddressPath[h] : f === "tx" ? a.ExplorerTxPath[h] : void 0;
                },
                2164: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Protocols = void 0, i.Protocols = {
                        xrpl: "XRPL",
                        evm: "EVM",
                        btc: "BTC",
                        bsc: "BSC",
                        ada: "ADA",
                        sol: "SOL",
                        usd: "USD"
                    };
                },
                2789: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Security = void 0;
                    const a = o(2625);
                    class u {
                    }
                    S(u, "EncryptTypes"), S(u, "AlgoTypes", o(6914).AlgoTypes), ((i.Security = u) || (i.Security = u = {})).AllEncryptionTypes = {
                        AES_CBC: a.AES_CBC,
                        AES_GCM: a.AES_GCM,
                        PBKDF2: a.PBKDF2,
                        Standard: a.Standard
                    };
                },
                7083: (s, i, o)=>{
                    var a;
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Types = void 0, o(4575).Types.Api.Types, i.Types = (a = class {
                    }, S(a, "AgreementsSchema"), S(a, "GeneralSchema"), S(a, "NodeSchema"), S(a, "CardSchema"), S(a, "ContactSchema"), S(a, "ProfileSchema"), S(a, "SecuritySchema"), S(a, "StateSchema"), S(a, "UserSchema"), S(a, "AppSchema"), S(a, "PreferenceSchema"), S(a, "VaultSchema"), S(a, "MountedUserSchema"), S(a, "SecurityTypes"), S(a, "SecurityLevel"), S(a, "Blank"), a);
                },
                191: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Apps = void 0;
                    class o {
                    }
                    S(o, "AppTitle"), S(o, "AppTypes"), i.Apps = o, (i = (i = o || (i.Apps = o = {})).titles || (i.titles = {})).crossmark = "crossmark", i.embark = "embark";
                },
                5659: function(s, i, p) {
                    var a = this && this.__createBinding || (Object.create ? function(x, _, v, N) {
                        N === void 0 && (N = v);
                        var O = Object.getOwnPropertyDescriptor(_, v);
                        O && ("get" in O ? _.__esModule : !O.writable && !O.configurable) || (O = {
                            enumerable: !0,
                            get: function() {
                                return _[v];
                            }
                        }), Object.defineProperty(x, N, O);
                    } : function(x, _, v, N) {
                        x[N = N === void 0 ? v : N] = _[v];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(x, _) {
                        Object.defineProperty(x, "default", {
                            enumerable: !0,
                            value: _
                        });
                    } : function(x, _) {
                        x.default = _;
                    }), g = this && this.__importStar || function(x) {
                        if (x && x.__esModule) return x;
                        var _ = {};
                        if (x != null) for(var v in x)v !== "default" && Object.prototype.hasOwnProperty.call(x, v) && a(_, x, v);
                        return u(_, x), _;
                    }, c = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Projects = i.BasicUser = i.BasicNetwork = i.Types = void 0, p(1437)), l = g(p(7083)), d = g(p(4855)), h = g(p(2789)), f = g(p(8084)), g = g(p(191)), p = p(2164);
                    class m {
                    }
                    S(m, "AllNetworks", c.AllNetworks), S(m, "AllNodeTypes", c.AllNetworks.AllNodeTypes), S(m, "AllNodeExplorers", c.AllNetworks.AllNodeExplorers), S(m, "Themes", f), S(m, "Apps", g), S(m, "AllProtocols", p.Protocols), S(m, "Api", l), S(m, "Card", d.Card), S(m, "Security", h.Security), S(m, "BasicNetwork"), S(m, "BasicUser"), S(m, "NodeTypes"), S(m, "NodeExplorers"), S(m, "Protocols"), S(m, "Networks"), S(m, "Icons"), S(m, "EncryptionTypes"), S(m, "EncryptTypes"), S(m, "CardEncryptionTypes"), S(m, "PasscodeEncryptionTypes"), S(m, "availableProtocols", [
                        p.Protocols.xrpl,
                        p.Protocols.evm
                    ]), S(m, "NetworkIdentifiers", {
                        [c.AllNetworks.NetworkLabels.xrpl]: c.AllNetworks.XrplLedger,
                        [c.AllNetworks.NetworkLabels.xevm]: c.AllNetworks.Xevm,
                        [c.AllNetworks.NetworkLabels.xahau]: c.AllNetworks.Xahau
                    }), i.Types = m, i.BasicNetwork = m.BasicNetwork, i.BasicUser = m.BasicUser, i.Projects = g.Apps;
                },
                8084: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Themes = void 0;
                    const a = o(191);
                    class u {
                    }
                    S(u, "ThemeTypes");
                    var c;
                    i.Themes = u, o = u || (i.Themes = u = {}), (c = i = o.availableThemes || (o.availableThemes = {})).theme1 = "theme1", c.theme2 = "theme2", c.theme3 = "theme3", c.theme4 = "theme4", c.theme5 = "theme5", c.theme6 = "theme6", o.DefaultThemes = {
                        [a.Apps.titles.crossmark]: i.theme1,
                        [a.Apps.titles.embark]: i.theme6
                    }, o.CrossmarkThemeKey = {
                        [i.theme1]: "light",
                        [i.theme2]: "dark",
                        [i.theme3]: "moon",
                        [i.theme4]: "sun",
                        [i.theme5]: "blueberry",
                        [i.theme6]: "treeberry"
                    }, o.EmbarkThemeKey = {
                        [i.theme1]: "",
                        [i.theme2]: "",
                        [i.theme3]: "",
                        [i.theme4]: "",
                        [i.theme5]: "",
                        [i.theme6]: "treeberry"
                    }, o.ThemeKey = {
                        [a.Apps.titles.crossmark]: o.CrossmarkThemeKey,
                        [a.Apps.titles.embark]: o.EmbarkThemeKey
                    }, o.ToastColor = {
                        [i.theme1]: "light",
                        [i.theme2]: "dark",
                        [i.theme3]: "light",
                        [i.theme4]: "light",
                        [i.theme5]: "dark",
                        [i.theme6]: "dark"
                    }, o.SpinnerColor = {
                        [i.theme1]: "black",
                        [i.theme2]: "white",
                        [i.theme3]: "black",
                        [i.theme4]: "black",
                        [i.theme5]: "light",
                        [i.theme6]: "light"
                    };
                },
                2876: function(s, i, l) {
                    var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
                        p === void 0 && (p = g);
                        var m = Object.getOwnPropertyDescriptor(f, g);
                        m && ("get" in m ? f.__esModule : !m.writable && !m.configurable) || (m = {
                            enumerable: !0,
                            get: function() {
                                return f[g];
                            }
                        }), Object.defineProperty(h, p, m);
                    } : function(h, f, g, p) {
                        h[p = p === void 0 ? g : p] = f[g];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
                        Object.defineProperty(h, "default", {
                            enumerable: !0,
                            value: f
                        });
                    } : function(h, f) {
                        h.default = f;
                    }), c = this && this.__importStar || function(h) {
                        if (h && h.__esModule) return h;
                        var f = {};
                        if (h != null) for(var g in h)g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
                        return u(f, h), f;
                    }, c = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Types = void 0, c(l(4080))), l = l(5659).Types.Api.Types;
                    class d {
                    }
                    S(d, "AgreementsSchema"), S(d, "GeneralSchema"), S(d, "NodeSchema"), S(d, "ContactSchema"), S(d, "ProfileSchema"), S(d, "AppSchema"), S(d, "PreferenceSchema"), S(d, "VaultSchema"), S(d, "CardSchema"), S(d, "StateSchema"), S(d, "SecuritySchema"), S(d, "UserSchema"), S(d, "MountedUserSchema"), S(d, "SecurityTypes", c), S(d, "SecurityLevel", l.SecurityLevel), S(d, "Blank"), i.Types = d;
                },
                43: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Apps = void 0;
                    class o {
                    }
                    S(o, "AppTitle"), S(o, "AppTypes"), i.Apps = o, (i = (i = o || (i.Apps = o = {})).titles || (i.titles = {})).crossmark = "crossmark", i.embark = "embark";
                },
                9455: (s, i)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Index = void 0, i.Index = class {
                        constructor(){
                            S(this, "algo");
                            S(this, "type");
                            S(this, "opts");
                        }
                    };
                },
                3710: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.HashTypes = i.AesTypes = i.Standard = i.Pbkdf2 = i.hash = i.aes = void 0;
                    var a = o(9455);
                    Object.defineProperty(i, "aes", {
                        enumerable: !0,
                        get: function() {
                            return a.Index;
                        }
                    });
                    const u = o(1261), c = (Object.defineProperty(i, "Standard", {
                        enumerable: !0,
                        get: function() {
                            return u.Index;
                        }
                    }), o(4483));
                    Object.defineProperty(i, "Pbkdf2", {
                        enumerable: !0,
                        get: function() {
                            return c.Index;
                        }
                    }), i.hash = {
                        Pbkdf2: c.Index,
                        Standard: u.Index
                    }, i.AesTypes = {
                        cbc: "aes-cbc",
                        gcm: "aes-gcm",
                        ctr: "aes-ctr",
                        cfb: "aes-cfb",
                        ecb: "aes-ecb",
                        ofb: "aes-ofb"
                    }, i.HashTypes = {
                        standard: "hmac256",
                        pbkdf2: "pbkdf2"
                    };
                },
                4483: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Index = void 0;
                    var a = o(3710);
                    i.Index = class {
                        constructor(){
                            S(this, "type", a.HashTypes.pbkdf2);
                            S(this, "opts");
                            S(this, "make");
                        }
                    };
                },
                1261: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Index = void 0;
                    var a = o(3710);
                    i.Index = class {
                        constructor(){
                            S(this, "type", a.HashTypes.standard);
                            S(this, "make");
                        }
                    };
                },
                5541: function(s, i, p) {
                    var a = this && this.__createBinding || (Object.create ? function(x, _, v, N) {
                        N === void 0 && (N = v);
                        var O = Object.getOwnPropertyDescriptor(_, v);
                        O && ("get" in O ? _.__esModule : !O.writable && !O.configurable) || (O = {
                            enumerable: !0,
                            get: function() {
                                return _[v];
                            }
                        }), Object.defineProperty(x, N, O);
                    } : function(x, _, v, N) {
                        x[N = N === void 0 ? v : N] = _[v];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(x, _) {
                        Object.defineProperty(x, "default", {
                            enumerable: !0,
                            value: _
                        });
                    } : function(x, _) {
                        x.default = _;
                    }), g = this && this.__importStar || function(x) {
                        if (x && x.__esModule) return x;
                        var _ = {};
                        if (x != null) for(var v in x)v !== "default" && Object.prototype.hasOwnProperty.call(x, v) && a(_, x, v);
                        return u(_, x), _;
                    }, c = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.AllHashTypes = i.AllEncryptionTypes = i.Projects = i.BasicUser = i.BasicNetwork = i.Types = void 0, p(1437)), l = g(p(2876)), d = g(p(4855)), h = g(p(4080)), f = g(p(2897)), g = g(p(43)), p = p(2164);
                    class m {
                    }
                    S(m, "AllNetworks", c.AllNetworks), S(m, "AllNodeTypes", c.AllNetworks.AllNodeTypes), S(m, "AllNodeExplorers", c.AllNetworks.AllNodeExplorers), S(m, "Themes", f), S(m, "Apps", g), S(m, "AllProtocols", p.Protocols), S(m, "Api", l), S(m, "Card", d.Card), S(m, "Security", h), S(m, "BasicNetwork"), S(m, "BasicUser"), S(m, "NodeTypes"), S(m, "NodeExplorers"), S(m, "Protocols"), S(m, "Networks"), S(m, "Icons"), S(m, "EncryptionTypes"), S(m, "EncryptTypes"), S(m, "HashTypes"), S(m, "CardEncryptionTypes"), S(m, "PasscodeHashTypes"), S(m, "availableProtocols", [
                        p.Protocols.xrpl,
                        p.Protocols.evm
                    ]), S(m, "NetworkIdentifiers", {
                        [c.AllNetworks.NetworkLabels.xrpl]: c.AllNetworks.XrplLedger,
                        [c.AllNetworks.NetworkLabels.xevm]: c.AllNetworks.Xevm,
                        [c.AllNetworks.NetworkLabels.xahau]: c.AllNetworks.Xahau
                    }), i.Types = m, i.BasicNetwork = m.BasicNetwork, i.BasicUser = m.BasicUser, i.Projects = g.Apps, i.AllEncryptionTypes = h.AllEncryptionTypes, i.AllHashTypes = h.AllHashTypes;
                },
                4080: function(s, i, o) {
                    var a = this && this.__createBinding || (Object.create ? function(l, d, h, f) {
                        f === void 0 && (f = h);
                        var g = Object.getOwnPropertyDescriptor(d, h);
                        g && ("get" in g ? d.__esModule : !g.writable && !g.configurable) || (g = {
                            enumerable: !0,
                            get: function() {
                                return d[h];
                            }
                        }), Object.defineProperty(l, f, g);
                    } : function(l, d, h, f) {
                        l[f = f === void 0 ? h : f] = d[h];
                    }), u = this && this.__setModuleDefault || (Object.create ? function(l, d) {
                        Object.defineProperty(l, "default", {
                            enumerable: !0,
                            value: d
                        });
                    } : function(l, d) {
                        l.default = d;
                    }), c = this && this.__importStar || function(l) {
                        if (l && l.__esModule) return l;
                        var d = {};
                        if (l != null) for(var h in l)h !== "default" && Object.prototype.hasOwnProperty.call(l, h) && a(d, l, h);
                        return u(d, l), d;
                    }, c = (Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.AllHashTypes = i.AllEncryptionTypes = void 0, c(o(3710)));
                    i.AllEncryptionTypes = {
                        AES_CBC: c.AesTypes.cbc,
                        AES_GCM: c.AesTypes.gcm,
                        AES_CTR: c.AesTypes.ctr,
                        AES_ECB: c.AesTypes.ecb,
                        AES_OFB: c.AesTypes.ofb,
                        AES_CFB: c.AesTypes.cfb
                    }, i.AllHashTypes = {
                        PBKDF2: c.HashTypes.pbkdf2,
                        Standard: c.HashTypes.standard
                    };
                },
                2897: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.Themes = void 0;
                    const a = o(43);
                    class u {
                    }
                    S(u, "ThemeTypes");
                    var c;
                    i.Themes = u, o = u || (i.Themes = u = {}), (c = i = o.availableThemes || (o.availableThemes = {})).theme1 = "theme1", c.theme2 = "theme2", c.theme3 = "theme3", c.theme4 = "theme4", c.theme5 = "theme5", c.theme6 = "theme6", o.DefaultThemes = {
                        [a.Apps.titles.crossmark]: i.theme1,
                        [a.Apps.titles.embark]: i.theme6
                    }, o.CrossmarkThemeKey = {
                        [i.theme1]: "light",
                        [i.theme2]: "dark",
                        [i.theme3]: "moon",
                        [i.theme4]: "sun",
                        [i.theme5]: "blueberry",
                        [i.theme6]: "treeberry"
                    }, o.EmbarkThemeKey = {
                        [i.theme1]: "",
                        [i.theme2]: "",
                        [i.theme3]: "",
                        [i.theme4]: "",
                        [i.theme5]: "",
                        [i.theme6]: "treeberry"
                    }, o.ThemeKey = {
                        [a.Apps.titles.crossmark]: o.CrossmarkThemeKey,
                        [a.Apps.titles.embark]: o.EmbarkThemeKey
                    }, o.ToastColor = {
                        [i.theme1]: "light",
                        [i.theme2]: "dark",
                        [i.theme3]: "light",
                        [i.theme4]: "light",
                        [i.theme5]: "dark",
                        [i.theme6]: "dark"
                    }, o.SpinnerColor = {
                        [i.theme1]: "black",
                        [i.theme2]: "white",
                        [i.theme3]: "black",
                        [i.theme4]: "black",
                        [i.theme5]: "light",
                        [i.theme6]: "light"
                    };
                },
                9815: (s, i, o)=>{
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    }), i.HashTypes = i.EncryptionAlgos = i.Projects = i.BasicUser = i.BasicNetwork = i.CatchAllEvent = i.TYPES = i.COMMANDS = i.EVENTS = i.Events = i.Models = i.Config = void 0;
                    var a = o(2025), u = (Object.defineProperty(i, "Config", {
                        enumerable: !0,
                        get: function() {
                            return a.Config;
                        }
                    }), o(9291)), c = (Object.defineProperty(i, "Models", {
                        enumerable: !0,
                        get: function() {
                            return u.Models;
                        }
                    }), o(7268)), l = (Object.defineProperty(i, "Events", {
                        enumerable: !0,
                        get: function() {
                            return c.Events;
                        }
                    }), o(4151)), d = (Object.defineProperty(i, "EVENTS", {
                        enumerable: !0,
                        get: function() {
                            return l.EVENTS;
                        }
                    }), Object.defineProperty(i, "COMMANDS", {
                        enumerable: !0,
                        get: function() {
                            return l.COMMANDS;
                        }
                    }), Object.defineProperty(i, "TYPES", {
                        enumerable: !0,
                        get: function() {
                            return l.TYPES;
                        }
                    }), Object.defineProperty(i, "CatchAllEvent", {
                        enumerable: !0,
                        get: function() {
                            return l.CatchAllEvent;
                        }
                    }), o(5541));
                    Object.defineProperty(i, "BasicNetwork", {
                        enumerable: !0,
                        get: function() {
                            return d.BasicNetwork;
                        }
                    }), Object.defineProperty(i, "BasicUser", {
                        enumerable: !0,
                        get: function() {
                            return d.BasicUser;
                        }
                    }), Object.defineProperty(i, "Projects", {
                        enumerable: !0,
                        get: function() {
                            return d.Projects;
                        }
                    }), Object.defineProperty(i, "EncryptionAlgos", {
                        enumerable: !0,
                        get: function() {
                            return d.AllEncryptionTypes;
                        }
                    }), Object.defineProperty(i, "HashTypes", {
                        enumerable: !0,
                        get: function() {
                            return d.AllHashTypes;
                        }
                    });
                }
            }, n = {};
            return function s(i) {
                var o = n[i];
                return o === void 0 && (o = n[i] = {
                    exports: {}
                }, t[i].call(o.exports, o, o.exports, s)), o.exports;
            }(4240);
        })());
})(ty);
var Nv = ty.exports;
const Po = /* @__PURE__ */ Di(Nv);
class xv {
    constructor(e = {}){
        this.id = "crossmark", this.name = "Crossmark", this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjE1MCIgaGVpZ2h0PSIxNDgiPgo8cGF0aCBkPSJNMCAwIEM0OS41IDAgOTkgMCAxNTAgMCBDMTUwIDQ4Ljg0IDE1MCA5Ny42OCAxNTAgMTQ4IEMxMDAuNSAxNDggNTEgMTQ4IDAgMTQ4IEMwIDk5LjE2IDAgNTAuMzIgMCAwIFogIiBmaWxsPSIjRTE0QzQ3IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDApIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuMTU0NTE2NSAxLjM0NDczMTcyIDUuODE3Mjg5NzcgMy4zMDUxNTA3OSA4LjU3NDIxODc1IDUuMzEyNSBDMTkuNzIxNjI5NDEgMTMuMzg2NTU5MTIgMjguNzgyNDI2MTMgMTQuNjU0ODMzNDcgNDIuMTk5MjE4NzUgMTMuOTM3NSBDNTAuNTE1OTg5OTcgMTIuNTE1MjExNTkgNTguMzgzMTU2NzYgNy41OTg0NjY2MyA2NC41NzQyMTg3NSAyIEM2Ny4xOTkyMTg3NSAtMC4wNjI1IDY3LjE5OTIxODc1IC0wLjA2MjUgNjkuMTU2MjUgMC4xMzY3MTg3NSBDNzEuNDIzOTM1NzIgMS4wMjU1ODIxOCA3Mi43NjEwMjIyNyAyLjAwMTk2NTkyIDc0LjUxMTcxODc1IDMuNjg3NSBDNzUuMzEwMjkyOTcgNC40MjIyNjU2MyA3NS4zMTAyOTI5NyA0LjQyMjI2NTYzIDc2LjEyNSA1LjE3MTg3NSBDNzcuMTk5MjE4NzUgNi45Mzc1IDc3LjE5OTIxODc1IDYuOTM3NSA3Ny4xNDA2MjUgOS4yMTQ4NDM3NSBDNzUuNjgzMDU4OCAxMy40MzAyOTQ1NSA3My4xMjc0ODczOSAxNi44NjQ0NjQ1NyA3MC42MTMyODEyNSAyMC41MDE5NTMxMiBDNjUuNjQ0Nzg3OTggMjcuODk3NDg5OTkgNjMuNjQ1Nzk5NDkgMzQuMzg5NDEyNDEgNjMuNzYxNzE4NzUgNDMuMzEyNSBDNjMuNzc2MzQxNTUgNDQuNTcyNDc4MDMgNjMuNzc2MzQxNTUgNDQuNTcyNDc4MDMgNjMuNzkxMjU5NzcgNDUuODU3OTEwMTYgQzY0LjA5MjU1MDcxIDU2LjM4Nzc3MzE5IDY3LjkyODcwODczIDYzLjIzNzYwNTk3IDc0LjI4ODgxODM2IDcxLjM4NjIzMDQ3IEM3Ni4xODQ1NDY3MSA3My45MDk5NDU4IDc3LjIxMTYzNjA1IDc1LjQwNTg4NDQzIDc3LjEzNjcxODc1IDc4LjYxMzI4MTI1IEM3Ni4xNTk2MjEwOCA4MS4wMzU2NjkyMiA3NS4yMjg5ODA2OCA4Mi40NzQ5MDIwMyA3My4zODY3MTg3NSA4NC4zMTI1IEM3Mi44ODUyNzM0NCA4NC44MzU4NTkzNyA3Mi4zODM4MjgxMiA4NS4zNTkyMTg3NSA3MS44NjcxODc1IDg1Ljg5ODQzNzUgQzcwLjE5OTIxODc1IDg2LjkzNzUgNzAuMTk5MjE4NzUgODYuOTM3NSA2OC4yODkwNjI1IDg2LjgwNDY4NzUgQzY1LjczNzc1NjY4IDg1Ljc0NjAxNDgxIDYzLjc4NTM0MDkxIDg0LjM0NDA0MTAzIDYxLjU3NDIxODc1IDgyLjY4NzUgQzQ5LjgzNTgyNzgyIDc0LjI3MzI1NTE3IDM5LjU2MzA4NzIxIDcxLjkzMTg3OTEyIDI1LjE5OTIxODc1IDcyLjkzNzUgQzE3LjcyNDQ2NzQ4IDc0LjQzNjc2NDY4IDExLjg5MzA0NiA3OS4wNDU3OTE2NiA2LjAxOTI4NzExIDgzLjY3MTM4NjcyIEMxLjc0NTc1MTM4IDg2Ljk0NjIwNTgzIDEuNzQ1NzUxMzggODYuOTQ2MjA1ODMgLTEuMDA3ODEyNSA4Ni45MDIzNDM3NSBDLTIuOTg4MDU0NTYgODUuODM2NzIzMyAtNC40OTE1OTEwNSA4NC43NDg4Mjk1MiAtNi4xMTMyODEyNSA4My4xODc1IEMtNi42NDU2NjQwNiA4Mi42OTc2NTYyNSAtNy4xNzgwNDY4NyA4Mi4yMDc4MTI1IC03LjcyNjU2MjUgODEuNzAzMTI1IEMtOC44MDA3ODEyNSA3OS45Mzc1IC04LjgwMDc4MTI1IDc5LjkzNzUgLTguNzA3MDMxMjUgNzcuNTYyNSBDLTcuNjE1MTk1OTcgNzQuMzk5OTQyNjMgLTYuMDU3NDk4MDMgNzIuMzEzMzcwNjUgLTMuOTg4MjgxMjUgNjkuNjg3NSBDMy44MTAzMTMyNSA1OS4zMDMzNDk5OCA2LjA2Nzg2NDI3IDQ5Ljg2ODg0NTUzIDUuMTk5MjE4NzUgMzYuOTM3NSBDMy43MTgyNjUxNSAyNy44NDc5Nzc0MiAtMS4yMTI1NjMxMyAyMC4yNjYxNDQwOCAtNy4wMTU2MjUgMTMuMjY1NjI1IEMtOC44MDA3ODEyNSAxMC45Mzc1IC04LjgwMDc4MTI1IDEwLjkzNzUgLTguOTI1NzgxMjUgOC41IEMtNy4zNDk5MTAxNyA0LjkxMDUxNTg3IC00LjM4MzcwMTUxIC0wLjE1MjE0NTgyIDAgMCBaICIgZmlsbD0iI0UyNEU0NyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDAuODAwNzgxMjUsMzIuMDYyNSkiLz4KPHBhdGggZD0iTTAgMCBDMy4xNTQ1MTY1IDEuMzQ0NzMxNzIgNS44MTcyODk3NyAzLjMwNTE1MDc5IDguNTc0MjE4NzUgNS4zMTI1IEMxOS43MjE2Mjk0MSAxMy4zODY1NTkxMiAyOC43ODI0MjYxMyAxNC42NTQ4MzM0NyA0Mi4xOTkyMTg3NSAxMy45Mzc1IEM1MC41MTU5ODk5NyAxMi41MTUyMTE1OSA1OC4zODMxNTY3NiA3LjU5ODQ2NjYzIDY0LjU3NDIxODc1IDIgQzY3LjE5OTIxODc1IC0wLjA2MjUgNjcuMTk5MjE4NzUgLTAuMDYyNSA2OS4xNTYyNSAwLjEzNjcxODc1IEM3MS40MjM5MzU3MiAxLjAyNTU4MjE4IDcyLjc2MTAyMjI3IDIuMDAxOTY1OTIgNzQuNTExNzE4NzUgMy42ODc1IEM3NS4zMTAyOTI5NyA0LjQyMjI2NTYzIDc1LjMxMDI5Mjk3IDQuNDIyMjY1NjMgNzYuMTI1IDUuMTcxODc1IEM3Ny4xOTkyMTg3NSA2LjkzNzUgNzcuMTk5MjE4NzUgNi45Mzc1IDc3LjE0MDYyNSA5LjIxNDg0Mzc1IEM3NS42ODMwNTg4IDEzLjQzMDI5NDU1IDczLjEyNzQ4NzM5IDE2Ljg2NDQ2NDU3IDcwLjYxMzI4MTI1IDIwLjUwMTk1MzEyIEM2NS42NDQ3ODc5OCAyNy44OTc0ODk5OSA2My42NDU3OTk0OSAzNC4zODk0MTI0MSA2My43NjE3MTg3NSA0My4zMTI1IEM2My43NzYzNDE1NSA0NC41NzI0NzgwMyA2My43NzYzNDE1NSA0NC41NzI0NzgwMyA2My43OTEyNTk3NyA0NS44NTc5MTAxNiBDNjQuMDkyNTUwNzEgNTYuMzg3NzczMTkgNjcuOTI4NzA4NzMgNjMuMjM3NjA1OTcgNzQuMjg4ODE4MzYgNzEuMzg2MjMwNDcgQzc2LjE4NDU0NjcxIDczLjkwOTk0NTggNzcuMjExNjM2MDUgNzUuNDA1ODg0NDMgNzcuMTM2NzE4NzUgNzguNjEzMjgxMjUgQzc2LjE1OTYyMTA4IDgxLjAzNTY2OTIyIDc1LjIyODk4MDY4IDgyLjQ3NDkwMjAzIDczLjM4NjcxODc1IDg0LjMxMjUgQzcyLjg4NTI3MzQ0IDg0LjgzNTg1OTM3IDcyLjM4MzgyODEyIDg1LjM1OTIxODc1IDcxLjg2NzE4NzUgODUuODk4NDM3NSBDNzAuMTk5MjE4NzUgODYuOTM3NSA3MC4xOTkyMTg3NSA4Ni45Mzc1IDY4LjI4OTA2MjUgODYuODA0Njg3NSBDNjUuNzM3NzU2NjggODUuNzQ2MDE0ODEgNjMuNzg1MzQwOTEgODQuMzQ0MDQxMDMgNjEuNTc0MjE4NzUgODIuNjg3NSBDNDkuODM1ODI3ODIgNzQuMjczMjU1MTcgMzkuNTYzMDg3MjEgNzEuOTMxODc5MTIgMjUuMTk5MjE4NzUgNzIuOTM3NSBDMTcuNzI0NDY3NDggNzQuNDM2NzY0NjggMTEuODkzMDQ2IDc5LjA0NTc5MTY2IDYuMDE5Mjg3MTEgODMuNjcxMzg2NzIgQzEuNzQ1NzUxMzggODYuOTQ2MjA1ODMgMS43NDU3NTEzOCA4Ni45NDYyMDU4MyAtMS4wMDc4MTI1IDg2LjkwMjM0Mzc1IEMtMi45ODgwNTQ1NiA4NS44MzY3MjMzIC00LjQ5MTU5MTA1IDg0Ljc0ODgyOTUyIC02LjExMzI4MTI1IDgzLjE4NzUgQy02LjY0NTY2NDA2IDgyLjY5NzY1NjI1IC03LjE3ODA0Njg3IDgyLjIwNzgxMjUgLTcuNzI2NTYyNSA4MS43MDMxMjUgQy04LjgwMDc4MTI1IDc5LjkzNzUgLTguODAwNzgxMjUgNzkuOTM3NSAtOC43MDcwMzEyNSA3Ny41NjI1IEMtNy42MTUxOTU5NyA3NC4zOTk5NDI2MyAtNi4wNTc0OTgwMyA3Mi4zMTMzNzA2NSAtMy45ODgyODEyNSA2OS42ODc1IEMzLjgxMDMxMzI1IDU5LjMwMzM0OTk4IDYuMDY3ODY0MjcgNDkuODY4ODQ1NTMgNS4xOTkyMTg3NSAzNi45Mzc1IEMzLjcxODI2NTE1IDI3Ljg0Nzk3NzQyIC0xLjIxMjU2MzEzIDIwLjI2NjE0NDA4IC03LjAxNTYyNSAxMy4yNjU2MjUgQy04LjgwMDc4MTI1IDEwLjkzNzUgLTguODAwNzgxMjUgMTAuOTM3NSAtOC45MjU3ODEyNSA4LjUgQy03LjM0OTkxMDE3IDQuOTEwNTE1ODcgLTQuMzgzNzAxNTEgLTAuMTUyMTQ1ODIgMCAwIFogTS0wLjgwMDc4MTI1IDUuOTM3NSBDLTEuNDYwNzgxMjUgNi41OTc1IC0yLjEyMDc4MTI1IDcuMjU3NSAtMi44MDA3ODEyNSA3LjkzNzUgQy0yLjQ2MzgxNTI5IDExLjU2NTc2MTM1IC0wLjUxMTgyNzg0IDE0LjA1Nzg0MTI1IDEuNTExNzE4NzUgMTcgQzguMzE5MDQ1NjggMjcuNDI3NjUwNyAxMS42ODQ1MDAzOCAzOC40ODQ1NjM1IDkuNzM4MjgxMjUgNTAuODcxMDkzNzUgQzcuODQ2Nzc0NjggNTkuNDI3Mzc5MzUgNC40NTQ1MTI1NyA2Ny4wOTc5MjI2NyAtMS4yMzgyODEyNSA3My44MTI1IEMtMy4xMTg0ODE1IDc1Ljg3ODc2MTMyIC0zLjExODQ4MTUgNzUuODc4NzYxMzIgLTIuNTUwNzgxMjUgNzguNzUgQy0yLjMwMzI4MTI1IDc5LjQ3MTg3NSAtMi4wNTU3ODEyNSA4MC4xOTM3NSAtMS44MDA3ODEyNSA4MC45Mzc1IEMyLjMwMjQ2NDg1IDgwLjM5Mzc4MzY0IDQuNTgyNjIwNyA3OS4xNTY0ODIwOSA3LjgyNDIxODc1IDc2LjYyNSBDMTIuOTc1NTQxODYgNzIuODYzODM5MDUgMTguMTQyMTgyMDcgNzAuODEyMDU3MTEgMjQuMTk5MjE4NzUgNjguOTM3NSBDMjUuNjg0MjE4NzUgNjguNDQyNSAyNS42ODQyMTg3NSA2OC40NDI1IDI3LjE5OTIxODc1IDY3LjkzNzUgQzQxLjYyMjg4NzM4IDY2Ljk5MzQ4NTE2IDUyLjYwNzczOTY1IDcwLjA1NTgyMzY4IDY0LjEzNjcxODc1IDc4Ljg3NSBDNjYuODgxNTA4MyA4MS4xODkzMDk5NSA2Ni44ODE1MDgzIDgxLjE4OTMwOTk1IDY5LjMyODEyNSA4MC43NTM5MDYyNSBDNjkuOTQ1NTg1OTQgODAuNDg0NDkyMTkgNzAuNTYzMDQ2ODcgODAuMjE1MDc4MTMgNzEuMTk5MjE4NzUgNzkuOTM3NSBDNzEuNjk0MjE4NzUgNzguNDUyNSA3MS42OTQyMTg3NSA3OC40NTI1IDcyLjE5OTIxODc1IDc2LjkzNzUgQzcwLjg3ODUwNTUzIDc0LjY0NDg4NDk2IDY5LjUyMDE2NjgxIDcyLjUzNzQ2NDU0IDY4LjAxMTcxODc1IDcwLjM3NSBDNTkuNzUyMjc2ODkgNTcuODgyODkzNDQgNTcuNTcyNTQ5OTQgNDcuNjU4MjI5NyA1OS42MzY3MTg3NSAzMi43ODUxNTYyNSBDNjEuMDgzNzEzODUgMjYuNDgxNjgzODMgNjQuMDI1NDE3MTQgMjEuNTQ4NDE4NzkgNjcuNjc1NzgxMjUgMTYuMjUgQzY5LjM0MzIxNDk5IDEzLjkzNTIyNjY2IDY5LjM0MzIxNDk5IDEzLjkzNTIyNjY2IDcwLjE5OTIxODc1IDEwLjkzNzUgQzcwLjg1OTIxODc1IDEwLjkzNzUgNzEuNTE5MjE4NzUgMTAuOTM3NSA3Mi4xOTkyMTg3NSAxMC45Mzc1IEM3MS43MDQyMTg3NSA4Ljk1NzUgNzEuNzA0MjE4NzUgOC45NTc1IDcxLjE5OTIxODc1IDYuOTM3NSBDNjkuNDQwMzUwMDQgNi4xMzIxNzA4OCA2OS40NDAzNTAwNCA2LjEzMjE3MDg4IDY3LjE5OTIxODc1IDUuOTM3NSBDNjQuODM0MzUyMjkgNy4yMTc4MDQ2IDY0LjgzNDM1MjI5IDcuMjE3ODA0NiA2Mi41MTE3MTg3NSA5LjEyNSBDNTcuOTQ3MzMxODUgMTIuNDk5NTU0MDggNTMuNTA2NTE0NzYgMTQuOTUxOTY5MDUgNDguMTk5MjE4NzUgMTYuOTM3NSBDNDcuMjg5MTQwNjMgMTcuMjkzMjgxMjUgNDYuMzc5MDYyNSAxNy42NDkwNjI1IDQ1LjQ0MTQwNjI1IDE4LjAxNTYyNSBDMzUuNzQxNTkwMzQgMjAuNzczNjQ0OTQgMjUuMDE5Mzc3NDIgMTkuODU3MjIxMjEgMTUuOTkyMTg3NSAxNS41MTE3MTg3NSBDMTIuMDQ4ODgzNTkgMTMuMjg5MTI5MjggOC4yMjc0ODUxNSAxMC45MjQyODc4OCA0LjQ3NjU2MjUgOC4zOTA2MjUgQzIuMTgyMDUzMzkgNi43OTYzNzg4IDIuMTgyMDUzMzkgNi43OTYzNzg4IC0wLjgwMDc4MTI1IDUuOTM3NSBaICIgZmlsbD0iI0Y5RURFRCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDAuODAwNzgxMjUsMzIuMDYyNSkiLz4KPHBhdGggZD0iTTAgMCBDMC41ODEzNjcxOSAwLjIzMDc0MjE5IDEuMTYyNzM0MzcgMC40NjE0ODQzNyAxLjc2MTcxODc1IDAuNjk5MjE4NzUgQzAuNjc4OTA2MjUgMS41MDM1OTM3NSAwLjY3ODkwNjI1IDEuNTAzNTkzNzUgLTAuNDI1NzgxMjUgMi4zMjQyMTg3NSBDLTMuNDg2MTIzMjUgNC45MDg1MDc1NSAtNS43NTA0ODEzNiA3LjU3MTY5ODg5IC04LjIzODI4MTI1IDEwLjY5OTIxODc1IEMtOC45Mzc1IDguOTM3NSAtOC45Mzc1IDguOTM3NSAtOS4yMzgyODEyNSA2LjY5OTIxODc1IEMtNy45NDUzMTI1IDQuNzQyMTg3NSAtNy45NDUzMTI1IDQuNzQyMTg3NSAtNi4wNTA3ODEyNSAyLjg4NjcxODc1IEMtNS40Mzg0NzY1NiAyLjI2MTUyMzQ0IC00LjgyNjE3MTg4IDEuNjM2MzI4MTIgLTQuMTk1MzEyNSAwLjk5MjE4NzUgQy0yLjIzODI4MTI1IC0wLjMwMDc4MTI1IC0yLjIzODI4MTI1IC0wLjMwMDc4MTI1IDAgMCBaICIgZmlsbD0iI0Y1REFERSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDEuMjM4MjgxMjUsMzIuMzAwNzgxMjUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIuMzEgMCA0LjYyIDAgNyAwIEM2LjAyNDMzODg4IDEuMTY5NTk5ODcgNS4wNDQzNzUgMi4zMzU2MTE3NyA0LjA2MjUgMy41IEMzLjUxNzIyNjU2IDQuMTQ5Njg3NSAyLjk3MTk1MzEyIDQuNzk5Mzc1IDIuNDEwMTU2MjUgNS40Njg3NSBDMS45NDQ4MDQ2OSA1Ljk3NDA2MjUgMS40Nzk0NTMxMyA2LjQ3OTM3NSAxIDcgQzAuNjcgNyAwLjM0IDcgMCA3IEMwIDQuNjkgMCAyLjM4IDAgMCBaICIgZmlsbD0iIzFDMUIyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwwKSIvPgo8cGF0aCBkPSJNMCAwIEMyLjMxIDAgNC42MiAwIDcgMCBDNyAxLjk4IDcgMy45NiA3IDYgQzUuODMwNTQyMDggNS4xOTE1MjI3MSA0LjY2NDQ5NTM5IDQuMzc4MTA4ODggMy41IDMuNTYyNSBDMi44NTAzMTI1IDMuMTEwMDM5MDYgMi4yMDA2MjUgMi42NTc1NzgxMiAxLjUzMTI1IDIuMTkxNDA2MjUgQzEuMDI1OTM3NSAxLjc5ODI0MjE5IDAuNTIwNjI1IDEuNDA1MDc4MTIgMCAxIEMwIDAuNjcgMCAwLjM0IDAgMCBaICIgZmlsbD0iIzI2MjEyMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQzLDApIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuNjYgMC4zMyAxLjMyIDAuNjYgMiAxIEMtMC42NCAzLjY0IC0zLjI4IDYuMjggLTYgOSBDLTYgNiAtNiA2IC0zLjU2MjUgMy4zNzUgQy0yLjcxNjg3NSAyLjU5MTI1IC0xLjg3MTI1IDEuODA3NSAtMSAxIEMtMC42NyAwLjY3IC0wLjM0IDAuMzQgMCAwIFogIiBmaWxsPSIjQkYzNTUzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3LDApIi8+Cjwvc3ZnPgo=", this.url = "https://crossmark.io", this.currentAccount = null;
    }
    /**
   * Check if Crossmark is installed
   */ async isAvailable() {
        try {
            return !!Po.sync.isInstalled();
        } catch  {
            return !1;
        }
    }
    /**
   * Connect to Crossmark wallet
   */ async connect(e) {
        try {
            if (!await this.isAvailable()) throw ge.notInstalled(this.name);
            const n = this.resolveNetwork(e == null ? void 0 : e.network), s = this.generateRandomHash(), i = await Po.methods.signInAndWait(s);
            if (!i || !i.response || !i.response.data) throw new Error("Failed to sign in with Crossmark");
            const { address: o, publicKey: a } = i.response.data;
            if (!o) throw new Error("No address returned from Crossmark");
            return this.currentAccount = {
                address: o,
                publicKey: a,
                network: n
            }, this.currentAccount;
        } catch (t) {
            throw ge.connectionFailed(this.name, t);
        }
    }
    /**
   * Disconnect from Crossmark
   */ async disconnect() {
        this.currentAccount = null;
    }
    /**
   * Get current account
   */ async getAccount() {
        return this.currentAccount;
    }
    /**
   * Get current network
   */ async getNetwork() {
        if (!this.currentAccount) throw ge.notConnected();
        return this.currentAccount.network;
    }
    /**
   * Sign and optionally submit a transaction
   * @param transaction - The transaction to sign
   * @param submit - Whether to submit to the ledger (default: true)
   */ async signAndSubmit(e) {
        if (!this.currentAccount) throw ge.notConnected();
        try {
            const t = {
                ...e,
                Account: e.Account || this.currentAccount.address
            }, n = await Po.methods.signAndSubmitAndWait(t);
            if (!n.response.data.resp.result.hash) throw new Error("Failed to sign transaction with Crossmark");
            return {
                hash: n.response.data.resp.result.hash
            };
        } catch (t) {
            throw t instanceof Error && t.message.toLowerCase().includes("reject") ? ge.signRejected() : ge.signFailed(t);
        }
    }
    /**
   * Sign a message
   */ async signMessage(e) {
        if (!this.currentAccount) throw ge.notConnected();
        try {
            const t = typeof e == "string" ? e : new TextDecoder().decode(e), n = await Po.methods.signInAndWait(t);
            if (!n || !n.response || !n.response.data) throw new Error("Failed to sign message with Crossmark");
            const { signature: s, publicKey: i } = n.response.data;
            return {
                message: t,
                signature: s || "",
                publicKey: i || this.currentAccount.publicKey || ""
            };
        } catch (t) {
            throw ge.signFailed(t);
        }
    }
    /**
   * Resolve network configuration
   */ resolveNetwork(e) {
        if (!e) return Hr.mainnet;
        if (typeof e == "string") {
            const t = Hr[e];
            if (!t) throw ge.unknown(`Unknown network: ${e}`);
            return t;
        }
        return e;
    }
    /**
   * Generate a random hash for signing
   */ generateRandomHash() {
        const e = new Uint8Array(32);
        if (("TURBOPACK compile-time value", "undefined") < "u" && window.crypto) window.crypto.getRandomValues(e);
        else for(let t = 0; t < e.length; t++)e[t] = Math.floor(Math.random() * 256);
        return Array.from(e, (t)=>t.toString(16).padStart(2, "0")).join("");
    }
}
var Hi = {}, ry = {}, sc = {}, Ze = {}, oc = {};
Object.defineProperty(oc, "__esModule", {
    value: !0
});
oc.API_ERROR_BAD_REQUEST = void 0;
oc.API_ERROR_BAD_REQUEST = "gem_BAD_REQUEST";
var ny = {};
Object.defineProperty(ny, "__esModule", {
    value: !0
});
var Gn = {};
Object.defineProperty(Gn, "__esModule", {
    value: !0
});
Gn.MSG_INTERNAL_RECEIVE_SIGN_OUT = Gn.MSG_INTERNAL_RECEIVE_PASSWORD = Gn.MSG_INTERNAL_REQUEST_PASSWORD = void 0;
Gn.MSG_INTERNAL_REQUEST_PASSWORD = "INTERNAL_REQUEST_PASSWORD";
Gn.MSG_INTERNAL_RECEIVE_PASSWORD = "INTERNAL_RECEIVE_PASSWORD";
Gn.MSG_INTERNAL_RECEIVE_SIGN_OUT = "INTERNAL_RECEIVE_SIGN_OUT";
var iy = {};
Object.defineProperty(iy, "__esModule", {
    value: !0
});
var sy = {};
(function(r) {
    var e = $ && $.__spreadArray || function(d, h, f) {
        if (f || arguments.length === 2) for(var g = 0, p = h.length, m; g < p; g++)(m || !(g in h)) && (m || (m = Array.prototype.slice.call(h, 0, g)), m[g] = h[g]);
        return d.concat(m || Array.prototype.slice.call(h));
    }, t, n, s;
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), r.getNetworkByNetworkID = r.getNetwork = r.getDefaultNetwork = r.NETWORK = r.FAUCET_XAHAU_TESTNET = r.XAHAU_TESTNET_NODES = r.XAHAU_MAINNET_NODES = r.DEVNET_NODES = r.TESTNET_NODES = r.MAINNET_NODES = r.MAINNET_CLIO_NODES = r.XahauNetwork = r.XRPLNetwork = r.Chain = void 0;
    var i;
    (function(d) {
        d.XRPL = "XRPL", d.XAHAU = "XAHAU";
    })(i || (r.Chain = i = {}));
    var o;
    (function(d) {
        d.MAINNET = "Mainnet", d.TESTNET = "Testnet", d.DEVNET = "Devnet", d.CUSTOM = "Custom";
    })(o || (r.XRPLNetwork = o = {}));
    var a;
    (function(d) {
        d.XAHAU_MAINNET = "Mainnet", d.XAHAU_TESTNET = "Testnet", d.CUSTOM = "Custom";
    })(a || (r.XahauNetwork = a = {})), r.MAINNET_CLIO_NODES = [
        "wss://s1.ripple.com",
        "wss://s2.ripple.com"
    ], r.MAINNET_NODES = e([
        "wss://xrplcluster.com"
    ], r.MAINNET_CLIO_NODES, !0), r.TESTNET_NODES = [
        "wss://s.altnet.rippletest.net:51233",
        "wss://testnet.xrpl-labs.com"
    ], r.DEVNET_NODES = [
        "wss://s.devnet.rippletest.net:51233"
    ], r.XAHAU_MAINNET_NODES = [
        "wss://xahau.network"
    ], r.XAHAU_TESTNET_NODES = [
        "wss://xahau-test.net"
    ], r.FAUCET_XAHAU_TESTNET = "https://xahau-test.net/accounts", r.NETWORK = (t = {}, t[i.XRPL] = (n = {}, n[o.MAINNET] = {
        chain: i.XRPL,
        name: o.MAINNET,
        server: r.MAINNET_NODES[0],
        nodes: r.MAINNET_NODES,
        description: "Main network using the production version of the XRP Ledger.",
        networkID: 0
    }, n[o.TESTNET] = {
        chain: i.XRPL,
        name: o.TESTNET,
        server: r.TESTNET_NODES[0],
        nodes: r.TESTNET_NODES,
        description: "Acts as a testing network, without impacting production users and risking real money.",
        networkID: 1
    }, n[o.DEVNET] = {
        chain: i.XRPL,
        name: o.DEVNET,
        server: r.DEVNET_NODES[0],
        nodes: r.DEVNET_NODES,
        description: "A preview of upcoming features, where unstable changes are tested out."
    }, n[o.CUSTOM] = {
        chain: i.XRPL,
        name: o.CUSTOM,
        server: "",
        description: "Custom network configuration provided by the user."
    }, n), t[i.XAHAU] = (s = {}, s[a.XAHAU_MAINNET] = {
        chain: i.XAHAU,
        name: a.XAHAU_MAINNET,
        server: r.XAHAU_MAINNET_NODES[0],
        nodes: r.XAHAU_MAINNET_NODES,
        description: "Mainnet for the Xahau blockchain.",
        networkID: 21337
    }, s[a.XAHAU_TESTNET] = {
        chain: i.XAHAU,
        name: a.XAHAU_TESTNET,
        server: r.XAHAU_TESTNET_NODES[0],
        nodes: r.XAHAU_TESTNET_NODES,
        description: "Testnet for the Xahau blockchain.",
        networkID: 21338
    }, s[a.CUSTOM] = {
        chain: i.XAHAU,
        name: a.CUSTOM,
        server: "",
        description: "Custom network configuration provided by the user."
    }, s), t);
    var u = function(d) {
        switch(d){
            case i.XAHAU:
                return a.XAHAU_MAINNET;
            default:
                return o.MAINNET;
        }
    };
    r.getDefaultNetwork = u;
    function c(d, h) {
        if (d === i.XRPL && Object.values(o).includes(h) || d === i.XAHAU && Object.values(a).includes(h)) return r.NETWORK[d][h];
        throw new Error("Network ".concat(h, " is not valid for chain ").concat(d));
    }
    r.getNetwork = c;
    var l = function(d) {
        switch(d){
            case 0:
                return r.NETWORK[i.XRPL][o.MAINNET];
            case 1:
                return r.NETWORK[i.XRPL][o.TESTNET];
            case 21337:
                return r.NETWORK[i.XAHAU][a.XAHAU_MAINNET];
            case 21338:
                return r.NETWORK[i.XAHAU][a.XAHAU_TESTNET];
            default:
                throw new Error("Network ID ".concat(d, " is not valid"));
        }
    };
    r.getNetworkByNetworkID = l;
})(sy);
var ac = {};
Object.defineProperty(ac, "__esModule", {
    value: !0
});
ac.GEM_WALLET = void 0;
ac.GEM_WALLET = "gem-wallet";
var cc = {};
Object.defineProperty(cc, "__esModule", {
    value: !0
});
cc.DEFAULT_SUBMIT_TX_BULK_ON_ERROR = void 0;
cc.DEFAULT_SUBMIT_TX_BULK_ON_ERROR = "abort";
var oy = {};
Object.defineProperty(oy, "__esModule", {
    value: !0
});
var ay = {};
Object.defineProperty(ay, "__esModule", {
    value: !0
});
var cy = {};
Object.defineProperty(cy, "__esModule", {
    value: !0
});
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(oc, r), t(ny, r), t(Gn, r), t(iy, r), t(sy, r), t(ac, r), t(cc, r), t(oy, r), t(ay, r), t(cy, r);
})(Ze);
var Je = {};
Object.defineProperty(Je, "__esModule", {
    value: !0
});
Je.deserializeError = void 0;
var Iv = function(r) {
    var e = new Error(r.message);
    return e.stack = r.stack, e.name = r.name, e;
};
Je.deserializeError = Iv;
var Ke = {}, yl = $ && $.__assign || function() {
    return yl = Object.assign || function(r) {
        for(var e, t = 1, n = arguments.length; t < n; t++){
            e = arguments[t];
            for(var s in e)Object.prototype.hasOwnProperty.call(e, s) && (r[s] = e[s]);
        }
        return r;
    }, yl.apply(this, arguments);
};
Object.defineProperty(Ke, "__esModule", {
    value: !0
});
Ke.sendMessageToContentScript = void 0;
var Tv = function(r) {
    var e = Date.now() + Math.random();
    return window.postMessage(yl({
        source: "GEM_WALLET_MSG_REQUEST",
        messageId: e
    }, r), window.location.origin), new Promise(function(t, n) {
        !window.gemWallet && r.type !== "REQUEST_IS_INSTALLED/V3" && n(new Error("Please check if GemWallet is installed - GemWallet needs to be installed: https://gemwallet.app"));
        var s = function(i) {
            var o, a;
            i.source === window && ((o = i == null ? void 0 : i.data) === null || o === void 0 ? void 0 : o.source) === "GEM_WALLET_MSG_RESPONSE" && ((a = i == null ? void 0 : i.data) === null || a === void 0 ? void 0 : a.messagedId) === e && (t(i.data), window.removeEventListener("message", s));
        };
        window.addEventListener("message", s, !1);
    });
};
Ke.sendMessageToContentScript = Tv;
var Dv = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, _v = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(sc, "__esModule", {
    value: !0
});
sc.acceptNFTOffer = void 0;
var Av = Ze, Sv = Je, Ov = Ke, jv = function(r) {
    return Dv(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return _v(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: Av.GEM_WALLET,
                        type: "REQUEST_ACCEPT_NFT_OFFER/V3",
                        payload: r
                    }, [
                        4,
                        (0, Ov.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Sv.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
sc.acceptNFTOffer = jv;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(sc, r);
})(ry);
var uy = {}, uc = {}, Cv = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, Lv = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(uc, "__esModule", {
    value: !0
});
uc.burnNFT = void 0;
var kv = Ze, zv = Je, Pv = Ke, Uv = function(r) {
    return Cv(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return Lv(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: kv.GEM_WALLET,
                        type: "REQUEST_BURN_NFT/V3",
                        payload: r
                    }, [
                        4,
                        (0, Pv.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, zv.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
uc.burnNFT = Uv;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(uc, r);
})(uy);
var ly = {}, lc = {}, Rv = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, $v = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(lc, "__esModule", {
    value: !0
});
lc.cancelNFTOffer = void 0;
var Bv = Ze, Fv = Je, qv = Ke, Qv = function(r) {
    return Rv(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return $v(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: Bv.GEM_WALLET,
                        type: "REQUEST_CANCEL_NFT_OFFER/V3",
                        payload: r
                    }, [
                        4,
                        (0, qv.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Fv.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
lc.cancelNFTOffer = Qv;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(lc, r);
})(ly);
var dy = {}, dc = {}, Vv = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, Yv = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(dc, "__esModule", {
    value: !0
});
dc.cancelOffer = void 0;
var Gv = Ze, Hv = Je, Wv = Ke, Kv = function(r) {
    return Vv(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return Yv(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: Gv.GEM_WALLET,
                        type: "REQUEST_CANCEL_OFFER/V3",
                        payload: r
                    }, [
                        4,
                        (0, Wv.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Hv.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
dc.cancelOffer = Kv;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(dc, r);
})(dy);
var hy = {}, hc = {}, Xv = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, Zv = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(hc, "__esModule", {
    value: !0
});
hc.createNFTOffer = void 0;
var Jv = Ze, eE = Je, tE = Ke, rE = function(r) {
    return Xv(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return Zv(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: Jv.GEM_WALLET,
                        type: "REQUEST_CREATE_NFT_OFFER/V3",
                        payload: r
                    }, [
                        4,
                        (0, tE.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, eE.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
hc.createNFTOffer = rE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(hc, r);
})(hy);
var fy = {}, fc = {}, nE = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, iE = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(fc, "__esModule", {
    value: !0
});
fc.createOffer = void 0;
var sE = Ze, oE = Je, aE = Ke, cE = function(r) {
    return nE(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return iE(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: sE.GEM_WALLET,
                        type: "REQUEST_CREATE_OFFER/V3",
                        payload: r
                    }, [
                        4,
                        (0, aE.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, oE.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
fc.createOffer = cE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(fc, r);
})(fy);
var py = {}, pc = {};
Object.defineProperty(pc, "__esModule", {
    value: !0
});
pc.on = void 0;
var uE = Ze, lE = function(r, e) {
    window.addEventListener("message", function(t) {
        t.origin === window.origin && (t.source !== window && t.data.app === uE.GEM_WALLET || !t.data.source || t.data.source !== "GEM_WALLET_MSG_REQUEST" || t.data.type && t.data.type === r && e(t.data.payload.result));
    });
};
pc.on = lE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(pc, r);
})(py);
var gy = {}, gc = {}, Ai = {};
Object.defineProperty(Ai, "__esModule", {
    value: !0
});
Ai.getFavicon = void 0;
var dE = function() {
    var r, e = (r = document.querySelector("link[rel*='icon']")) === null || r === void 0 ? void 0 : r.getAttribute("href");
    if (e) try {
        new URL(e);
    } catch  {
        e = window.location.origin + e;
    }
    return e;
};
Ai.getFavicon = dE;
var hE = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, fE = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(gc, "__esModule", {
    value: !0
});
gc.getAddress = void 0;
var pE = Ze, gE = Je, yE = Ke, wE = Ai, mE = function() {
    return hE(void 0, void 0, void 0, function() {
        var r, e, t, n, s, i, o, a;
        return fE(this, function(u) {
            switch(u.label){
                case 0:
                    r = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), e = (0, wE.getFavicon)(), t = {
                        app: pE.GEM_WALLET,
                        type: "REQUEST_GET_ADDRESS/V3",
                        payload: {
                            url: window.location.origin,
                            title: document.title,
                            favicon: e
                        }
                    }, [
                        4,
                        (0, yE.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, gE.deserializeError)(i) : void 0, o) throw o;
                    return s && (r.type = "response", r.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        r
                    ];
            }
        });
    });
};
gc.getAddress = mE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(gc, r);
})(gy);
var yy = {}, yc = {}, bE = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, vE = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(yc, "__esModule", {
    value: !0
});
yc.getNetwork = void 0;
var EE = Ze, ME = Je, NE = Ke, xE = function() {
    return bE(void 0, void 0, void 0, function() {
        var r, e, t, n, s, i, o;
        return vE(this, function(a) {
            switch(a.label){
                case 0:
                    r = {
                        type: "reject",
                        result: void 0
                    }, a.label = 1;
                case 1:
                    return a.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), e = {
                        app: EE.GEM_WALLET,
                        type: "REQUEST_GET_NETWORK/V3"
                    }, [
                        4,
                        (0, NE.sendMessageToContentScript)(e)
                    ];
                case 2:
                    if (t = a.sent(), n = t.result, s = t.error, i = s ? (0, ME.deserializeError)(s) : void 0, i) throw i;
                    return n && (r.type = "response", r.result = n), [
                        3,
                        4
                    ];
                case 3:
                    throw o = a.sent(), o;
                case 4:
                    return [
                        2,
                        r
                    ];
            }
        });
    });
};
yc.getNetwork = xE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(yc, r);
})(yy);
var wy = {}, wc = {}, IE = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, TE = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(wc, "__esModule", {
    value: !0
});
wc.getNFT = void 0;
var DE = Ze, _E = Je, AE = Ke, SE = Ai, OE = function(r) {
    return IE(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a, u, c, l;
        return TE(this, function(d) {
            switch(d.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, d.label = 1;
                case 1:
                    return d.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = (0, SE.getFavicon)(), n = {
                        app: DE.GEM_WALLET,
                        type: "REQUEST_GET_NFT/V3",
                        payload: {
                            url: window.location.origin,
                            title: document.title,
                            favicon: t,
                            limit: (c = r == null ? void 0 : r.limit) !== null && c !== void 0 ? c : void 0,
                            // Value from a previous paginated response. Resume retrieving data where that response left off.
                            marker: (l = r == null ? void 0 : r.marker) !== null && l !== void 0 ? l : void 0
                        }
                    }, [
                        4,
                        (0, AE.sendMessageToContentScript)(n)
                    ];
                case 2:
                    if (s = d.sent(), i = s.result, o = s.error, a = o ? (0, _E.deserializeError)(o) : void 0, a) throw a;
                    return i && (e.type = "response", e.result = i), [
                        3,
                        4
                    ];
                case 3:
                    throw u = d.sent(), u;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
wc.getNFT = OE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(wc, r);
})(wy);
var my = {}, mc = {}, jE = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, CE = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(mc, "__esModule", {
    value: !0
});
mc.getPublicKey = void 0;
var LE = Ze, kE = Je, zE = Ke, PE = Ai, UE = function() {
    return jE(void 0, void 0, void 0, function() {
        var r, e, t, n, s, i, o, a;
        return CE(this, function(u) {
            switch(u.label){
                case 0:
                    r = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), e = (0, PE.getFavicon)(), t = {
                        app: LE.GEM_WALLET,
                        type: "REQUEST_GET_PUBLIC_KEY/V3",
                        payload: {
                            url: window.location.origin,
                            title: document.title,
                            favicon: e
                        }
                    }, [
                        4,
                        (0, zE.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, kE.deserializeError)(i) : void 0, o) throw o;
                    return s && (r.type = "response", r.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        r
                    ];
            }
        });
    });
};
mc.getPublicKey = UE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(mc, r);
})(my);
var by = {}, bc = {}, RE = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, $E = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(bc, "__esModule", {
    value: !0
});
bc.isInstalled = void 0;
var BE = Ze, FE = Ke, qE = function() {
    if (window.gemWallet) return Promise.resolve({
        result: {
            isInstalled: !0
        }
    });
    var r, e = new Promise(function(n) {
        r = setTimeout(function() {
            n({
                result: {
                    isInstalled: !1
                }
            });
        }, 1e3);
    }), t = new Promise(function(n) {
        return RE(void 0, void 0, void 0, function() {
            var s, i;
            return $E(this, function(o) {
                switch(o.label){
                    case 0:
                        return o.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]), s = {
                            app: BE.GEM_WALLET,
                            type: "REQUEST_IS_INSTALLED/V3"
                        }, [
                            4,
                            (0, FE.sendMessageToContentScript)(s)
                        ];
                    case 1:
                        return i = o.sent(), n({
                            result: {
                                isInstalled: i.isInstalled || !1
                            }
                        }), [
                            3,
                            3
                        ];
                    case 2:
                        return o.sent(), n({
                            result: {
                                isInstalled: !1
                            }
                        }), [
                            3,
                            3
                        ];
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    });
    return Promise.race([
        e,
        t
    ]).then(function(n) {
        return clearTimeout(r), n.result.isInstalled === !0 && (window.gemWallet = !0), {
            result: {
                isInstalled: n.result.isInstalled
            }
        };
    }).catch(function() {
        return {
            result: {
                isInstalled: !1
            }
        };
    });
};
bc.isInstalled = qE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(bc, r);
})(by);
var vy = {}, vc = {}, QE = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, VE = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(vc, "__esModule", {
    value: !0
});
vc.mintNFT = void 0;
var YE = Ze, GE = Je, HE = Ke, WE = function(r) {
    return QE(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return VE(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: YE.GEM_WALLET,
                        type: "REQUEST_MINT_NFT/V3",
                        payload: r
                    }, [
                        4,
                        (0, HE.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, GE.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
vc.mintNFT = WE;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(vc, r);
})(vy);
var Ey = {}, Ec = {}, KE = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, XE = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(Ec, "__esModule", {
    value: !0
});
Ec.sendPayment = void 0;
var ZE = Ze, JE = Je, eM = Ke, tM = function(r) {
    return KE(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return XE(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: ZE.GEM_WALLET,
                        type: "REQUEST_SEND_PAYMENT/V3",
                        payload: r
                    }, [
                        4,
                        (0, eM.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, JE.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
Ec.sendPayment = tM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(Ec, r);
})(Ey);
var My = {}, Mc = {}, rM = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, nM = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(Mc, "__esModule", {
    value: !0
});
Mc.setAccount = void 0;
var iM = Ze, sM = Je, oM = Ke, aM = function(r) {
    return rM(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return nM(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: iM.GEM_WALLET,
                        type: "REQUEST_SET_ACCOUNT/V3",
                        payload: r
                    }, [
                        4,
                        (0, oM.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, sM.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
Mc.setAccount = aM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(Mc, r);
})(My);
var Ny = {}, Nc = {}, cM = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, uM = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(Nc, "__esModule", {
    value: !0
});
Nc.setHook = void 0;
var lM = Ze, dM = Je, hM = Ke, fM = function(r) {
    return cM(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return uM(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: lM.GEM_WALLET,
                        type: "REQUEST_SET_HOOK/V3",
                        payload: r
                    }, [
                        4,
                        (0, hM.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, dM.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
Nc.setHook = fM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(Nc, r);
})(Ny);
var xy = {}, xc = {}, pM = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, gM = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(xc, "__esModule", {
    value: !0
});
xc.setRegularKey = void 0;
var yM = Ze, wM = Je, mM = Ke, bM = function(r) {
    return pM(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return gM(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: yM.GEM_WALLET,
                        type: "REQUEST_SET_REGULAR_KEY/V3",
                        payload: r
                    }, [
                        4,
                        (0, mM.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, wM.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
xc.setRegularKey = bM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(xc, r);
})(xy);
var Iy = {}, Ic = {}, vM = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, EM = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(Ic, "__esModule", {
    value: !0
});
Ic.setTrustline = void 0;
var MM = Ze, NM = Je, xM = Ke, IM = function(r) {
    return vM(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return EM(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: MM.GEM_WALLET,
                        type: "REQUEST_SET_TRUSTLINE/V3",
                        payload: r
                    }, [
                        4,
                        (0, xM.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, NM.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
Ic.setTrustline = IM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(Ic, r);
})(Iy);
var Ty = {}, Tc = {}, TM = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, DM = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(Tc, "__esModule", {
    value: !0
});
Tc.signMessage = void 0;
var _M = Ze, AM = Je, SM = Ke, OM = Ai, jM = function(r, e) {
    return TM(void 0, void 0, void 0, function() {
        var t, n, s, i, o, a, u, c;
        return DM(this, function(l) {
            switch(l.label){
                case 0:
                    t = {
                        type: "reject",
                        result: void 0
                    }, l.label = 1;
                case 1:
                    return l.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), n = (0, OM.getFavicon)(), s = {
                        app: _M.GEM_WALLET,
                        type: "REQUEST_SIGN_MESSAGE/V3",
                        payload: {
                            url: window.location.origin,
                            title: document.title,
                            favicon: n,
                            message: r,
                            isHex: e
                        }
                    }, [
                        4,
                        (0, SM.sendMessageToContentScript)(s)
                    ];
                case 2:
                    if (i = l.sent(), o = i.result, a = i.error, u = a ? (0, AM.deserializeError)(a) : void 0, u) throw u;
                    return o && (t.type = "response", t.result = o), [
                        3,
                        4
                    ];
                case 3:
                    throw c = l.sent(), c;
                case 4:
                    return [
                        2,
                        t
                    ];
            }
        });
    });
};
Tc.signMessage = jM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(Tc, r);
})(Ty);
var Dy = {}, Dc = {}, CM = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, LM = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(Dc, "__esModule", {
    value: !0
});
Dc.signTransaction = void 0;
var kM = Ze, zM = Je, PM = Ke, UM = function(r) {
    return CM(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return LM(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: kM.GEM_WALLET,
                        type: "REQUEST_SIGN_TRANSACTION/V3",
                        payload: r
                    }, [
                        4,
                        (0, PM.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, zM.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
Dc.signTransaction = UM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(Dc, r);
})(Dy);
var _y = {}, _c = {}, RM = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, $M = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(_c, "__esModule", {
    value: !0
});
_c.submitTransaction = void 0;
var BM = Ze, FM = Je, qM = Ke, QM = function(r) {
    return RM(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return $M(this, function(u) {
            switch(u.label){
                case 0:
                    e = {
                        type: "reject",
                        result: void 0
                    }, u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: BM.GEM_WALLET,
                        type: "REQUEST_SUBMIT_TRANSACTION/V3",
                        payload: r
                    }, [
                        4,
                        (0, qM.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, FM.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
_c.submitTransaction = QM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(_c, r);
})(_y);
var Ay = {}, Ac = {}, Da = $ && $.__assign || function() {
    return Da = Object.assign || function(r) {
        for(var e, t = 1, n = arguments.length; t < n; t++){
            e = arguments[t];
            for(var s in e)Object.prototype.hasOwnProperty.call(e, s) && (r[s] = e[s]);
        }
        return r;
    }, Da.apply(this, arguments);
}, VM = $ && $.__awaiter || function(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}, YM = $ && $.__generator || function(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; o && (o = 0, c[0] && (t = 0)), t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
};
Object.defineProperty(Ac, "__esModule", {
    value: !0
});
Ac.submitBulkTransactions = void 0;
var sf = Ze, GM = Je, HM = Ke, of = 50, WM = function(r) {
    return VM(void 0, void 0, void 0, function() {
        var e, t, n, s, i, o, a;
        return YM(this, function(u) {
            switch(u.label){
                case 0:
                    if (e = {
                        type: "reject",
                        result: void 0
                    }, !r.transactions) throw new Error(sf.API_ERROR_BAD_REQUEST);
                    if (r.transactions.length === 0 || r.transactions.length > of) throw new Error("Invalid number of transactions (must be between 1 and ".concat(of, ")"));
                    u.label = 1;
                case 1:
                    return u.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), t = {
                        app: sf.GEM_WALLET,
                        type: "REQUEST_SUBMIT_BULK_TRANSACTIONS/V3",
                        payload: Da(Da({}, r), {
                            // Add an index to each transaction so that we can process them in order
                            transactions: r.transactions.reduce(function(c, l, d) {
                                return c[d] = l, c;
                            }, {})
                        })
                    }, [
                        4,
                        (0, HM.sendMessageToContentScript)(t)
                    ];
                case 2:
                    if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, GM.deserializeError)(i) : void 0, o) throw o;
                    return s && (e.type = "response", e.result = s), [
                        3,
                        4
                    ];
                case 3:
                    throw a = u.sent(), a;
                case 4:
                    return [
                        2,
                        e
                    ];
            }
        });
    });
};
Ac.submitBulkTransactions = WM;
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(Ac, r);
})(Ay);
(function(r) {
    var e = $ && $.__createBinding || (Object.create ? function(n, s, i, o) {
        o === void 0 && (o = i);
        var a = Object.getOwnPropertyDescriptor(s, i);
        (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return s[i];
            }
        }), Object.defineProperty(n, o, a);
    } : function(n, s, i, o) {
        o === void 0 && (o = i), n[o] = s[i];
    }), t = $ && $.__exportStar || function(n, s) {
        for(var i in n)i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
    };
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), t(ry, r), t(uy, r), t(ly, r), t(dy, r), t(hy, r), t(fy, r), t(py, r), t(gy, r), t(yy, r), t(wy, r), t(my, r), t(by, r), t(vy, r), t(Ey, r), t(My, r), t(Ny, r), t(xy, r), t(Iy, r), t(Ty, r), t(Dy, r), t(_y, r), t(Ay, r);
})(Hi);
class KM {
    constructor(e = {}){
        this.id = "gemwallet", this.name = "GemWallet", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwQThFQSIgZD0iTTIwIDM5LjkxMS41OTMgMTcuNDIyaDM4LjgxNHoiLz48cGF0aCBmaWxsPSIjMzNEM0Y0IiBkPSJNMzMuMTg1IDUuMzMzSDYuODE1TC41OTMgMTcuNDIzaDM4LjgxNHoiLz48cGF0aCBmaWxsPSIjNDBFRUZGIiBkPSJtMjAgMzkuOTExLTcuMDM3LTIyLjQ4OWgxNC4wNzR6TTE0LjIyMiAxNC40IDguNjY3IDUuMzMzSDIwem0xMS4yNTkgMEwyMCA1LjMzM2gxMS4zMzN6Ii8+PHBhdGggZmlsbD0iI0ZGRiIgZD0iTTYuMjk2IDYuNDg5IDMuNDA3IDUuMzMzbDIuODktMS4xNTVMNy4yNTguNzFsLjk2MyAzLjQ2NyAyLjg5IDEuMTU1LTIuODkgMS4xNTYtLjk2MyAzLjQ2N3ptMjcuNDA4IDExLjI4OS0xLjg1Mi0uNzExIDEuODUyLS44LjY2Ni0yLjIyMy41OTMgMi4yMjMgMS44NTIuOC0xLjg1Mi43MUwzNC4zNyAyMHoiLz48cGF0aCBkPSJNMjEuODUyIDUuMzMzIDYuMjk2IDI0LjA5bC0xLjMzMy0xLjUxMSAxNC4zNy0xNy4yNDV6bTguNzQxIDBMMTAuNzQgMjkuMTU2IDcuNjMgMjUuNiAyNC40NDQgNS4zMzN6IiBvcGFjaXR5PSIuMiIgZmlsbD0iI0ZGRiIvPjwvZz48L3N2Zz4=", this.url = "https://gemwallet.app", this.currentAccount = null;
    }
    /**
   * Check if GemWallet is installed
   */ async isAvailable() {
        var e;
        try {
            return ((e = (await Hi.isInstalled()).result) == null ? void 0 : e.isInstalled) || !1;
        } catch  {
            return !1;
        }
    }
    /**
   * Connect to GemWallet
   */ async connect(e) {
        try {
            if (!await this.isAvailable()) throw ge.notInstalled(this.name);
            const n = this.resolveNetwork(e == null ? void 0 : e.network), s = await Hi.getPublicKey();
            if (!s.result || !s.result.address) throw new Error("Failed to get address from GemWallet");
            const { address: i, publicKey: o } = s.result;
            return this.currentAccount = {
                address: i,
                publicKey: o,
                network: n
            }, this.currentAccount;
        } catch (t) {
            throw ge.connectionFailed(this.name, t);
        }
    }
    /**
   * Disconnect from GemWallet
   */ async disconnect() {
        this.currentAccount = null;
    }
    /**
   * Get current account
   */ async getAccount() {
        return this.currentAccount;
    }
    /**
   * Get current network
   */ async getNetwork() {
        if (!this.currentAccount) throw ge.notConnected();
        return this.currentAccount.network;
    }
    /**
   * Sign and optionally submit a transaction
   * @param transaction - The transaction to sign
   * @param submit - Whether to submit to the ledger (default: true)
   */ async signAndSubmit(e, t = !0) {
        if (!this.currentAccount) throw ge.notConnected();
        try {
            const n = {
                ...e,
                Account: e.Account || this.currentAccount.address
            };
            if (t) {
                const s = await Hi.submitTransaction({
                    transaction: n
                });
                if (!s.result || !s.result.hash) throw new Error("Failed to submit transaction with GemWallet");
                const { hash: i } = s.result;
                return {
                    hash: i
                };
            } else {
                const s = await Hi.signTransaction({
                    transaction: n
                });
                if (!s.result) throw new Error("Failed to sign transaction with GemWallet");
                const { signature: i } = s.result;
                return {
                    hash: "",
                    // GemWallet doesn't return hash for sign-only
                    signature: i
                };
            }
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("reject") ? ge.signRejected() : ge.signFailed(n);
        }
    }
    /**
   * Sign a message
   */ async signMessage(e) {
        if (!this.currentAccount) throw ge.notConnected();
        try {
            const t = typeof e == "string" ? e : new TextDecoder().decode(e), n = await Hi.signMessage(t);
            if (!n.result || !n.result.signedMessage) throw new Error("Failed to sign message with GemWallet");
            const { signedMessage: s } = n.result;
            return {
                message: t,
                signature: s,
                publicKey: this.currentAccount.publicKey || ""
            };
        } catch (t) {
            throw ge.signFailed(t);
        }
    }
    /**
   * Resolve network configuration
   */ resolveNetwork(e) {
        if (!e) return Hr.mainnet;
        if (typeof e == "string") {
            const t = Hr[e];
            if (!t) throw ge.unknown(`Unknown network: ${e}`);
            return t;
        }
        return e;
    }
}
var ue = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var wl = function(r, e) {
    return wl = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(t, n) {
        t.__proto__ = n;
    } || function(t, n) {
        for(var s in n)n.hasOwnProperty(s) && (t[s] = n[s]);
    }, wl(r, e);
};
function XM(r, e) {
    wl(r, e);
    function t() {
        this.constructor = r;
    }
    r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var ml = function() {
    return ml = Object.assign || function(e) {
        for(var t, n = 1, s = arguments.length; n < s; n++){
            t = arguments[n];
            for(var i in t)Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        }
        return e;
    }, ml.apply(this, arguments);
};
function ZM(r, e) {
    var t = {};
    for(var n in r)Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
    if (r != null && typeof Object.getOwnPropertySymbols == "function") for(var s = 0, n = Object.getOwnPropertySymbols(r); s < n.length; s++)e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[s]) && (t[n[s]] = r[n[s]]);
    return t;
}
function JM(r, e, t, n) {
    var s = arguments.length, i = s < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(r, e, t, n);
    else for(var a = r.length - 1; a >= 0; a--)(o = r[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, t, i) : o(e, t)) || i);
    return s > 3 && i && Object.defineProperty(e, t, i), i;
}
function eN(r, e) {
    return function(t, n) {
        e(t, n, r);
    };
}
function tN(r, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(r, e);
}
function rN(r, e, t, n) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i);
        });
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(l) {
            try {
                c(n.next(l));
            } catch (d) {
                o(d);
            }
        }
        function u(l) {
            try {
                c(n.throw(l));
            } catch (d) {
                o(d);
            }
        }
        function c(l) {
            l.done ? i(l.value) : s(l.value).then(a, u);
        }
        c((n = n.apply(r, e || [])).next());
    });
}
function nN(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    }, n, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(c) {
        return function(l) {
            return u([
                c,
                l
            ]);
        };
    }
    function u(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for(; t;)try {
            if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
            switch(s = 0, i && (c = [
                c[0] & 2,
                i.value
            ]), c[0]){
                case 0:
                case 1:
                    i = c;
                    break;
                case 4:
                    return t.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++, s = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                default:
                    if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
                        t.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && t.label < i[1]) {
                        t.label = i[1], i = c;
                        break;
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2], t.ops.push(c);
                        break;
                    }
                    i[2] && t.ops.pop(), t.trys.pop();
                    continue;
            }
            c = e.call(r, t);
        } catch (l) {
            c = [
                6,
                l
            ], s = 0;
        } finally{
            n = i = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
}
function iN(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
}
function sN(r, e) {
    for(var t in r)t !== "default" && !e.hasOwnProperty(t) && (e[t] = r[t]);
}
function bl(r) {
    var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
    if (t) return t.call(r);
    if (r && typeof r.length == "number") return {
        next: function() {
            return r && n >= r.length && (r = void 0), {
                value: r && r[n++],
                done: !r
            };
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Sy(r, e) {
    var t = typeof Symbol == "function" && r[Symbol.iterator];
    if (!t) return r;
    var n = t.call(r), s, i = [], o;
    try {
        for(; (e === void 0 || e-- > 0) && !(s = n.next()).done;)i.push(s.value);
    } catch (a) {
        o = {
            error: a
        };
    } finally{
        try {
            s && !s.done && (t = n.return) && t.call(n);
        } finally{
            if (o) throw o.error;
        }
    }
    return i;
}
function oN() {
    for(var r = [], e = 0; e < arguments.length; e++)r = r.concat(Sy(arguments[e]));
    return r;
}
function aN() {
    for(var r = 0, e = 0, t = arguments.length; e < t; e++)r += arguments[e].length;
    for(var n = Array(r), s = 0, e = 0; e < t; e++)for(var i = arguments[e], o = 0, a = i.length; o < a; o++, s++)n[s] = i[o];
    return n;
}
function so(r) {
    return this instanceof so ? (this.v = r, this) : new so(r);
}
function cN(r, e, t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = t.apply(r, e || []), s, i = [];
    return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
        return this;
    }, s;
    //TURBOPACK unreachable
    ;
    function o(h) {
        n[h] && (s[h] = function(f) {
            return new Promise(function(g, p) {
                i.push([
                    h,
                    f,
                    g,
                    p
                ]) > 1 || a(h, f);
            });
        });
    }
    function a(h, f) {
        try {
            u(n[h](f));
        } catch (g) {
            d(i[0][3], g);
        }
    }
    function u(h) {
        h.value instanceof so ? Promise.resolve(h.value.v).then(c, l) : d(i[0][2], h);
    }
    function c(h) {
        a("next", h);
    }
    function l(h) {
        a("throw", h);
    }
    function d(h, f) {
        h(f), i.shift(), i.length && a(i[0][0], i[0][1]);
    }
}
function uN(r) {
    var e, t;
    return e = {}, n("next"), n("throw", function(s) {
        throw s;
    }), n("return"), e[Symbol.iterator] = function() {
        return this;
    }, e;
    //TURBOPACK unreachable
    ;
    function n(s, i) {
        e[s] = r[s] ? function(o) {
            return (t = !t) ? {
                value: so(r[s](o)),
                done: s === "return"
            } : i ? i(o) : o;
        } : i;
    }
}
function lN(r) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = r[Symbol.asyncIterator], t;
    return e ? e.call(r) : (r = typeof bl == "function" ? bl(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
        return this;
    }, t);
    //TURBOPACK unreachable
    ;
    function n(i) {
        t[i] = r[i] && function(o) {
            return new Promise(function(a, u) {
                o = r[i](o), s(a, u, o.done, o.value);
            });
        };
    }
    function s(i, o, a, u) {
        Promise.resolve(u).then(function(c) {
            i({
                value: c,
                done: a
            });
        }, o);
    }
}
function dN(r, e) {
    return Object.defineProperty ? Object.defineProperty(r, "raw", {
        value: e
    }) : r.raw = e, r;
}
function hN(r) {
    if (r && r.__esModule) return r;
    var e = {};
    if (r != null) for(var t in r)Object.hasOwnProperty.call(r, t) && (e[t] = r[t]);
    return e.default = r, e;
}
function fN(r) {
    return r && r.__esModule ? r : {
        default: r
    };
}
function pN(r, e) {
    if (!e.has(r)) throw new TypeError("attempted to get private field on non-instance");
    return e.get(r);
}
function gN(r, e, t) {
    if (!e.has(r)) throw new TypeError("attempted to set private field on non-instance");
    return e.set(r, t), t;
}
const yN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get __assign () {
        return ml;
    },
    __asyncDelegator: uN,
    __asyncGenerator: cN,
    __asyncValues: lN,
    __await: so,
    __awaiter: rN,
    __classPrivateFieldGet: pN,
    __classPrivateFieldSet: gN,
    __createBinding: iN,
    __decorate: JM,
    __exportStar: sN,
    __extends: XM,
    __generator: nN,
    __importDefault: fN,
    __importStar: hN,
    __makeTemplateObject: dN,
    __metadata: tN,
    __param: eN,
    __read: Sy,
    __rest: ZM,
    __spread: oN,
    __spreadArrays: aN,
    __values: bl
}, Symbol.toStringTag, {
    value: "Module"
})), go = /* @__PURE__ */ P0(yN);
var du = {}, Ss = {}, af;
function wN() {
    if (af) return Ss;
    af = 1, Object.defineProperty(Ss, "__esModule", {
        value: !0
    }), Ss.delay = void 0;
    function r(e) {
        return new Promise((t)=>{
            setTimeout(()=>{
                t(!0);
            }, e);
        });
    }
    return Ss.delay = r, Ss;
}
var ni = {}, hu = {}, ii = {}, cf;
function mN() {
    return cf || (cf = 1, Object.defineProperty(ii, "__esModule", {
        value: !0
    }), ii.ONE_THOUSAND = ii.ONE_HUNDRED = void 0, ii.ONE_HUNDRED = 100, ii.ONE_THOUSAND = 1e3), ii;
}
var fu = {}, uf;
function bN() {
    return uf || (uf = 1, function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        }), r.ONE_YEAR = r.FOUR_WEEKS = r.THREE_WEEKS = r.TWO_WEEKS = r.ONE_WEEK = r.THIRTY_DAYS = r.SEVEN_DAYS = r.FIVE_DAYS = r.THREE_DAYS = r.ONE_DAY = r.TWENTY_FOUR_HOURS = r.TWELVE_HOURS = r.SIX_HOURS = r.THREE_HOURS = r.ONE_HOUR = r.SIXTY_MINUTES = r.THIRTY_MINUTES = r.TEN_MINUTES = r.FIVE_MINUTES = r.ONE_MINUTE = r.SIXTY_SECONDS = r.THIRTY_SECONDS = r.TEN_SECONDS = r.FIVE_SECONDS = r.ONE_SECOND = void 0, r.ONE_SECOND = 1, r.FIVE_SECONDS = 5, r.TEN_SECONDS = 10, r.THIRTY_SECONDS = 30, r.SIXTY_SECONDS = 60, r.ONE_MINUTE = r.SIXTY_SECONDS, r.FIVE_MINUTES = r.ONE_MINUTE * 5, r.TEN_MINUTES = r.ONE_MINUTE * 10, r.THIRTY_MINUTES = r.ONE_MINUTE * 30, r.SIXTY_MINUTES = r.ONE_MINUTE * 60, r.ONE_HOUR = r.SIXTY_MINUTES, r.THREE_HOURS = r.ONE_HOUR * 3, r.SIX_HOURS = r.ONE_HOUR * 6, r.TWELVE_HOURS = r.ONE_HOUR * 12, r.TWENTY_FOUR_HOURS = r.ONE_HOUR * 24, r.ONE_DAY = r.TWENTY_FOUR_HOURS, r.THREE_DAYS = r.ONE_DAY * 3, r.FIVE_DAYS = r.ONE_DAY * 5, r.SEVEN_DAYS = r.ONE_DAY * 7, r.THIRTY_DAYS = r.ONE_DAY * 30, r.ONE_WEEK = r.SEVEN_DAYS, r.TWO_WEEKS = r.ONE_WEEK * 2, r.THREE_WEEKS = r.ONE_WEEK * 3, r.FOUR_WEEKS = r.ONE_WEEK * 4, r.ONE_YEAR = r.ONE_DAY * 365;
    }(fu)), fu;
}
var lf;
function Oy() {
    return lf || (lf = 1, function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        const e = go;
        e.__exportStar(mN(), r), e.__exportStar(bN(), r);
    }(hu)), hu;
}
var df;
function vN() {
    if (df) return ni;
    df = 1, Object.defineProperty(ni, "__esModule", {
        value: !0
    }), ni.fromMiliseconds = ni.toMiliseconds = void 0;
    const r = Oy();
    function e(n) {
        return n * r.ONE_THOUSAND;
    }
    ni.toMiliseconds = e;
    function t(n) {
        return Math.floor(n / r.ONE_THOUSAND);
    }
    return ni.fromMiliseconds = t, ni;
}
var hf;
function EN() {
    return hf || (hf = 1, function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        const e = go;
        e.__exportStar(wN(), r), e.__exportStar(vN(), r);
    }(du)), du;
}
var Ri = {}, ff;
function MN() {
    if (ff) return Ri;
    ff = 1, Object.defineProperty(Ri, "__esModule", {
        value: !0
    }), Ri.Watch = void 0;
    class r {
        constructor(){
            this.timestamps = /* @__PURE__ */ new Map();
        }
        start(t) {
            if (this.timestamps.has(t)) throw new Error(`Watch already started for label: ${t}`);
            this.timestamps.set(t, {
                started: Date.now()
            });
        }
        stop(t) {
            const n = this.get(t);
            if (typeof n.elapsed < "u") throw new Error(`Watch already stopped for label: ${t}`);
            const s = Date.now() - n.started;
            this.timestamps.set(t, {
                started: n.started,
                elapsed: s
            });
        }
        get(t) {
            const n = this.timestamps.get(t);
            if (typeof n > "u") throw new Error(`No timestamp found for label: ${t}`);
            return n;
        }
        elapsed(t) {
            const n = this.get(t);
            return n.elapsed || Date.now() - n.started;
        }
    }
    return Ri.Watch = r, Ri.default = r, Ri;
}
var pu = {}, Os = {}, pf;
function NN() {
    if (pf) return Os;
    pf = 1, Object.defineProperty(Os, "__esModule", {
        value: !0
    }), Os.IWatch = void 0;
    class r {
    }
    return Os.IWatch = r, Os;
}
var gf;
function xN() {
    return gf || (gf = 1, function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        }), go.__exportStar(NN(), r);
    }(pu)), pu;
}
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    });
    const e = go;
    e.__exportStar(EN(), r), e.__exportStar(MN(), r), e.__exportStar(xN(), r), e.__exportStar(Oy(), r);
})(ue);
class Si {
}
let IN = class extends Si {
    constructor(e){
        super();
    }
};
const yf = ue.FIVE_SECONDS, Oi = {
    pulse: "heartbeat_pulse"
};
let TN = class jy extends IN {
    constructor(e){
        super(e), this.events = new rr.EventEmitter(), this.interval = yf, this.interval = (e == null ? void 0 : e.interval) || yf;
    }
    static async init(e) {
        const t = new jy(e);
        return await t.init(), t;
    }
    async init() {
        await this.initialize();
    }
    stop() {
        clearInterval(this.intervalRef);
    }
    on(e, t) {
        this.events.on(e, t);
    }
    once(e, t) {
        this.events.once(e, t);
    }
    off(e, t) {
        this.events.off(e, t);
    }
    removeListener(e, t) {
        this.events.removeListener(e, t);
    }
    async initialize() {
        this.intervalRef = setInterval(()=>this.pulse(), ue.toMiliseconds(this.interval));
    }
    pulse() {
        this.events.emit(Oi.pulse);
    }
};
const DN = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, _N = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, AN = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function SN(r, e) {
    if (r === "__proto__" || r === "constructor" && e && typeof e == "object" && "prototype" in e) {
        ON(r);
        return;
    }
    return e;
}
function ON(r) {
    console.warn(`[destr] Dropping "${r}" key to prevent prototype pollution.`);
}
function Uo(r, e = {}) {
    if (typeof r != "string") return r;
    if (r[0] === '"' && r[r.length - 1] === '"' && r.indexOf("\\") === -1) return r.slice(1, -1);
    const t = r.trim();
    if (t.length <= 9) switch(t.toLowerCase()){
        case "true":
            return !0;
        case "false":
            return !1;
        case "undefined":
            return;
        case "null":
            return null;
        case "nan":
            return Number.NaN;
        case "infinity":
            return Number.POSITIVE_INFINITY;
        case "-infinity":
            return Number.NEGATIVE_INFINITY;
    }
    if (!AN.test(r)) {
        if (e.strict) throw new SyntaxError("[destr] Invalid JSON");
        return r;
    }
    try {
        if (DN.test(r) || _N.test(r)) {
            if (e.strict) throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(r, SN);
        }
        return JSON.parse(r);
    } catch (n) {
        if (e.strict) throw n;
        return r;
    }
}
function jN(r) {
    return !r || typeof r.then != "function" ? Promise.resolve(r) : r;
}
function bt(r, ...e) {
    try {
        return jN(r(...e));
    } catch (t) {
        return Promise.reject(t);
    }
}
function CN(r) {
    const e = typeof r;
    return r === null || e !== "object" && e !== "function";
}
function LN(r) {
    const e = Object.getPrototypeOf(r);
    return !e || e.isPrototypeOf(Object);
}
function ya(r) {
    if (CN(r)) return String(r);
    if (LN(r) || Array.isArray(r)) return JSON.stringify(r);
    if (typeof r.toJSON == "function") return ya(r.toJSON());
    throw new Error("[unstorage] Cannot stringify value!");
}
const vl = "base64:";
function kN(r) {
    return typeof r == "string" ? r : vl + UN(r);
}
function zN(r) {
    return typeof r != "string" || !r.startsWith(vl) ? r : PN(r.slice(vl.length));
}
function PN(r) {
    return globalThis.Buffer ? ye.Buffer.from(r, "base64") : Uint8Array.from(globalThis.atob(r), (e)=>e.codePointAt(0));
}
function UN(r) {
    return globalThis.Buffer ? ye.Buffer.from(r).toString("base64") : globalThis.btoa(String.fromCodePoint(...r));
}
function Ht(r) {
    var e;
    return r && ((e = r.split("?")[0]) == null ? void 0 : e.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function RN(...r) {
    return Ht(r.join(":"));
}
function Ro(r) {
    return r = Ht(r), r ? r + ":" : "";
}
function $N(r, e) {
    if (e === void 0) return !0;
    let t = 0, n = r.indexOf(":");
    for(; n > -1;)t++, n = r.indexOf(":", n + 1);
    return t <= e;
}
function BN(r, e) {
    return e ? r.startsWith(e) && r[r.length - 1] !== "$" : r[r.length - 1] !== "$";
}
const FN = "memory", qN = ()=>{
    const r = /* @__PURE__ */ new Map();
    return {
        name: FN,
        getInstance: ()=>r,
        hasItem (e) {
            return r.has(e);
        },
        getItem (e) {
            return r.get(e) ?? null;
        },
        getItemRaw (e) {
            return r.get(e) ?? null;
        },
        setItem (e, t) {
            r.set(e, t);
        },
        setItemRaw (e, t) {
            r.set(e, t);
        },
        removeItem (e) {
            r.delete(e);
        },
        getKeys () {
            return [
                ...r.keys()
            ];
        },
        clear () {
            r.clear();
        },
        dispose () {
            r.clear();
        }
    };
};
function QN(r = {}) {
    const e = {
        mounts: {
            "": r.driver || qN()
        },
        mountpoints: [
            ""
        ],
        watching: !1,
        watchListeners: [],
        unwatch: {}
    }, t = (c)=>{
        for (const l of e.mountpoints)if (c.startsWith(l)) return {
            base: l,
            relativeKey: c.slice(l.length),
            driver: e.mounts[l]
        };
        return {
            base: "",
            relativeKey: c,
            driver: e.mounts[""]
        };
    }, n = (c, l)=>e.mountpoints.filter((d)=>d.startsWith(c) || l && c.startsWith(d)).map((d)=>({
                relativeBase: c.length > d.length ? c.slice(d.length) : void 0,
                mountpoint: d,
                driver: e.mounts[d]
            })), s = (c, l)=>{
        if (e.watching) {
            l = Ht(l);
            for (const d of e.watchListeners)d(c, l);
        }
    }, i = async ()=>{
        if (!e.watching) {
            e.watching = !0;
            for(const c in e.mounts)e.unwatch[c] = await wf(e.mounts[c], s, c);
        }
    }, o = async ()=>{
        if (e.watching) {
            for(const c in e.unwatch)await e.unwatch[c]();
            e.unwatch = {}, e.watching = !1;
        }
    }, a = (c, l, d)=>{
        const h = /* @__PURE__ */ new Map(), f = (g)=>{
            let p = h.get(g.base);
            return p || (p = {
                driver: g.driver,
                base: g.base,
                items: []
            }, h.set(g.base, p)), p;
        };
        for (const g of c){
            const p = typeof g == "string", m = Ht(p ? g : g.key), x = p ? void 0 : g.value, _ = p || !g.options ? l : {
                ...l,
                ...g.options
            }, v = t(m);
            f(v).items.push({
                key: m,
                value: x,
                relativeKey: v.relativeKey,
                options: _
            });
        }
        return Promise.all([
            ...h.values()
        ].map((g)=>d(g))).then((g)=>g.flat());
    }, u = {
        // Item
        hasItem (c, l = {}) {
            c = Ht(c);
            const { relativeKey: d, driver: h } = t(c);
            return bt(h.hasItem, d, l);
        },
        getItem (c, l = {}) {
            c = Ht(c);
            const { relativeKey: d, driver: h } = t(c);
            return bt(h.getItem, d, l).then((f)=>Uo(f));
        },
        getItems (c, l = {}) {
            return a(c, l, (d)=>d.driver.getItems ? bt(d.driver.getItems, d.items.map((h)=>({
                        key: h.relativeKey,
                        options: h.options
                    })), l).then((h)=>h.map((f)=>({
                            key: RN(d.base, f.key),
                            value: Uo(f.value)
                        }))) : Promise.all(d.items.map((h)=>bt(d.driver.getItem, h.relativeKey, h.options).then((f)=>({
                            key: h.key,
                            value: Uo(f)
                        })))));
        },
        getItemRaw (c, l = {}) {
            c = Ht(c);
            const { relativeKey: d, driver: h } = t(c);
            return h.getItemRaw ? bt(h.getItemRaw, d, l) : bt(h.getItem, d, l).then((f)=>zN(f));
        },
        async setItem (c, l, d = {}) {
            if (l === void 0) return u.removeItem(c);
            c = Ht(c);
            const { relativeKey: h, driver: f } = t(c);
            f.setItem && (await bt(f.setItem, h, ya(l), d), f.watch || s("update", c));
        },
        async setItems (c, l) {
            await a(c, l, async (d)=>{
                if (d.driver.setItems) return bt(d.driver.setItems, d.items.map((h)=>({
                        key: h.relativeKey,
                        value: ya(h.value),
                        options: h.options
                    })), l);
                d.driver.setItem && await Promise.all(d.items.map((h)=>bt(d.driver.setItem, h.relativeKey, ya(h.value), h.options)));
            });
        },
        async setItemRaw (c, l, d = {}) {
            if (l === void 0) return u.removeItem(c, d);
            c = Ht(c);
            const { relativeKey: h, driver: f } = t(c);
            if (f.setItemRaw) await bt(f.setItemRaw, h, l, d);
            else if (f.setItem) await bt(f.setItem, h, kN(l), d);
            else return;
            f.watch || s("update", c);
        },
        async removeItem (c, l = {}) {
            typeof l == "boolean" && (l = {
                removeMeta: l
            }), c = Ht(c);
            const { relativeKey: d, driver: h } = t(c);
            h.removeItem && (await bt(h.removeItem, d, l), (l.removeMeta || l.removeMata) && await bt(h.removeItem, d + "$", l), h.watch || s("remove", c));
        },
        // Meta
        async getMeta (c, l = {}) {
            typeof l == "boolean" && (l = {
                nativeOnly: l
            }), c = Ht(c);
            const { relativeKey: d, driver: h } = t(c), f = /* @__PURE__ */ Object.create(null);
            if (h.getMeta && Object.assign(f, await bt(h.getMeta, d, l)), !l.nativeOnly) {
                const g = await bt(h.getItem, d + "$", l).then((p)=>Uo(p));
                g && typeof g == "object" && (typeof g.atime == "string" && (g.atime = new Date(g.atime)), typeof g.mtime == "string" && (g.mtime = new Date(g.mtime)), Object.assign(f, g));
            }
            return f;
        },
        setMeta (c, l, d = {}) {
            return this.setItem(c + "$", l, d);
        },
        removeMeta (c, l = {}) {
            return this.removeItem(c + "$", l);
        },
        // Keys
        async getKeys (c, l = {}) {
            var m;
            c = Ro(c);
            const d = n(c, !0);
            let h = [];
            const f = [];
            let g = !0;
            for (const x of d){
                (m = x.driver.flags) != null && m.maxDepth || (g = !1);
                const _ = await bt(x.driver.getKeys, x.relativeBase, l);
                for (const v of _){
                    const N = x.mountpoint + Ht(v);
                    h.some((O)=>N.startsWith(O)) || f.push(N);
                }
                h = [
                    x.mountpoint,
                    ...h.filter((v)=>!v.startsWith(x.mountpoint))
                ];
            }
            const p = l.maxDepth !== void 0 && !g;
            return f.filter((x)=>(!p || $N(x, l.maxDepth)) && BN(x, c));
        },
        // Utils
        async clear (c, l = {}) {
            c = Ro(c), await Promise.all(n(c, !1).map(async (d)=>{
                if (d.driver.clear) return bt(d.driver.clear, d.relativeBase, l);
                if (d.driver.removeItem) {
                    const h = await d.driver.getKeys(d.relativeBase || "", l);
                    return Promise.all(h.map((f)=>d.driver.removeItem(f, l)));
                }
            }));
        },
        async dispose () {
            await Promise.all(Object.values(e.mounts).map((c)=>mf(c)));
        },
        async watch (c) {
            return await i(), e.watchListeners.push(c), async ()=>{
                e.watchListeners = e.watchListeners.filter((l)=>l !== c), e.watchListeners.length === 0 && await o();
            };
        },
        async unwatch () {
            e.watchListeners = [], await o();
        },
        // Mount
        mount (c, l) {
            if (c = Ro(c), c && e.mounts[c]) throw new Error(`already mounted at ${c}`);
            return c && (e.mountpoints.push(c), e.mountpoints.sort((d, h)=>h.length - d.length)), e.mounts[c] = l, e.watching && Promise.resolve(wf(l, s, c)).then((d)=>{
                e.unwatch[c] = d;
            }).catch(console.error), u;
        },
        async unmount (c, l = !0) {
            var d, h;
            c = Ro(c), !(!c || !e.mounts[c]) && (e.watching && c in e.unwatch && ((h = (d = e.unwatch)[c]) == null || h.call(d), delete e.unwatch[c]), l && await mf(e.mounts[c]), e.mountpoints = e.mountpoints.filter((f)=>f !== c), delete e.mounts[c]);
        },
        getMount (c = "") {
            c = Ht(c) + ":";
            const l = t(c);
            return {
                driver: l.driver,
                base: l.base
            };
        },
        getMounts (c = "", l = {}) {
            return c = Ht(c), n(c, l.parents).map((h)=>({
                    driver: h.driver,
                    base: h.mountpoint
                }));
        },
        // Aliases
        keys: (c, l = {})=>u.getKeys(c, l),
        get: (c, l = {})=>u.getItem(c, l),
        set: (c, l, d = {})=>u.setItem(c, l, d),
        has: (c, l = {})=>u.hasItem(c, l),
        del: (c, l = {})=>u.removeItem(c, l),
        remove: (c, l = {})=>u.removeItem(c, l)
    };
    return u;
}
function wf(r, e, t) {
    return r.watch ? r.watch((n, s)=>e(n, t + s)) : ()=>{};
}
async function mf(r) {
    typeof r.dispose == "function" && await bt(r.dispose);
}
function ji(r) {
    return new Promise((e, t)=>{
        r.oncomplete = r.onsuccess = ()=>e(r.result), r.onabort = r.onerror = ()=>t(r.error);
    });
}
function Cy(r, e) {
    let t;
    const n = ()=>{
        if (t) return t;
        const s = indexedDB.open(r);
        return s.onupgradeneeded = ()=>s.result.createObjectStore(e), t = ji(s), t.then((i)=>{
            i.onclose = ()=>t = void 0;
        }, ()=>{}), t;
    };
    return (s, i)=>n().then((o)=>i(o.transaction(e, s).objectStore(e)));
}
let gu;
function yo() {
    return gu || (gu = Cy("keyval-store", "keyval")), gu;
}
function bf(r, e = yo()) {
    return e("readonly", (t)=>ji(t.get(r)));
}
function VN(r, e, t = yo()) {
    return t("readwrite", (n)=>(n.put(e, r), ji(n.transaction)));
}
function YN(r, e = yo()) {
    return e("readwrite", (t)=>(t.delete(r), ji(t.transaction)));
}
function GN(r = yo()) {
    return r("readwrite", (e)=>(e.clear(), ji(e.transaction)));
}
function HN(r, e) {
    return r.openCursor().onsuccess = function() {
        this.result && (e(this.result), this.result.continue());
    }, ji(r.transaction);
}
function WN(r = yo()) {
    return r("readonly", (e)=>{
        if (e.getAllKeys) return ji(e.getAllKeys());
        const t = [];
        return HN(e, (n)=>t.push(n.key)).then(()=>t);
    });
}
const KN = (r)=>JSON.stringify(r, (e, t)=>typeof t == "bigint" ? t.toString() + "n" : t), XN = (r)=>{
    const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, t = r.replace(e, '$1"$2n"$3');
    return JSON.parse(t, (n, s)=>typeof s == "string" && s.match(/^\d+n$/) ? BigInt(s.substring(0, s.length - 1)) : s);
};
function ss(r) {
    if (typeof r != "string") throw new Error(`Cannot safe json parse value of type ${typeof r}`);
    try {
        return XN(r);
    } catch  {
        return r;
    }
}
function Mi(r) {
    return typeof r == "string" ? r : KN(r) || "";
}
const ZN = "idb-keyval";
var JN = (r = {})=>{
    const e = r.base && r.base.length > 0 ? `${r.base}:` : "", t = (s)=>e + s;
    let n;
    return r.dbName && r.storeName && (n = Cy(r.dbName, r.storeName)), {
        name: ZN,
        options: r,
        async hasItem (s) {
            return !(typeof await bf(t(s), n) > "u");
        },
        async getItem (s) {
            return await bf(t(s), n) ?? null;
        },
        setItem (s, i) {
            return VN(t(s), i, n);
        },
        removeItem (s) {
            return YN(t(s), n);
        },
        getKeys () {
            return WN(n);
        },
        clear () {
            return GN(n);
        }
    };
};
const ex = "WALLET_CONNECT_V2_INDEXED_DB", tx = "keyvaluestorage";
let rx = class {
    constructor(){
        this.indexedDb = QN({
            driver: JN({
                dbName: ex,
                storeName: tx
            })
        });
    }
    async getKeys() {
        return this.indexedDb.getKeys();
    }
    async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e)=>[
                e.key,
                e.value
            ]);
    }
    async getItem(e) {
        const t = await this.indexedDb.getItem(e);
        if (t !== null) return t;
    }
    async setItem(e, t) {
        await this.indexedDb.setItem(e, Mi(t));
    }
    async removeItem(e) {
        await this.indexedDb.removeItem(e);
    }
};
var yu = typeof globalThis < "u" ? globalThis : ("TURBOPACK compile-time value", "undefined") < "u" ? window : ("TURBOPACK compile-time value", "object") < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.g : typeof self < "u" ? self : {}, wa = {
    exports: {}
};
(function() {
    let r;
    function e() {}
    r = e, r.prototype.getItem = function(t) {
        return this.hasOwnProperty(t) ? String(this[t]) : null;
    }, r.prototype.setItem = function(t, n) {
        this[t] = String(n);
    }, r.prototype.removeItem = function(t) {
        delete this[t];
    }, r.prototype.clear = function() {
        const t = this;
        Object.keys(t).forEach(function(n) {
            t[n] = void 0, delete t[n];
        });
    }, r.prototype.key = function(t) {
        return t = t || 0, Object.keys(this)[t];
    }, r.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length;
    }), typeof yu < "u" && yu.localStorage ? wa.exports = yu.localStorage : ("TURBOPACK compile-time value", "undefined") < "u" && window.localStorage ? wa.exports = window.localStorage : wa.exports = new e();
})();
function nx(r) {
    var e;
    return [
        r[0],
        ss((e = r[1]) != null ? e : "")
    ];
}
let ix = class {
    constructor(){
        this.localStorage = wa.exports;
    }
    async getKeys() {
        return Object.keys(this.localStorage);
    }
    async getEntries() {
        return Object.entries(this.localStorage).map(nx);
    }
    async getItem(e) {
        const t = this.localStorage.getItem(e);
        if (t !== null) return ss(t);
    }
    async setItem(e, t) {
        this.localStorage.setItem(e, Mi(t));
    }
    async removeItem(e) {
        this.localStorage.removeItem(e);
    }
};
const sx = "wc_storage_version", vf = 1, ox = async (r, e, t)=>{
    const n = sx, s = await e.getItem(n);
    if (s && s >= vf) {
        t(e);
        return;
    }
    const i = await r.getKeys();
    if (!i.length) {
        t(e);
        return;
    }
    const o = [];
    for(; i.length;){
        const a = i.shift();
        if (!a) continue;
        const u = a.toLowerCase();
        if (u.includes("wc@") || u.includes("walletconnect") || u.includes("wc_") || u.includes("wallet_connect")) {
            const c = await r.getItem(a);
            await e.setItem(a, c), o.push(a);
        }
    }
    await e.setItem(n, vf), t(e), ax(r, o);
}, ax = async (r, e)=>{
    e.length && e.forEach(async (t)=>{
        await r.removeItem(t);
    });
};
let cx = class {
    constructor(){
        this.initialized = !1, this.setInitialized = (t)=>{
            this.storage = t, this.initialized = !0;
        };
        const e = new ix();
        this.storage = e;
        try {
            const t = new rx();
            ox(e, t, this.setInitialized);
        } catch  {
            this.initialized = !0;
        }
    }
    async getKeys() {
        return await this.initialize(), this.storage.getKeys();
    }
    async getEntries() {
        return await this.initialize(), this.storage.getEntries();
    }
    async getItem(e) {
        return await this.initialize(), this.storage.getItem(e);
    }
    async setItem(e, t) {
        return await this.initialize(), this.storage.setItem(e, t);
    }
    async removeItem(e) {
        return await this.initialize(), this.storage.removeItem(e);
    }
    async initialize() {
        this.initialized || await new Promise((e)=>{
            const t = setInterval(()=>{
                this.initialized && (clearInterval(t), e());
            }, 20);
        });
    }
};
var Sc = {
    exports: {}
};
function ux(r) {
    try {
        return JSON.stringify(r);
    } catch  {
        return '"[Circular]"';
    }
}
var lx = dx;
function dx(r, e, t) {
    var n = t && t.stringify || ux, s = 1;
    if (typeof r == "object" && r !== null) {
        var i = e.length + s;
        if (i === 1) return r;
        var o = new Array(i);
        o[0] = n(r);
        for(var a = 1; a < i; a++)o[a] = n(e[a]);
        return o.join(" ");
    }
    if (typeof r != "string") return r;
    var u = e.length;
    if (u === 0) return r;
    for(var c = "", l = 1 - s, d = -1, h = r && r.length || 0, f = 0; f < h;){
        if (r.charCodeAt(f) === 37 && f + 1 < h) {
            switch(d = d > -1 ? d : 0, r.charCodeAt(f + 1)){
                case 100:
                case 102:
                    if (l >= u || e[l] == null) break;
                    d < f && (c += r.slice(d, f)), c += Number(e[l]), d = f + 2, f++;
                    break;
                case 105:
                    if (l >= u || e[l] == null) break;
                    d < f && (c += r.slice(d, f)), c += Math.floor(Number(e[l])), d = f + 2, f++;
                    break;
                case 79:
                case 111:
                case 106:
                    if (l >= u || e[l] === void 0) break;
                    d < f && (c += r.slice(d, f));
                    var g = typeof e[l];
                    if (g === "string") {
                        c += "'" + e[l] + "'", d = f + 2, f++;
                        break;
                    }
                    if (g === "function") {
                        c += e[l].name || "<anonymous>", d = f + 2, f++;
                        break;
                    }
                    c += n(e[l]), d = f + 2, f++;
                    break;
                case 115:
                    if (l >= u) break;
                    d < f && (c += r.slice(d, f)), c += String(e[l]), d = f + 2, f++;
                    break;
                case 37:
                    d < f && (c += r.slice(d, f)), c += "%", d = f + 2, f++, l--;
                    break;
            }
            ++l;
        }
        ++f;
    }
    return d === -1 ? r : (d < h && (c += r.slice(d)), c);
}
const Ef = lx;
Sc.exports = gn;
const oo = Tx().console || {}, hx = {
    mapHttpRequest: $o,
    mapHttpResponse: $o,
    wrapRequestSerializer: wu,
    wrapResponseSerializer: wu,
    wrapErrorSerializer: wu,
    req: $o,
    res: $o,
    err: Nf,
    errWithCause: Nf
};
function Vn(r, e) {
    return r === "silent" ? 1 / 0 : e.levels.values[r];
}
const Dd = Symbol("pino.logFuncs"), El = Symbol("pino.hierarchy"), fx = {
    error: "log",
    fatal: "error",
    warn: "error",
    info: "log",
    debug: "log",
    trace: "log"
};
function Mf(r, e) {
    const t = {
        logger: e,
        parent: r[El]
    };
    e[El] = t;
}
function px(r, e, t) {
    const n = {};
    e.forEach((s)=>{
        n[s] = t[s] ? t[s] : oo[s] || oo[fx[s] || "log"] || Ji;
    }), r[Dd] = n;
}
function gx(r, e) {
    return Array.isArray(r) ? r.filter(function(n) {
        return n !== "!stdSerializers.err";
    }) : r === !0 ? Object.keys(e) : !1;
}
function gn(r) {
    r = r || {}, r.browser = r.browser || {};
    const e = r.browser.transmit;
    if (e && typeof e.send != "function") throw Error("pino: transmit option must have a send function");
    const t = r.browser.write || oo;
    r.browser.write && (r.browser.asObject = !0);
    const n = r.serializers || {}, s = gx(r.browser.serialize, n);
    let i = r.browser.serialize;
    Array.isArray(r.browser.serialize) && r.browser.serialize.indexOf("!stdSerializers.err") > -1 && (i = !1);
    const o = Object.keys(r.customLevels || {}), a = [
        "error",
        "fatal",
        "warn",
        "info",
        "debug",
        "trace"
    ].concat(o);
    typeof t == "function" && a.forEach(function(p) {
        t[p] = t;
    }), (r.enabled === !1 || r.browser.disabled) && (r.level = "silent");
    const u = r.level || "info", c = Object.create(t);
    c.log || (c.log = Ji), px(c, a, t), Mf({}, c), Object.defineProperty(c, "levelVal", {
        get: d
    }), Object.defineProperty(c, "level", {
        get: h,
        set: f
    });
    const l = {
        transmit: e,
        serialize: s,
        asObject: r.browser.asObject,
        asObjectBindingsOnly: r.browser.asObjectBindingsOnly,
        formatters: r.browser.formatters,
        levels: a,
        timestamp: Nx(r),
        messageKey: r.messageKey || "msg",
        onChild: r.onChild || Ji
    };
    c.levels = yx(r), c.level = u, c.isLevelEnabled = function(p) {
        return this.levels.values[p] ? this.levels.values[p] >= this.levels.values[this.level] : !1;
    }, c.setMaxListeners = c.getMaxListeners = c.emit = c.addListener = c.on = c.prependListener = c.once = c.prependOnceListener = c.removeListener = c.removeAllListeners = c.listeners = c.listenerCount = c.eventNames = c.write = c.flush = Ji, c.serializers = n, c._serialize = s, c._stdErrSerialize = i, c.child = function(...p) {
        return g.call(this, l, ...p);
    }, e && (c._logEvent = Ml());
    function d() {
        return Vn(this.level, this);
    }
    function h() {
        return this._level;
    }
    function f(p) {
        if (p !== "silent" && !this.levels.values[p]) throw Error("unknown level " + p);
        this._level = p, si(this, l, c, "error"), si(this, l, c, "fatal"), si(this, l, c, "warn"), si(this, l, c, "info"), si(this, l, c, "debug"), si(this, l, c, "trace"), o.forEach((m)=>{
            si(this, l, c, m);
        });
    }
    function g(p, m, x) {
        if (!m) throw new Error("missing bindings for child Pino");
        x = x || {}, s && m.serializers && (x.serializers = m.serializers);
        const _ = x.serializers;
        if (s && _) {
            var v = Object.assign({}, n, _), N = r.browser.serialize === !0 ? Object.keys(v) : s;
            delete m.serializers, _d([
                m
            ], N, v, this._stdErrSerialize);
        }
        function O(P) {
            this._childLevel = (P._childLevel | 0) + 1, this.bindings = m, v && (this.serializers = v, this._serialize = N), e && (this._logEvent = Ml([].concat(P._logEvent.bindings, m)));
        }
        O.prototype = this;
        const z = new O(this);
        return Mf(this, z), z.child = function(...P) {
            return g.call(this, p, ...P);
        }, z.level = x.level || this.level, p.onChild(z), z;
    }
    return c;
}
function yx(r) {
    const e = r.customLevels || {}, t = Object.assign({}, gn.levels.values, e), n = Object.assign({}, gn.levels.labels, wx(e));
    return {
        values: t,
        labels: n
    };
}
function wx(r) {
    const e = {};
    return Object.keys(r).forEach(function(t) {
        e[r[t]] = t;
    }), e;
}
gn.levels = {
    values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
    },
    labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
    }
};
gn.stdSerializers = hx;
gn.stdTimeFunctions = Object.assign({}, {
    nullTime: Ly,
    epochTime: ky,
    unixTime: xx,
    isoTime: Ix
});
function mx(r) {
    const e = [];
    r.bindings && e.push(r.bindings);
    let t = r[El];
    for(; t.parent;)t = t.parent, t.logger.bindings && e.push(t.logger.bindings);
    return e.reverse();
}
function si(r, e, t, n) {
    if (Object.defineProperty(r, n, {
        value: Vn(r.level, t) > Vn(n, t) ? Ji : t[Dd][n],
        writable: !0,
        enumerable: !0,
        configurable: !0
    }), r[n] === Ji) {
        if (!e.transmit) return;
        const i = e.transmit.level || r.level, o = Vn(i, t);
        if (Vn(n, t) < o) return;
    }
    r[n] = vx(r, e, t, n);
    const s = mx(r);
    s.length !== 0 && (r[n] = bx(s, r[n]));
}
function bx(r, e) {
    return function() {
        return e.apply(this, [
            ...r,
            ...arguments
        ]);
    };
}
function vx(r, e, t, n) {
    return /* @__PURE__ */ function(s) {
        return function() {
            const o = e.timestamp(), a = new Array(arguments.length), u = Object.getPrototypeOf && Object.getPrototypeOf(this) === oo ? oo : this;
            for(var c = 0; c < a.length; c++)a[c] = arguments[c];
            var l = !1;
            if (e.serialize && (_d(a, this._serialize, this.serializers, this._stdErrSerialize), l = !0), e.asObject || e.formatters ? s.call(u, ...Ex(this, n, a, o, e)) : s.apply(u, a), e.transmit) {
                const d = e.transmit.level || r._level, h = Vn(d, t), f = Vn(n, t);
                if (f < h) return;
                Mx(this, {
                    ts: o,
                    methodLevel: n,
                    methodValue: f,
                    transmitValue: t.levels.values[e.transmit.level || r._level],
                    send: e.transmit.send,
                    val: Vn(r._level, t)
                }, a, l);
            }
        };
    }(r[Dd][n]);
}
function Ex(r, e, t, n, s) {
    const { level: i, log: o = (d)=>d } = s.formatters || {}, a = t.slice();
    let u = a[0];
    const c = {};
    let l = (r._childLevel | 0) + 1;
    if (l < 1 && (l = 1), n && (c.time = n), i) {
        const d = i(e, r.levels.values[e]);
        Object.assign(c, d);
    } else c.level = r.levels.values[e];
    if (s.asObjectBindingsOnly) {
        if (u !== null && typeof u == "object") for(; l-- && typeof a[0] == "object";)Object.assign(c, a.shift());
        return [
            o(c),
            ...a
        ];
    } else {
        if (u !== null && typeof u == "object") {
            for(; l-- && typeof a[0] == "object";)Object.assign(c, a.shift());
            u = a.length ? Ef(a.shift(), a) : void 0;
        } else typeof u == "string" && (u = Ef(a.shift(), a));
        return u !== void 0 && (c[s.messageKey] = u), [
            o(c)
        ];
    }
}
function _d(r, e, t, n) {
    for(const s in r)if (n && r[s] instanceof Error) r[s] = gn.stdSerializers.err(r[s]);
    else if (typeof r[s] == "object" && !Array.isArray(r[s]) && e) for(const i in r[s])e.indexOf(i) > -1 && i in t && (r[s][i] = t[i](r[s][i]));
}
function Mx(r, e, t, n = !1) {
    const s = e.send, i = e.ts, o = e.methodLevel, a = e.methodValue, u = e.val, c = r._logEvent.bindings;
    n || _d(t, r._serialize || Object.keys(r.serializers), r.serializers, r._stdErrSerialize === void 0 ? !0 : r._stdErrSerialize), r._logEvent.ts = i, r._logEvent.messages = t.filter(function(l) {
        return c.indexOf(l) === -1;
    }), r._logEvent.level.label = o, r._logEvent.level.value = a, s(o, r._logEvent, u), r._logEvent = Ml(c);
}
function Ml(r) {
    return {
        ts: 0,
        messages: [],
        bindings: r || [],
        level: {
            label: "",
            value: 0
        }
    };
}
function Nf(r) {
    const e = {
        type: r.constructor.name,
        msg: r.message,
        stack: r.stack
    };
    for(const t in r)e[t] === void 0 && (e[t] = r[t]);
    return e;
}
function Nx(r) {
    return typeof r.timestamp == "function" ? r.timestamp : r.timestamp === !1 ? Ly : ky;
}
function $o() {
    return {};
}
function wu(r) {
    return r;
}
function Ji() {}
function Ly() {
    return !1;
}
function ky() {
    return Date.now();
}
function xx() {
    return Math.round(Date.now() / 1e3);
}
function Ix() {
    return new Date(Date.now()).toISOString();
}
function Tx() {
    function r(e) {
        return typeof e < "u" && e;
    }
    try {
        return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
            get: function() {
                return delete Object.prototype.globalThis, this.globalThis = this;
            },
            configurable: !0
        }), globalThis;
    } catch  {
        return r(self) || r(window) || r(this) || {};
    }
}
Sc.exports.default = gn;
Sc.exports.pino = gn;
var Wi = Sc.exports;
const zy = /* @__PURE__ */ Di(Wi), Dx = {
    level: "info"
}, Oc = "custom_context", Ad = 1e3 * 1024;
var _x = Object.defineProperty, Ax = (r, e, t)=>e in r ? _x(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Bn = (r, e, t)=>Ax(r, typeof e != "symbol" ? e + "" : e, t);
let Sx = class {
    constructor(e){
        Bn(this, "nodeValue"), Bn(this, "sizeInBytes"), Bn(this, "next"), this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
    }
    get value() {
        return this.nodeValue;
    }
    get size() {
        return this.sizeInBytes;
    }
}, xf = class {
    constructor(e){
        Bn(this, "lengthInNodes"), Bn(this, "sizeInBytes"), Bn(this, "head"), Bn(this, "tail"), Bn(this, "maxSizeInBytes"), this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
    }
    append(e) {
        const t = new Sx(e);
        if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
        for(; this.size + t.size > this.maxSizeInBytes;)this.shift();
        this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
    }
    shift() {
        if (!this.head) return;
        const e = this.head;
        this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
    }
    toArray() {
        const e = [];
        let t = this.head;
        for(; t !== null;)e.push(t.value), t = t.next;
        return e;
    }
    get length() {
        return this.lengthInNodes;
    }
    get size() {
        return this.sizeInBytes;
    }
    toOrderedArray() {
        return Array.from(this);
    }
    [Symbol.iterator]() {
        let e = this.head;
        return {
            next: ()=>{
                if (!e) return {
                    done: !0,
                    value: null
                };
                const t = e.value;
                return e = e.next, {
                    done: !1,
                    value: t
                };
            }
        };
    }
};
var Ox = Object.defineProperty, jx = (r, e, t)=>e in r ? Ox(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Bo = (r, e, t)=>jx(r, typeof e != "symbol" ? e + "" : e, t);
class Py {
    constructor(e, t = Ad){
        Bo(this, "logs"), Bo(this, "level"), Bo(this, "levelValue"), Bo(this, "MAX_LOG_SIZE_IN_BYTES"), this.level = e ?? "error", this.levelValue = Wi.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new xf(this.MAX_LOG_SIZE_IN_BYTES);
    }
    forwardToConsole(e, t) {
        t === Wi.levels.values.error ? console.error(e) : t === Wi.levels.values.warn ? console.warn(e) : t === Wi.levels.values.debug ? console.debug(e) : t === Wi.levels.values.trace ? console.trace(e) : console.log(e);
    }
    appendToLogs(e) {
        this.logs.append(Mi({
            timestamp: /* @__PURE__ */ new Date().toISOString(),
            log: e
        }));
        const t = typeof e == "string" ? JSON.parse(e).level : e.level;
        t >= this.levelValue && this.forwardToConsole(e, t);
    }
    getLogs() {
        return this.logs;
    }
    clearLogs() {
        this.logs = new xf(this.MAX_LOG_SIZE_IN_BYTES);
    }
    getLogArray() {
        return Array.from(this.logs);
    }
    logsToBlob(e) {
        const t = this.getLogArray();
        return t.push(Mi({
            extraMetadata: e
        })), new Blob(t, {
            type: "application/json"
        });
    }
}
var Cx = Object.defineProperty, Lx = (r, e, t)=>e in r ? Cx(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, kx = (r, e, t)=>Lx(r, e + "", t);
class zx {
    constructor(e, t = Ad){
        kx(this, "baseChunkLogger"), this.baseChunkLogger = new Py(e, t);
    }
    write(e) {
        this.baseChunkLogger.appendToLogs(e);
    }
    getLogs() {
        return this.baseChunkLogger.getLogs();
    }
    clearLogs() {
        this.baseChunkLogger.clearLogs();
    }
    getLogArray() {
        return this.baseChunkLogger.getLogArray();
    }
    logsToBlob(e) {
        return this.baseChunkLogger.logsToBlob(e);
    }
    downloadLogsBlobInBrowser(e) {
        const t = URL.createObjectURL(this.logsToBlob(e)), n = document.createElement("a");
        n.href = t, n.download = `walletconnect-logs-${/* @__PURE__ */ new Date().toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(t);
    }
}
var Px = Object.defineProperty, Ux = (r, e, t)=>e in r ? Px(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Rx = (r, e, t)=>Ux(r, e + "", t);
let $x = class {
    constructor(e, t = Ad){
        Rx(this, "baseChunkLogger"), this.baseChunkLogger = new Py(e, t);
    }
    write(e) {
        this.baseChunkLogger.appendToLogs(e);
    }
    getLogs() {
        return this.baseChunkLogger.getLogs();
    }
    clearLogs() {
        this.baseChunkLogger.clearLogs();
    }
    getLogArray() {
        return this.baseChunkLogger.getLogArray();
    }
    logsToBlob(e) {
        return this.baseChunkLogger.logsToBlob(e);
    }
};
var Bx = Object.defineProperty, Fx = Object.defineProperties, qx = Object.getOwnPropertyDescriptors, If = Object.getOwnPropertySymbols, Qx = Object.prototype.hasOwnProperty, Vx = Object.prototype.propertyIsEnumerable, Tf = (r, e, t)=>e in r ? Bx(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, _a = (r, e)=>{
    for(var t in e || (e = {}))Qx.call(e, t) && Tf(r, t, e[t]);
    if (If) for (var t of If(e))Vx.call(e, t) && Tf(r, t, e[t]);
    return r;
}, Aa = (r, e)=>Fx(r, qx(e));
function Yx(r) {
    return Aa(_a({}, r), {
        level: (r == null ? void 0 : r.level) || Dx.level
    });
}
function Gx(r, e, t = Oc) {
    return r[t] = e, r;
}
function nr(r, e = Oc) {
    return r[e] || "";
}
function Hx(r, e, t = Oc) {
    const n = nr(r, t);
    return n.trim() ? `${n}/${e}` : e;
}
function ur(r, e, t = Oc) {
    const n = Hx(r, e, t), s = r.child({
        context: n
    });
    return Gx(s, n, t);
}
function Wx(r) {
    var e, t;
    const n = new zx((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);
    return {
        logger: zy(Aa(_a({}, r.opts), {
            level: "trace",
            browser: Aa(_a({}, (t = r.opts) == null ? void 0 : t.browser), {
                write: (s)=>n.write(s)
            })
        })),
        chunkLoggerController: n
    };
}
function Kx(r) {
    var e;
    const t = new $x((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);
    return {
        logger: zy(Aa(_a({}, r.opts), {
            level: "trace"
        }), t),
        chunkLoggerController: t
    };
}
function Uy(r) {
    return typeof r.loggerOverride < "u" && typeof r.loggerOverride != "string" ? {
        logger: r.loggerOverride,
        chunkLoggerController: null
    } : ("TURBOPACK compile-time value", "undefined") < "u" ? Wx(r) : Kx(r);
}
var Xx = Object.defineProperty, Zx = (r, e, t)=>e in r ? Xx(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Df = (r, e, t)=>Zx(r, typeof e != "symbol" ? e + "" : e, t);
let Jx = class extends Si {
    constructor(e){
        super(), this.opts = e, Df(this, "protocol", "wc"), Df(this, "version", 2);
    }
};
var eI = Object.defineProperty, tI = (r, e, t)=>e in r ? eI(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, rI = (r, e, t)=>tI(r, e + "", t);
class nI extends Si {
    constructor(e, t){
        super(), this.core = e, this.logger = t, rI(this, "records", /* @__PURE__ */ new Map());
    }
}
let iI = class {
    constructor(e, t){
        this.logger = e, this.core = t;
    }
}, sI = class extends Si {
    constructor(e, t){
        super(), this.relayer = e, this.logger = t;
    }
}, oI = class extends Si {
    constructor(e){
        super();
    }
}, aI = class {
    constructor(e, t, n, s){
        this.core = e, this.logger = t, this.name = n;
    }
}, cI = class extends Si {
    constructor(e, t){
        super(), this.relayer = e, this.logger = t;
    }
}, uI = class extends Si {
    constructor(e, t){
        super(), this.core = e, this.logger = t;
    }
}, lI = class {
    constructor(e, t, n){
        this.core = e, this.logger = t, this.store = n;
    }
}, dI = class {
    constructor(e, t){
        this.projectId = e, this.logger = t;
    }
}, hI = class {
    constructor(e, t, n){
        this.core = e, this.logger = t, this.telemetryEnabled = n;
    }
};
var fI = Object.defineProperty, pI = (r, e, t)=>e in r ? fI(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, _f = (r, e, t)=>pI(r, typeof e != "symbol" ? e + "" : e, t);
let gI = class {
    constructor(e){
        this.opts = e, _f(this, "protocol", "wc"), _f(this, "version", 2);
    }
}, yI = class {
    constructor(e){
        this.client = e;
    }
};
function wI(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Ry(r, ...e) {
    if (!wI(r)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function Af(r, e = !0) {
    if (r.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function mI(r, e) {
    Ry(r);
    const t = e.outputLen;
    if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
const $i = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const mu = (r)=>new DataView(r.buffer, r.byteOffset, r.byteLength);
function bI(r) {
    if (typeof r != "string") throw new Error("utf8ToBytes expected string, got " + typeof r);
    return new Uint8Array(new TextEncoder().encode(r));
}
function $y(r) {
    return typeof r == "string" && (r = bI(r)), Ry(r), r;
}
let vI = class {
    clone() {
        return this._cloneInto();
    }
};
function EI(r) {
    const e = (n)=>r().update($y(n)).digest(), t = r();
    return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = ()=>r(), e;
}
function By(r = 32) {
    if ($i && typeof $i.getRandomValues == "function") return $i.getRandomValues(new Uint8Array(r));
    if ($i && typeof $i.randomBytes == "function") return $i.randomBytes(r);
    throw new Error("crypto.getRandomValues must be defined");
}
function MI(r, e, t, n) {
    if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
    const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), u = n ? 4 : 0, c = n ? 0 : 4;
    r.setUint32(e + u, o, n), r.setUint32(e + c, a, n);
}
let NI = class extends vI {
    constructor(e, t, n, s){
        super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = mu(this.buffer);
    }
    update(e) {
        Af(this);
        const { view: t, buffer: n, blockLen: s } = this;
        e = $y(e);
        const i = e.length;
        for(let o = 0; o < i;){
            const a = Math.min(s - this.pos, i - o);
            if (a === s) {
                const u = mu(e);
                for(; s <= i - o; o += s)this.process(u, o);
                continue;
            }
            n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        Af(this), mI(e, this), this.finished = !0;
        const { buffer: t, view: n, blockLen: s, isLE: i } = this;
        let { pos: o } = this;
        t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
        for(let d = o; d < s; d++)t[d] = 0;
        MI(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
        const a = mu(e), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = u / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let d = 0; d < c; d++)a.setUint32(4 * d, l[d], i);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const n = e.slice(0, t);
        return this.destroy(), n;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
        return e.length = s, e.pos = a, e.finished = i, e.destroyed = o, s % t && e.buffer.set(n), e;
    }
};
const Fo = BigInt(2 ** 32 - 1), Nl = BigInt(32);
function Fy(r, e = !1) {
    return e ? {
        h: Number(r & Fo),
        l: Number(r >> Nl & Fo)
    } : {
        h: Number(r >> Nl & Fo) | 0,
        l: Number(r & Fo) | 0
    };
}
function xI(r, e = !1) {
    let t = new Uint32Array(r.length), n = new Uint32Array(r.length);
    for(let s = 0; s < r.length; s++){
        const { h: i, l: o } = Fy(r[s], e);
        [t[s], n[s]] = [
            i,
            o
        ];
    }
    return [
        t,
        n
    ];
}
const II = (r, e)=>BigInt(r >>> 0) << Nl | BigInt(e >>> 0), TI = (r, e, t)=>r >>> t, DI = (r, e, t)=>r << 32 - t | e >>> t, _I = (r, e, t)=>r >>> t | e << 32 - t, AI = (r, e, t)=>r << 32 - t | e >>> t, SI = (r, e, t)=>r << 64 - t | e >>> t - 32, OI = (r, e, t)=>r >>> t - 32 | e << 64 - t, jI = (r, e)=>e, CI = (r, e)=>r, LI = (r, e, t)=>r << t | e >>> 32 - t, kI = (r, e, t)=>e << t | r >>> 32 - t, zI = (r, e, t)=>e << t - 32 | r >>> 64 - t, PI = (r, e, t)=>r << t - 32 | e >>> 64 - t;
function UI(r, e, t, n) {
    const s = (e >>> 0) + (n >>> 0);
    return {
        h: r + t + (s / 2 ** 32 | 0) | 0,
        l: s | 0
    };
}
const RI = (r, e, t)=>(r >>> 0) + (e >>> 0) + (t >>> 0), $I = (r, e, t, n)=>e + t + n + (r / 2 ** 32 | 0) | 0, BI = (r, e, t, n)=>(r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0), FI = (r, e, t, n, s)=>e + t + n + s + (r / 2 ** 32 | 0) | 0, qI = (r, e, t, n, s)=>(r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0), QI = (r, e, t, n, s, i)=>e + t + n + s + i + (r / 2 ** 32 | 0) | 0, Te = {
    fromBig: Fy,
    split: xI,
    toBig: II,
    shrSH: TI,
    shrSL: DI,
    rotrSH: _I,
    rotrSL: AI,
    rotrBH: SI,
    rotrBL: OI,
    rotr32H: jI,
    rotr32L: CI,
    rotlSH: LI,
    rotlSL: kI,
    rotlBH: zI,
    rotlBL: PI,
    add: UI,
    add3L: RI,
    add3H: $I,
    add4L: BI,
    add4H: FI,
    add5H: QI,
    add5L: qI
}, [VI, YI] = Te.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((r)=>BigInt(r))), mn = new Uint32Array(80), bn = new Uint32Array(80);
let GI = class extends NI {
    constructor(){
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
    }
    get() {
        const { Ah: e, Al: t, Bh: n, Bl: s, Ch: i, Cl: o, Dh: a, Dl: u, Eh: c, El: l, Fh: d, Fl: h, Gh: f, Gl: g, Hh: p, Hl: m } = this;
        return [
            e,
            t,
            n,
            s,
            i,
            o,
            a,
            u,
            c,
            l,
            d,
            h,
            f,
            g,
            p,
            m
        ];
    }
    set(e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, m) {
        this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = c | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = h | 0, this.Gh = f | 0, this.Gl = g | 0, this.Hh = p | 0, this.Hl = m | 0;
    }
    process(e, t) {
        for(let v = 0; v < 16; v++, t += 4)mn[v] = e.getUint32(t), bn[v] = e.getUint32(t += 4);
        for(let v = 16; v < 80; v++){
            const N = mn[v - 15] | 0, O = bn[v - 15] | 0, z = Te.rotrSH(N, O, 1) ^ Te.rotrSH(N, O, 8) ^ Te.shrSH(N, O, 7), P = Te.rotrSL(N, O, 1) ^ Te.rotrSL(N, O, 8) ^ Te.shrSL(N, O, 7), U = mn[v - 2] | 0, R = bn[v - 2] | 0, G = Te.rotrSH(U, R, 19) ^ Te.rotrBH(U, R, 61) ^ Te.shrSH(U, R, 6), F = Te.rotrSL(U, R, 19) ^ Te.rotrBL(U, R, 61) ^ Te.shrSL(U, R, 6), H = Te.add4L(P, F, bn[v - 7], bn[v - 16]), B = Te.add4H(H, z, G, mn[v - 7], mn[v - 16]);
            mn[v] = B | 0, bn[v] = H | 0;
        }
        let { Ah: n, Al: s, Bh: i, Bl: o, Ch: a, Cl: u, Dh: c, Dl: l, Eh: d, El: h, Fh: f, Fl: g, Gh: p, Gl: m, Hh: x, Hl: _ } = this;
        for(let v = 0; v < 80; v++){
            const N = Te.rotrSH(d, h, 14) ^ Te.rotrSH(d, h, 18) ^ Te.rotrBH(d, h, 41), O = Te.rotrSL(d, h, 14) ^ Te.rotrSL(d, h, 18) ^ Te.rotrBL(d, h, 41), z = d & f ^ ~d & p, P = h & g ^ ~h & m, U = Te.add5L(_, O, P, YI[v], bn[v]), R = Te.add5H(U, x, N, z, VI[v], mn[v]), G = U | 0, F = Te.rotrSH(n, s, 28) ^ Te.rotrBH(n, s, 34) ^ Te.rotrBH(n, s, 39), H = Te.rotrSL(n, s, 28) ^ Te.rotrBL(n, s, 34) ^ Te.rotrBL(n, s, 39), B = n & i ^ n & a ^ i & a, C = s & o ^ s & u ^ o & u;
            x = p | 0, _ = m | 0, p = f | 0, m = g | 0, f = d | 0, g = h | 0, ({ h: d, l: h } = Te.add(c | 0, l | 0, R | 0, G | 0)), c = a | 0, l = u | 0, a = i | 0, u = o | 0, i = n | 0, o = s | 0;
            const T = Te.add3L(G, H, C);
            n = Te.add3H(T, R, F, B), s = T | 0;
        }
        ({ h: n, l: s } = Te.add(this.Ah | 0, this.Al | 0, n | 0, s | 0)), ({ h: i, l: o } = Te.add(this.Bh | 0, this.Bl | 0, i | 0, o | 0)), ({ h: a, l: u } = Te.add(this.Ch | 0, this.Cl | 0, a | 0, u | 0)), ({ h: c, l } = Te.add(this.Dh | 0, this.Dl | 0, c | 0, l | 0)), ({ h: d, l: h } = Te.add(this.Eh | 0, this.El | 0, d | 0, h | 0)), ({ h: f, l: g } = Te.add(this.Fh | 0, this.Fl | 0, f | 0, g | 0)), ({ h: p, l: m } = Te.add(this.Gh | 0, this.Gl | 0, p | 0, m | 0)), ({ h: x, l: _ } = Te.add(this.Hh | 0, this.Hl | 0, x | 0, _ | 0)), this.set(n, s, i, o, a, u, c, l, d, h, f, g, p, m, x, _);
    }
    roundClean() {
        mn.fill(0), bn.fill(0);
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
};
const HI = EI(()=>new GI());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Sd = BigInt(0), qy = BigInt(1), WI = BigInt(2);
function Od(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function jd(r) {
    if (!Od(r)) throw new Error("Uint8Array expected");
}
function bu(r, e) {
    if (typeof e != "boolean") throw new Error(r + " boolean expected, got " + e);
}
const KI = Array.from({
    length: 256
}, (r, e)=>e.toString(16).padStart(2, "0"));
function Cd(r) {
    jd(r);
    let e = "";
    for(let t = 0; t < r.length; t++)e += KI[r[t]];
    return e;
}
function Qy(r) {
    if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
    return r === "" ? Sd : BigInt("0x" + r);
}
const Kr = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function Sf(r) {
    if (r >= Kr._0 && r <= Kr._9) return r - Kr._0;
    if (r >= Kr.A && r <= Kr.F) return r - (Kr.A - 10);
    if (r >= Kr.a && r <= Kr.f) return r - (Kr.a - 10);
}
function Vy(r) {
    if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
    const e = r.length, t = e / 2;
    if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(t);
    for(let s = 0, i = 0; s < t; s++, i += 2){
        const o = Sf(r.charCodeAt(i)), a = Sf(r.charCodeAt(i + 1));
        if (o === void 0 || a === void 0) {
            const u = r[i] + r[i + 1];
            throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + i);
        }
        n[s] = o * 16 + a;
    }
    return n;
}
function XI(r) {
    return Qy(Cd(r));
}
function ma(r) {
    return jd(r), Qy(Cd(Uint8Array.from(r).reverse()));
}
function Yy(r, e) {
    return Vy(r.toString(16).padStart(e * 2, "0"));
}
function xl(r, e) {
    return Yy(r, e).reverse();
}
function Xr(r, e, t) {
    let n;
    if (typeof e == "string") try {
        n = Vy(e);
    } catch (i) {
        throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
    }
    else if (Od(e)) n = Uint8Array.from(e);
    else throw new Error(r + " must be hex string or Uint8Array");
    const s = n.length;
    if (typeof t == "number" && s !== t) throw new Error(r + " of length " + t + " expected, got " + s);
    return n;
}
function Of(...r) {
    let e = 0;
    for(let n = 0; n < r.length; n++){
        const s = r[n];
        jd(s), e += s.length;
    }
    const t = new Uint8Array(e);
    for(let n = 0, s = 0; n < r.length; n++){
        const i = r[n];
        t.set(i, s), s += i.length;
    }
    return t;
}
const vu = (r)=>typeof r == "bigint" && Sd <= r;
function ZI(r, e, t) {
    return vu(r) && vu(e) && vu(t) && e <= r && r < t;
}
function js(r, e, t, n) {
    if (!ZI(e, t, n)) throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function JI(r) {
    let e;
    for(e = 0; r > Sd; r >>= qy, e += 1);
    return e;
}
const e2 = (r)=>(WI << BigInt(r - 1)) - qy, t2 = {
    bigint: (r)=>typeof r == "bigint",
    function: (r)=>typeof r == "function",
    boolean: (r)=>typeof r == "boolean",
    string: (r)=>typeof r == "string",
    stringOrUint8Array: (r)=>typeof r == "string" || Od(r),
    isSafeInteger: (r)=>Number.isSafeInteger(r),
    array: (r)=>Array.isArray(r),
    field: (r, e)=>e.Fp.isValid(r),
    hash: (r)=>typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function Ld(r, e, t = {}) {
    const n = (s, i, o)=>{
        const a = t2[i];
        if (typeof a != "function") throw new Error("invalid validator function");
        const u = r[s];
        if (!(o && u === void 0) && !a(u, r)) throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + u);
    };
    for (const [s, i] of Object.entries(e))n(s, i, !1);
    for (const [s, i] of Object.entries(t))n(s, i, !0);
    return r;
}
function jf(r) {
    const e = /* @__PURE__ */ new WeakMap();
    return (t, ...n)=>{
        const s = e.get(t);
        if (s !== void 0) return s;
        const i = r(t, ...n);
        return e.set(t, i), i;
    };
}
const Et = BigInt(0), ot = BigInt(1), hi = BigInt(2), r2 = BigInt(3), Il = BigInt(4), Cf = BigInt(5), Lf = BigInt(8);
function ft(r, e) {
    const t = r % e;
    return t >= Et ? t : e + t;
}
function n2(r, e, t) {
    if (e < Et) throw new Error("invalid exponent, negatives unsupported");
    if (t <= Et) throw new Error("invalid modulus");
    if (t === ot) return Et;
    let n = ot;
    for(; e > Et;)e & ot && (n = n * r % t), r = r * r % t, e >>= ot;
    return n;
}
function Cr(r, e, t) {
    let n = r;
    for(; e-- > Et;)n *= n, n %= t;
    return n;
}
function kf(r, e) {
    if (r === Et) throw new Error("invert: expected non-zero number");
    if (e <= Et) throw new Error("invert: expected positive modulus, got " + e);
    let t = ft(r, e), n = e, s = Et, i = ot;
    for(; t !== Et;){
        const o = n / t, a = n % t, u = s - i * o;
        n = t, t = a, s = i, i = u;
    }
    if (n !== ot) throw new Error("invert: does not exist");
    return ft(s, e);
}
function i2(r) {
    const e = (r - ot) / hi;
    let t, n, s;
    for(t = r - ot, n = 0; t % hi === Et; t /= hi, n++);
    for(s = hi; s < r && n2(s, e, r) !== r - ot; s++)if (s > 1e3) throw new Error("Cannot find square root: likely non-prime P");
    if (n === 1) {
        const o = (r + ot) / Il;
        return function(a, u) {
            const c = a.pow(u, o);
            if (!a.eql(a.sqr(c), u)) throw new Error("Cannot find square root");
            return c;
        };
    }
    const i = (t + ot) / hi;
    return function(o, a) {
        if (o.pow(a, e) === o.neg(o.ONE)) throw new Error("Cannot find square root");
        let u = n, c = o.pow(o.mul(o.ONE, s), t), l = o.pow(a, i), d = o.pow(a, t);
        for(; !o.eql(d, o.ONE);){
            if (o.eql(d, o.ZERO)) return o.ZERO;
            let h = 1;
            for(let g = o.sqr(d); h < u && !o.eql(g, o.ONE); h++)g = o.sqr(g);
            const f = o.pow(c, ot << BigInt(u - h - 1));
            c = o.sqr(f), l = o.mul(l, f), d = o.mul(d, c), u = h;
        }
        return l;
    };
}
function s2(r) {
    if (r % Il === r2) {
        const e = (r + ot) / Il;
        return function(t, n) {
            const s = t.pow(n, e);
            if (!t.eql(t.sqr(s), n)) throw new Error("Cannot find square root");
            return s;
        };
    }
    if (r % Lf === Cf) {
        const e = (r - Cf) / Lf;
        return function(t, n) {
            const s = t.mul(n, hi), i = t.pow(s, e), o = t.mul(n, i), a = t.mul(t.mul(o, hi), i), u = t.mul(o, t.sub(a, t.ONE));
            if (!t.eql(t.sqr(u), n)) throw new Error("Cannot find square root");
            return u;
        };
    }
    return i2(r);
}
const o2 = (r, e)=>(ft(r, e) & ot) === ot, a2 = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function c2(r) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }, t = a2.reduce((n, s)=>(n[s] = "function", n), e);
    return Ld(r, t);
}
function u2(r, e, t) {
    if (t < Et) throw new Error("invalid exponent, negatives unsupported");
    if (t === Et) return r.ONE;
    if (t === ot) return e;
    let n = r.ONE, s = e;
    for(; t > Et;)t & ot && (n = r.mul(n, s)), s = r.sqr(s), t >>= ot;
    return n;
}
function l2(r, e) {
    const t = new Array(e.length), n = e.reduce((i, o, a)=>r.is0(o) ? i : (t[a] = i, r.mul(i, o)), r.ONE), s = r.inv(n);
    return e.reduceRight((i, o, a)=>r.is0(o) ? i : (t[a] = r.mul(i, t[a]), r.mul(i, o)), s), t;
}
function Gy(r, e) {
    const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: n
    };
}
function Hy(r, e, t = !1, n = {}) {
    if (r <= Et) throw new Error("invalid field: expected ORDER > 0, got " + r);
    const { nBitLength: s, nByteLength: i } = Gy(r, e);
    if (i > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let o;
    const a = Object.freeze({
        ORDER: r,
        isLE: t,
        BITS: s,
        BYTES: i,
        MASK: e2(s),
        ZERO: Et,
        ONE: ot,
        create: (u)=>ft(u, r),
        isValid: (u)=>{
            if (typeof u != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof u);
            return Et <= u && u < r;
        },
        is0: (u)=>u === Et,
        isOdd: (u)=>(u & ot) === ot,
        neg: (u)=>ft(-u, r),
        eql: (u, c)=>u === c,
        sqr: (u)=>ft(u * u, r),
        add: (u, c)=>ft(u + c, r),
        sub: (u, c)=>ft(u - c, r),
        mul: (u, c)=>ft(u * c, r),
        pow: (u, c)=>u2(a, u, c),
        div: (u, c)=>ft(u * kf(c, r), r),
        sqrN: (u)=>u * u,
        addN: (u, c)=>u + c,
        subN: (u, c)=>u - c,
        mulN: (u, c)=>u * c,
        inv: (u)=>kf(u, r),
        sqrt: n.sqrt || ((u)=>(o || (o = s2(r)), o(a, u))),
        invertBatch: (u)=>l2(a, u),
        cmov: (u, c, l)=>l ? c : u,
        toBytes: (u)=>t ? xl(u, i) : Yy(u, i),
        fromBytes: (u)=>{
            if (u.length !== i) throw new Error("Field.fromBytes: expected " + i + " bytes, got " + u.length);
            return t ? ma(u) : XI(u);
        }
    });
    return Object.freeze(a);
}
const zf = BigInt(0), qo = BigInt(1);
function Eu(r, e) {
    const t = e.negate();
    return r ? t : e;
}
function Wy(r, e) {
    if (!Number.isSafeInteger(r) || r <= 0 || r > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function Mu(r, e) {
    Wy(r, e);
    const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1);
    return {
        windows: t,
        windowSize: n
    };
}
function d2(r, e) {
    if (!Array.isArray(r)) throw new Error("array expected");
    r.forEach((t, n)=>{
        if (!(t instanceof e)) throw new Error("invalid point at index " + n);
    });
}
function h2(r, e) {
    if (!Array.isArray(r)) throw new Error("array of scalars expected");
    r.forEach((t, n)=>{
        if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
    });
}
const Nu = /* @__PURE__ */ new WeakMap(), Ky = /* @__PURE__ */ new WeakMap();
function xu(r) {
    return Ky.get(r) || 1;
}
function f2(r, e) {
    return {
        constTimeNegate: Eu,
        hasPrecomputes (t) {
            return xu(t) !== 1;
        },
        unsafeLadder (t, n, s = r.ZERO) {
            let i = t;
            for(; n > zf;)n & qo && (s = s.add(i)), i = i.double(), n >>= qo;
            return s;
        },
        precomputeWindow (t, n) {
            const { windows: s, windowSize: i } = Mu(n, e), o = [];
            let a = t, u = a;
            for(let c = 0; c < s; c++){
                u = a, o.push(u);
                for(let l = 1; l < i; l++)u = u.add(a), o.push(u);
                a = u.double();
            }
            return o;
        },
        wNAF (t, n, s) {
            const { windows: i, windowSize: o } = Mu(t, e);
            let a = r.ZERO, u = r.BASE;
            const c = BigInt(2 ** t - 1), l = 2 ** t, d = BigInt(t);
            for(let h = 0; h < i; h++){
                const f = h * o;
                let g = Number(s & c);
                s >>= d, g > o && (g -= l, s += qo);
                const p = f, m = f + Math.abs(g) - 1, x = h % 2 !== 0, _ = g < 0;
                g === 0 ? u = u.add(Eu(x, n[p])) : a = a.add(Eu(_, n[m]));
            }
            return {
                p: a,
                f: u
            };
        },
        wNAFUnsafe (t, n, s, i = r.ZERO) {
            const { windows: o, windowSize: a } = Mu(t, e), u = BigInt(2 ** t - 1), c = 2 ** t, l = BigInt(t);
            for(let d = 0; d < o; d++){
                const h = d * a;
                if (s === zf) break;
                let f = Number(s & u);
                if (s >>= l, f > a && (f -= c, s += qo), f === 0) continue;
                let g = n[h + Math.abs(f) - 1];
                f < 0 && (g = g.negate()), i = i.add(g);
            }
            return i;
        },
        getPrecomputes (t, n, s) {
            let i = Nu.get(n);
            return i || (i = this.precomputeWindow(n, t), t !== 1 && Nu.set(n, s(i))), i;
        },
        wNAFCached (t, n, s) {
            const i = xu(t);
            return this.wNAF(i, this.getPrecomputes(i, t, s), n);
        },
        wNAFCachedUnsafe (t, n, s, i) {
            const o = xu(t);
            return o === 1 ? this.unsafeLadder(t, n, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, s), n, i);
        },
        setWindowSize (t, n) {
            Wy(n, e), Ky.set(t, n), Nu.delete(t);
        }
    };
}
function p2(r, e, t, n) {
    if (d2(t, r), h2(n, e), t.length !== n.length) throw new Error("arrays of points and scalars must have equal length");
    const s = r.ZERO, i = JI(BigInt(t.length)), o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1, a = (1 << o) - 1, u = new Array(a + 1).fill(s), c = Math.floor((e.BITS - 1) / o) * o;
    let l = s;
    for(let d = c; d >= 0; d -= o){
        u.fill(s);
        for(let f = 0; f < n.length; f++){
            const g = n[f], p = Number(g >> BigInt(d) & BigInt(a));
            u[p] = u[p].add(t[f]);
        }
        let h = s;
        for(let f = u.length - 1, g = s; f > 0; f--)g = g.add(u[f]), h = h.add(g);
        if (l = l.add(h), d !== 0) for(let f = 0; f < o; f++)l = l.double();
    }
    return l;
}
function g2(r) {
    return c2(r.Fp), Ld(r, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...Gy(r.n, r.nBitLength),
        ...r,
        p: r.Fp.ORDER
    });
}
const Nr = BigInt(0), Vt = BigInt(1), Qo = BigInt(2), y2 = BigInt(8), w2 = {
    zip215: !0
};
function m2(r) {
    const e = g2(r);
    return Ld(r, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }), Object.freeze({
        ...e
    });
}
function b2(r) {
    const e = m2(r), { Fp: t, n, prehash: s, hash: i, randomBytes: o, nByteLength: a, h: u } = e, c = Qo << BigInt(a * 8) - Vt, l = t.create, d = Hy(e.n, e.nBitLength), h = e.uvRatio || ((T, I)=>{
        try {
            return {
                isValid: !0,
                value: t.sqrt(T * t.inv(I))
            };
        } catch  {
            return {
                isValid: !1,
                value: Nr
            };
        }
    }), f = e.adjustScalarBytes || ((T)=>T), g = e.domain || ((T, I, y)=>{
        if (bu("phflag", y), I.length || y) throw new Error("Contexts/pre-hash are not supported");
        return T;
    });
    function p(T, I) {
        js("coordinate " + T, I, Nr, c);
    }
    function m(T) {
        if (!(T instanceof v)) throw new Error("ExtendedPoint expected");
    }
    const x = jf((T, I)=>{
        const { ex: y, ey: w, ez: M } = T, D = T.is0();
        I == null && (I = D ? y2 : t.inv(M));
        const A = l(y * I), L = l(w * I), V = l(M * I);
        if (D) return {
            x: Nr,
            y: Vt
        };
        if (V !== Vt) throw new Error("invZ was invalid");
        return {
            x: A,
            y: L
        };
    }), _ = jf((T)=>{
        const { a: I, d: y } = e;
        if (T.is0()) throw new Error("bad point: ZERO");
        const { ex: w, ey: M, ez: D, et: A } = T, L = l(w * w), V = l(M * M), Y = l(D * D), K = l(Y * Y), J = l(L * I), ne = l(Y * l(J + V)), ie = l(K + l(y * l(L * V)));
        if (ne !== ie) throw new Error("bad point: equation left != right (1)");
        const oe = l(w * M), le = l(D * A);
        if (oe !== le) throw new Error("bad point: equation left != right (2)");
        return !0;
    });
    class v {
        constructor(I, y, w, M){
            this.ex = I, this.ey = y, this.ez = w, this.et = M, p("x", I), p("y", y), p("z", w), p("t", M), Object.freeze(this);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static fromAffine(I) {
            if (I instanceof v) throw new Error("extended point not allowed");
            const { x: y, y: w } = I || {};
            return p("x", y), p("y", w), new v(y, w, Vt, l(y * w));
        }
        static normalizeZ(I) {
            const y = t.invertBatch(I.map((w)=>w.ez));
            return I.map((w, M)=>w.toAffine(y[M])).map(v.fromAffine);
        }
        static msm(I, y) {
            return p2(v, d, I, y);
        }
        _setWindowSize(I) {
            z.setWindowSize(this, I);
        }
        assertValidity() {
            _(this);
        }
        equals(I) {
            m(I);
            const { ex: y, ey: w, ez: M } = this, { ex: D, ey: A, ez: L } = I, V = l(y * L), Y = l(D * M), K = l(w * L), J = l(A * M);
            return V === Y && K === J;
        }
        is0() {
            return this.equals(v.ZERO);
        }
        negate() {
            return new v(l(-this.ex), this.ey, this.ez, l(-this.et));
        }
        double() {
            const { a: I } = e, { ex: y, ey: w, ez: M } = this, D = l(y * y), A = l(w * w), L = l(Qo * l(M * M)), V = l(I * D), Y = y + w, K = l(l(Y * Y) - D - A), J = V + A, ne = J - L, ie = V - A, oe = l(K * ne), le = l(J * ie), fe = l(K * ie), Q = l(ne * J);
            return new v(oe, le, Q, fe);
        }
        add(I) {
            m(I);
            const { a: y, d: w } = e, { ex: M, ey: D, ez: A, et: L } = this, { ex: V, ey: Y, ez: K, et: J } = I;
            if (y === BigInt(-1)) {
                const ve = l((D - M) * (Y + V)), _e = l((D + M) * (Y - V)), Ie = l(_e - ve);
                if (Ie === Nr) return this.double();
                const xe = l(A * Qo * J), He = l(L * Qo * K), Qe = He + xe, De = _e + ve, Ae = He - xe, j = l(Qe * Ie), b = l(De * Ae), E = l(Qe * Ae), k = l(Ie * De);
                return new v(j, b, k, E);
            }
            const ne = l(M * V), ie = l(D * Y), oe = l(L * w * J), le = l(A * K), fe = l((M + D) * (V + Y) - ne - ie), Q = le - oe, Z = le + oe, W = l(ie - y * ne), ee = l(fe * Q), se = l(Z * W), pe = l(fe * W), be = l(Q * Z);
            return new v(ee, se, be, pe);
        }
        subtract(I) {
            return this.add(I.negate());
        }
        wNAF(I) {
            return z.wNAFCached(this, I, v.normalizeZ);
        }
        multiply(I) {
            const y = I;
            js("scalar", y, Vt, n);
            const { p: w, f: M } = this.wNAF(y);
            return v.normalizeZ([
                w,
                M
            ])[0];
        }
        multiplyUnsafe(I, y = v.ZERO) {
            const w = I;
            return js("scalar", w, Nr, n), w === Nr ? O : this.is0() || w === Vt ? this : z.wNAFCachedUnsafe(this, w, v.normalizeZ, y);
        }
        isSmallOrder() {
            return this.multiplyUnsafe(u).is0();
        }
        isTorsionFree() {
            return z.unsafeLadder(this, n).is0();
        }
        toAffine(I) {
            return x(this, I);
        }
        clearCofactor() {
            const { h: I } = e;
            return I === Vt ? this : this.multiplyUnsafe(I);
        }
        static fromHex(I, y = !1) {
            const { d: w, a: M } = e, D = t.BYTES;
            I = Xr("pointHex", I, D), bu("zip215", y);
            const A = I.slice(), L = I[D - 1];
            A[D - 1] = L & -129;
            const V = ma(A), Y = y ? c : t.ORDER;
            js("pointHex.y", V, Nr, Y);
            const K = l(V * V), J = l(K - Vt), ne = l(w * K - M);
            let { isValid: ie, value: oe } = h(J, ne);
            if (!ie) throw new Error("Point.fromHex: invalid y coordinate");
            const le = (oe & Vt) === Vt, fe = (L & 128) !== 0;
            if (!y && oe === Nr && fe) throw new Error("Point.fromHex: x=0 and x_0=1");
            return fe !== le && (oe = l(-oe)), v.fromAffine({
                x: oe,
                y: V
            });
        }
        static fromPrivateKey(I) {
            return R(I).point;
        }
        toRawBytes() {
            const { x: I, y } = this.toAffine(), w = xl(y, t.BYTES);
            return w[w.length - 1] |= I & Vt ? 128 : 0, w;
        }
        toHex() {
            return Cd(this.toRawBytes());
        }
    }
    v.BASE = new v(e.Gx, e.Gy, Vt, l(e.Gx * e.Gy)), v.ZERO = new v(Nr, Vt, Vt, Nr);
    const { BASE: N, ZERO: O } = v, z = f2(v, a * 8);
    function P(T) {
        return ft(T, n);
    }
    function U(T) {
        return P(ma(T));
    }
    function R(T) {
        const I = t.BYTES;
        T = Xr("private key", T, I);
        const y = Xr("hashed private key", i(T), 2 * I), w = f(y.slice(0, I)), M = y.slice(I, 2 * I), D = U(w), A = N.multiply(D), L = A.toRawBytes();
        return {
            head: w,
            prefix: M,
            scalar: D,
            point: A,
            pointBytes: L
        };
    }
    function G(T) {
        return R(T).pointBytes;
    }
    function F(T = new Uint8Array(), ...I) {
        const y = Of(...I);
        return U(i(g(y, Xr("context", T), !!s)));
    }
    function H(T, I, y = {}) {
        T = Xr("message", T), s && (T = s(T));
        const { prefix: w, scalar: M, pointBytes: D } = R(I), A = F(y.context, w, T), L = N.multiply(A).toRawBytes(), V = F(y.context, L, D, T), Y = P(A + V * M);
        js("signature.s", Y, Nr, n);
        const K = Of(L, xl(Y, t.BYTES));
        return Xr("result", K, t.BYTES * 2);
    }
    const B = w2;
    function C(T, I, y, w = B) {
        const { context: M, zip215: D } = w, A = t.BYTES;
        T = Xr("signature", T, 2 * A), I = Xr("message", I), y = Xr("publicKey", y, A), D !== void 0 && bu("zip215", D), s && (I = s(I));
        const L = ma(T.slice(A, 2 * A));
        let V, Y, K;
        try {
            V = v.fromHex(y, D), Y = v.fromHex(T.slice(0, A), D), K = N.multiplyUnsafe(L);
        } catch  {
            return !1;
        }
        if (!D && V.isSmallOrder()) return !1;
        const J = F(M, Y.toRawBytes(), V.toRawBytes(), I);
        return Y.add(V.multiplyUnsafe(J)).subtract(K).clearCofactor().equals(v.ZERO);
    }
    return N._setWindowSize(8), {
        CURVE: e,
        getPublicKey: G,
        sign: H,
        verify: C,
        ExtendedPoint: v,
        utils: {
            getExtendedPublicKey: R,
            randomPrivateKey: ()=>o(t.BYTES),
            precompute (T = 8, I = v.BASE) {
                return I._setWindowSize(T), I.multiply(BigInt(3)), I;
            }
        }
    };
}
BigInt(0), BigInt(1);
const kd = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), Pf = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const v2 = BigInt(1), Uf = BigInt(2);
BigInt(3);
const E2 = BigInt(5), M2 = BigInt(8);
function N2(r) {
    const e = BigInt(10), t = BigInt(20), n = BigInt(40), s = BigInt(80), i = kd, o = r * r % i * r % i, a = Cr(o, Uf, i) * o % i, u = Cr(a, v2, i) * r % i, c = Cr(u, E2, i) * u % i, l = Cr(c, e, i) * c % i, d = Cr(l, t, i) * l % i, h = Cr(d, n, i) * d % i, f = Cr(h, s, i) * h % i, g = Cr(f, s, i) * h % i, p = Cr(g, e, i) * c % i;
    return {
        pow_p_5_8: Cr(p, Uf, i) * r % i,
        b2: o
    };
}
function x2(r) {
    return r[0] &= 248, r[31] &= 127, r[31] |= 64, r;
}
function I2(r, e) {
    const t = kd, n = ft(e * e * e, t), s = ft(n * n * e, t), i = N2(r * s).pow_p_5_8;
    let o = ft(r * n * i, t);
    const a = ft(e * o * o, t), u = o, c = ft(o * Pf, t), l = a === r, d = a === ft(-r, t), h = a === ft(-r * Pf, t);
    return l && (o = u), (d || h) && (o = c), o2(o, t) && (o = ft(-o, t)), {
        isValid: l || d,
        value: o
    };
}
const T2 = Hy(kd, void 0, !0), D2 = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: T2,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: M2,
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: HI,
    randomBytes: By,
    adjustScalarBytes: x2,
    uvRatio: I2
}, Xy = b2(D2), _2 = "EdDSA", A2 = "JWT", Sa = ".", jc = "base64url", Zy = "utf8", Jy = "utf8", S2 = ":", O2 = "did", j2 = "key", Rf = "base58btc", C2 = "z", L2 = "K36", k2 = 32;
function zd(r) {
    return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function ew(r = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? zd(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function tw(r, e) {
    e || (e = r.reduce((s, i)=>s + i.length, 0));
    const t = ew(e);
    let n = 0;
    for (const s of r)t.set(s, n), n += s.length;
    return zd(t);
}
function z2(r, e) {
    if (r.length >= 255) throw new TypeError("Alphabet too long");
    for(var t = new Uint8Array(256), n = 0; n < t.length; n++)t[n] = 255;
    for(var s = 0; s < r.length; s++){
        var i = r.charAt(s), o = i.charCodeAt(0);
        if (t[o] !== 255) throw new TypeError(i + " is ambiguous");
        t[o] = s;
    }
    var a = r.length, u = r.charAt(0), c = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
    function d(g) {
        if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (g.length === 0) return "";
        for(var p = 0, m = 0, x = 0, _ = g.length; x !== _ && g[x] === 0;)x++, p++;
        for(var v = (_ - x) * l + 1 >>> 0, N = new Uint8Array(v); x !== _;){
            for(var O = g[x], z = 0, P = v - 1; (O !== 0 || z < m) && P !== -1; P--, z++)O += 256 * N[P] >>> 0, N[P] = O % a >>> 0, O = O / a >>> 0;
            if (O !== 0) throw new Error("Non-zero carry");
            m = z, x++;
        }
        for(var U = v - m; U !== v && N[U] === 0;)U++;
        for(var R = u.repeat(p); U < v; ++U)R += r.charAt(N[U]);
        return R;
    }
    function h(g) {
        if (typeof g != "string") throw new TypeError("Expected String");
        if (g.length === 0) return new Uint8Array();
        var p = 0;
        if (g[p] !== " ") {
            for(var m = 0, x = 0; g[p] === u;)m++, p++;
            for(var _ = (g.length - p) * c + 1 >>> 0, v = new Uint8Array(_); g[p];){
                var N = t[g.charCodeAt(p)];
                if (N === 255) return;
                for(var O = 0, z = _ - 1; (N !== 0 || O < x) && z !== -1; z--, O++)N += a * v[z] >>> 0, v[z] = N % 256 >>> 0, N = N / 256 >>> 0;
                if (N !== 0) throw new Error("Non-zero carry");
                x = O, p++;
            }
            if (g[p] !== " ") {
                for(var P = _ - x; P !== _ && v[P] === 0;)P++;
                for(var U = new Uint8Array(m + (_ - P)), R = m; P !== _;)U[R++] = v[P++];
                return U;
            }
        }
    }
    function f(g) {
        var p = h(g);
        if (p) return p;
        throw new Error(`Non-${e} character`);
    }
    return {
        encode: d,
        decodeUnsafe: h,
        decode: f
    };
}
var P2 = z2, U2 = P2;
const rw = (r)=>{
    if (r instanceof Uint8Array && r.constructor.name === "Uint8Array") return r;
    if (r instanceof ArrayBuffer) return new Uint8Array(r);
    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
    throw new Error("Unknown type, must be binary type");
}, R2 = (r)=>new TextEncoder().encode(r), $2 = (r)=>new TextDecoder().decode(r);
let B2 = class {
    constructor(e, t, n){
        this.name = e, this.prefix = t, this.baseEncode = n;
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type");
    }
}, F2 = class {
    constructor(e, t, n){
        if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
    }
    or(e) {
        return nw(this, e);
    }
}, q2 = class {
    constructor(e){
        this.decoders = e;
    }
    or(e) {
        return nw(this, e);
    }
    decode(e) {
        const t = e[0], n = this.decoders[t];
        if (n) return n.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
};
const nw = (r, e)=>new q2({
        ...r.decoders || {
            [r.prefix]: r
        },
        ...e.decoders || {
            [e.prefix]: e
        }
    });
let Q2 = class {
    constructor(e, t, n, s){
        this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new B2(e, t, n), this.decoder = new F2(e, t, s);
    }
    encode(e) {
        return this.encoder.encode(e);
    }
    decode(e) {
        return this.decoder.decode(e);
    }
};
const Cc = ({ name: r, prefix: e, encode: t, decode: n })=>new Q2(r, e, t, n), wo = ({ prefix: r, name: e, alphabet: t })=>{
    const { encode: n, decode: s } = U2(t, e);
    return Cc({
        prefix: r,
        name: e,
        encode: n,
        decode: (i)=>rw(s(i))
    });
}, V2 = (r, e, t, n)=>{
    const s = {};
    for(let l = 0; l < e.length; ++l)s[e[l]] = l;
    let i = r.length;
    for(; r[i - 1] === "=";)--i;
    const o = new Uint8Array(i * t / 8 | 0);
    let a = 0, u = 0, c = 0;
    for(let l = 0; l < i; ++l){
        const d = s[r[l]];
        if (d === void 0) throw new SyntaxError(`Non-${n} character`);
        u = u << t | d, a += t, a >= 8 && (a -= 8, o[c++] = 255 & u >> a);
    }
    if (a >= t || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
    return o;
}, Y2 = (r, e, t)=>{
    const n = e[e.length - 1] === "=", s = (1 << t) - 1;
    let i = "", o = 0, a = 0;
    for(let u = 0; u < r.length; ++u)for(a = a << 8 | r[u], o += 8; o > t;)o -= t, i += e[s & a >> o];
    if (o && (i += e[s & a << t - o]), n) for(; i.length * t & 7;)i += "=";
    return i;
}, Dt = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n })=>Cc({
        prefix: e,
        name: r,
        encode (s) {
            return Y2(s, n, t);
        },
        decode (s) {
            return V2(s, n, t, r);
        }
    }), G2 = Cc({
    prefix: "\0",
    name: "identity",
    encode: (r)=>$2(r),
    decode: (r)=>R2(r)
});
var H2 = Object.freeze({
    __proto__: null,
    identity: G2
});
const W2 = Dt({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var K2 = Object.freeze({
    __proto__: null,
    base2: W2
});
const X2 = Dt({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var Z2 = Object.freeze({
    __proto__: null,
    base8: X2
});
const J2 = wo({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var eT = Object.freeze({
    __proto__: null,
    base10: J2
});
const tT = Dt({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
}), rT = Dt({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
});
var nT = Object.freeze({
    __proto__: null,
    base16: tT,
    base16upper: rT
});
const iT = Dt({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
}), sT = Dt({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
}), oT = Dt({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
}), aT = Dt({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
}), cT = Dt({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
}), uT = Dt({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
}), lT = Dt({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
}), dT = Dt({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
}), hT = Dt({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});
var fT = Object.freeze({
    __proto__: null,
    base32: iT,
    base32upper: sT,
    base32pad: oT,
    base32padupper: aT,
    base32hex: cT,
    base32hexupper: uT,
    base32hexpad: lT,
    base32hexpadupper: dT,
    base32z: hT
});
const pT = wo({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), gT = wo({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var yT = Object.freeze({
    __proto__: null,
    base36: pT,
    base36upper: gT
});
const wT = wo({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), mT = wo({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var bT = Object.freeze({
    __proto__: null,
    base58btc: wT,
    base58flickr: mT
});
const vT = Dt({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
}), ET = Dt({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
}), MT = Dt({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
}), NT = Dt({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});
var xT = Object.freeze({
    __proto__: null,
    base64: vT,
    base64pad: ET,
    base64url: MT,
    base64urlpad: NT
});
const iw = Array.from(""), IT = iw.reduce((r, e, t)=>(r[t] = e, r), []), TT = iw.reduce((r, e, t)=>(r[e.codePointAt(0)] = t, r), []);
function DT(r) {
    return r.reduce((e, t)=>(e += IT[t], e), "");
}
function _T(r) {
    const e = [];
    for (const t of r){
        const n = TT[t.codePointAt(0)];
        if (n === void 0) throw new Error(`Non-base256emoji character: ${t}`);
        e.push(n);
    }
    return new Uint8Array(e);
}
const AT = Cc({
    prefix: "",
    name: "base256emoji",
    encode: DT,
    decode: _T
});
var ST = Object.freeze({
    __proto__: null,
    base256emoji: AT
}), OT = sw, $f = 128, jT = -128, CT = Math.pow(2, 31);
function sw(r, e, t) {
    e = e || [], t = t || 0;
    for(var n = t; r >= CT;)e[t++] = r & 255 | $f, r /= 128;
    for(; r & jT;)e[t++] = r & 255 | $f, r >>>= 7;
    return e[t] = r | 0, sw.bytes = t - n + 1, e;
}
var LT = Tl, kT = 128, Bf = 127;
function Tl(r, n) {
    var t = 0, n = n || 0, s = 0, i = n, o, a = r.length;
    do {
        if (i >= a) throw Tl.bytes = 0, new RangeError("Could not decode varint");
        o = r[i++], t += s < 28 ? (o & Bf) << s : (o & Bf) * Math.pow(2, s), s += 7;
    }while (o >= kT)
    return Tl.bytes = i - n, t;
}
var zT = Math.pow(2, 7), PT = Math.pow(2, 14), UT = Math.pow(2, 21), RT = Math.pow(2, 28), $T = Math.pow(2, 35), BT = Math.pow(2, 42), FT = Math.pow(2, 49), qT = Math.pow(2, 56), QT = Math.pow(2, 63), VT = function(r) {
    return r < zT ? 1 : r < PT ? 2 : r < UT ? 3 : r < RT ? 4 : r < $T ? 5 : r < BT ? 6 : r < FT ? 7 : r < qT ? 8 : r < QT ? 9 : 10;
}, YT = {
    encode: OT,
    decode: LT,
    encodingLength: VT
}, ow = YT;
const Ff = (r, e, t = 0)=>(ow.encode(r, e, t), e), qf = (r)=>ow.encodingLength(r), Dl = (r, e)=>{
    const t = e.byteLength, n = qf(r), s = n + qf(t), i = new Uint8Array(s + t);
    return Ff(r, i, 0), Ff(t, i, n), i.set(e, s), new GT(r, t, e, i);
};
let GT = class {
    constructor(e, t, n, s){
        this.code = e, this.size = t, this.digest = n, this.bytes = s;
    }
};
const aw = ({ name: r, code: e, encode: t })=>new HT(r, e, t);
let HT = class {
    constructor(e, t, n){
        this.name = e, this.code = t, this.encode = n;
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const t = this.encode(e);
            return t instanceof Uint8Array ? Dl(this.code, t) : t.then((n)=>Dl(this.code, n));
        } else throw Error("Unknown type, must be binary type");
    }
};
const cw = (r)=>async (e)=>new Uint8Array(await crypto.subtle.digest(r, e)), WT = aw({
    name: "sha2-256",
    code: 18,
    encode: cw("SHA-256")
}), KT = aw({
    name: "sha2-512",
    code: 19,
    encode: cw("SHA-512")
});
var XT = Object.freeze({
    __proto__: null,
    sha256: WT,
    sha512: KT
});
const uw = 0, ZT = "identity", lw = rw, JT = (r)=>Dl(uw, lw(r)), eD = {
    code: uw,
    name: ZT,
    encode: lw,
    digest: JT
};
var tD = Object.freeze({
    __proto__: null,
    identity: eD
});
new TextEncoder(), new TextDecoder();
const Qf = {
    ...H2,
    ...K2,
    ...Z2,
    ...eT,
    ...nT,
    ...fT,
    ...yT,
    ...bT,
    ...xT,
    ...ST
};
({
    ...XT,
    ...tD
});
function dw(r, e, t, n) {
    return {
        name: r,
        prefix: e,
        encoder: {
            name: r,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: n
        }
    };
}
const Vf = dw("utf8", "u", (r)=>"u" + new TextDecoder("utf8").decode(r), (r)=>new TextEncoder().encode(r.substring(1))), Iu = dw("ascii", "a", (r)=>{
    let e = "a";
    for(let t = 0; t < r.length; t++)e += String.fromCharCode(r[t]);
    return e;
}, (r)=>{
    r = r.substring(1);
    const e = ew(r.length);
    for(let t = 0; t < r.length; t++)e[t] = r.charCodeAt(t);
    return e;
}), hw = {
    utf8: Vf,
    "utf-8": Vf,
    hex: Qf.base16,
    latin1: Iu,
    ascii: Iu,
    binary: Iu,
    ...Qf
};
function Lc(r, e = "utf8") {
    const t = hw[e];
    if (!t) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1);
}
function ps(r, e = "utf8") {
    const t = hw[e];
    if (!t) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? zd(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
function Yf(r) {
    return ss(Lc(ps(r, jc), Zy));
}
function Oa(r) {
    return Lc(ps(Mi(r), Zy), jc);
}
function fw(r) {
    const e = ps(L2, Rf), t = C2 + Lc(tw([
        e,
        r
    ]), Rf);
    return [
        O2,
        j2,
        t
    ].join(S2);
}
function rD(r) {
    return Lc(r, jc);
}
function nD(r) {
    return ps(r, jc);
}
function iD(r) {
    return ps([
        Oa(r.header),
        Oa(r.payload)
    ].join(Sa), Jy);
}
function sD(r) {
    return [
        Oa(r.header),
        Oa(r.payload),
        rD(r.signature)
    ].join(Sa);
}
function _l(r) {
    const e = r.split(Sa), t = Yf(e[0]), n = Yf(e[1]), s = nD(e[2]), i = ps(e.slice(0, 2).join(Sa), Jy);
    return {
        header: t,
        payload: n,
        signature: s,
        data: i
    };
}
function Gf(r = By(k2)) {
    const e = Xy.getPublicKey(r);
    return {
        secretKey: tw([
            r,
            e
        ]),
        publicKey: e
    };
}
async function oD(r, e, t, n, s = ue.fromMiliseconds(Date.now())) {
    const i = {
        alg: _2,
        typ: A2
    }, o = fw(n.publicKey), a = s + t, u = {
        iss: o,
        sub: r,
        aud: e,
        iat: s,
        exp: a
    }, c = iD({
        header: i,
        payload: u
    }), l = Xy.sign(c, n.secretKey.slice(0, 32));
    return sD({
        header: i,
        payload: u,
        signature: l
    });
}
var Hf = function(r, e, t) {
    if (t || arguments.length === 2) for(var n = 0, s = e.length, i; n < s; n++)(i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
    return r.concat(i || Array.prototype.slice.call(e));
}, aD = /** @class */ /* @__PURE__ */ function() {
    function r(e, t, n) {
        this.name = e, this.version = t, this.os = n, this.type = "browser";
    }
    return r;
}(), cD = /** @class */ /* @__PURE__ */ function() {
    function r(e) {
        this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return r;
}(), uD = /** @class */ /* @__PURE__ */ function() {
    function r(e, t, n, s) {
        this.name = e, this.version = t, this.os = n, this.bot = s, this.type = "bot-device";
    }
    return r;
}(), lD = /** @class */ /* @__PURE__ */ function() {
    function r() {
        this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return r;
}(), dD = /** @class */ /* @__PURE__ */ function() {
    function r() {
        this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return r;
}(), hD = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, fD = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, Wf = 3, pD = [
    [
        "aol",
        /AOLShield\/([0-9\._]+)/
    ],
    [
        "edge",
        /Edge\/([0-9\._]+)/
    ],
    [
        "edge-ios",
        /EdgiOS\/([0-9\._]+)/
    ],
    [
        "yandexbrowser",
        /YaBrowser\/([0-9\._]+)/
    ],
    [
        "kakaotalk",
        /KAKAOTALK\s([0-9\.]+)/
    ],
    [
        "samsung",
        /SamsungBrowser\/([0-9\.]+)/
    ],
    [
        "silk",
        /\bSilk\/([0-9._-]+)\b/
    ],
    [
        "miui",
        /MiuiBrowser\/([0-9\.]+)$/
    ],
    [
        "beaker",
        /BeakerBrowser\/([0-9\.]+)/
    ],
    [
        "edge-chromium",
        /EdgA?\/([0-9\.]+)/
    ],
    [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "chrome",
        /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "phantomjs",
        /PhantomJS\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "crios",
        /CriOS\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "firefox",
        /Firefox\/([0-9\.]+)(?:\s|$)/
    ],
    [
        "fxios",
        /FxiOS\/([0-9\.]+)/
    ],
    [
        "opera-mini",
        /Opera Mini.*Version\/([0-9\.]+)/
    ],
    [
        "opera",
        /Opera\/([0-9\.]+)(?:\s|$)/
    ],
    [
        "opera",
        /OPR\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "pie",
        /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/
    ],
    [
        "pie",
        /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/
    ],
    [
        "netfront",
        /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/
    ],
    [
        "ie",
        /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/
    ],
    [
        "ie",
        /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/
    ],
    [
        "ie",
        /MSIE\s(7\.0)/
    ],
    [
        "bb10",
        /BB10;\sTouch.*Version\/([0-9\.]+)/
    ],
    [
        "android",
        /Android\s([0-9\.]+)/
    ],
    [
        "ios",
        /Version\/([0-9\._]+).*Mobile.*Safari.*/
    ],
    [
        "safari",
        /Version\/([0-9\._]+).*Safari/
    ],
    [
        "facebook",
        /FB[AS]V\/([0-9\.]+)/
    ],
    [
        "instagram",
        /Instagram\s([0-9\.]+)/
    ],
    [
        "ios-webview",
        /AppleWebKit\/([0-9\.]+).*Mobile/
    ],
    [
        "ios-webview",
        /AppleWebKit\/([0-9\.]+).*Gecko\)$/
    ],
    [
        "curl",
        /^curl\/([0-9\.]+)$/
    ],
    [
        "searchbot",
        hD
    ]
], Kf = [
    [
        "iOS",
        /iP(hone|od|ad)/
    ],
    [
        "Android OS",
        /Android/
    ],
    [
        "BlackBerry OS",
        /BlackBerry|BB10/
    ],
    [
        "Windows Mobile",
        /IEMobile/
    ],
    [
        "Amazon OS",
        /Kindle/
    ],
    [
        "Windows 3.11",
        /Win16/
    ],
    [
        "Windows 95",
        /(Windows 95)|(Win95)|(Windows_95)/
    ],
    [
        "Windows 98",
        /(Windows 98)|(Win98)/
    ],
    [
        "Windows 2000",
        /(Windows NT 5.0)|(Windows 2000)/
    ],
    [
        "Windows XP",
        /(Windows NT 5.1)|(Windows XP)/
    ],
    [
        "Windows Server 2003",
        /(Windows NT 5.2)/
    ],
    [
        "Windows Vista",
        /(Windows NT 6.0)/
    ],
    [
        "Windows 7",
        /(Windows NT 6.1)/
    ],
    [
        "Windows 8",
        /(Windows NT 6.2)/
    ],
    [
        "Windows 8.1",
        /(Windows NT 6.3)/
    ],
    [
        "Windows 10",
        /(Windows NT 10.0)/
    ],
    [
        "Windows ME",
        /Windows ME/
    ],
    [
        "Windows CE",
        /Windows CE|WinCE|Microsoft Pocket Internet Explorer/
    ],
    [
        "Open BSD",
        /OpenBSD/
    ],
    [
        "Sun OS",
        /SunOS/
    ],
    [
        "Chrome OS",
        /CrOS/
    ],
    [
        "Linux",
        /(Linux)|(X11)/
    ],
    [
        "Mac OS",
        /(Mac_PowerPC)|(Macintosh)/
    ],
    [
        "QNX",
        /QNX/
    ],
    [
        "BeOS",
        /BeOS/
    ],
    [
        "OS/2",
        /OS\/2/
    ]
];
function gD(r) {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new dD() : typeof navigator < "u" ? wD(navigator.userAgent) : bD();
}
function yD(r) {
    return r !== "" && pD.reduce(function(e, t) {
        var n = t[0], s = t[1];
        if (e) return e;
        var i = s.exec(r);
        return !!i && [
            n,
            i
        ];
    }, !1);
}
function wD(r) {
    var e = yD(r);
    if (!e) return null;
    var t = e[0], n = e[1];
    if (t === "searchbot") return new lD();
    var s = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
    s ? s.length < Wf && (s = Hf(Hf([], s, !0), vD(Wf - s.length), !0)) : s = [];
    var i = s.join("."), o = mD(r), a = fD.exec(r);
    return a && a[1] ? new uD(t, i, o, a[1]) : new aD(t, i, o);
}
function mD(r) {
    for(var e = 0, t = Kf.length; e < t; e++){
        var n = Kf[e], s = n[0], i = n[1], o = i.exec(r);
        if (o) return s;
    }
    return null;
}
function bD() {
    var r = typeof process < "u" && process.version;
    return r ? new cD(process.version.slice(1)) : null;
}
function vD(r) {
    for(var e = [], t = 0; t < r; t++)e.push("0");
    return e;
}
var Ye = {};
Object.defineProperty(Ye, "__esModule", {
    value: !0
});
Ye.getLocalStorage = Ye.getLocalStorageOrThrow = Ye.getCrypto = Ye.getCryptoOrThrow = pw = Ye.getLocation = Ye.getLocationOrThrow = Pd = Ye.getNavigator = Ye.getNavigatorOrThrow = Ni = Ye.getDocument = Ye.getDocumentOrThrow = Ye.getFromWindowOrThrow = Ye.getFromWindow = void 0;
function Ci(r) {
    let e;
    return ("TURBOPACK compile-time value", "undefined") < "u" && typeof window[r] < "u" && (e = window[r]), e;
}
Ye.getFromWindow = Ci;
function gs(r) {
    const e = Ci(r);
    if (!e) throw new Error(`${r} is not defined in Window`);
    return e;
}
Ye.getFromWindowOrThrow = gs;
function ED() {
    return gs("document");
}
Ye.getDocumentOrThrow = ED;
function MD() {
    return Ci("document");
}
var Ni = Ye.getDocument = MD;
function ND() {
    return gs("navigator");
}
Ye.getNavigatorOrThrow = ND;
function xD() {
    return Ci("navigator");
}
var Pd = Ye.getNavigator = xD;
function ID() {
    return gs("location");
}
Ye.getLocationOrThrow = ID;
function TD() {
    return Ci("location");
}
var pw = Ye.getLocation = TD;
function DD() {
    return gs("crypto");
}
Ye.getCryptoOrThrow = DD;
function _D() {
    return Ci("crypto");
}
Ye.getCrypto = _D;
function AD() {
    return gs("localStorage");
}
Ye.getLocalStorageOrThrow = AD;
function SD() {
    return Ci("localStorage");
}
Ye.getLocalStorage = SD;
var Ud = {};
Object.defineProperty(Ud, "__esModule", {
    value: !0
});
var gw = Ud.getWindowMetadata = void 0;
const Xf = Ye;
function OD() {
    let r, e;
    try {
        r = Xf.getDocumentOrThrow(), e = Xf.getLocationOrThrow();
    } catch  {
        return null;
    }
    function t() {
        const d = r.getElementsByTagName("link"), h = [];
        for(let f = 0; f < d.length; f++){
            const g = d[f], p = g.getAttribute("rel");
            if (p && p.toLowerCase().indexOf("icon") > -1) {
                const m = g.getAttribute("href");
                if (m) if (m.toLowerCase().indexOf("https:") === -1 && m.toLowerCase().indexOf("http:") === -1 && m.indexOf("//") !== 0) {
                    let x = e.protocol + "//" + e.host;
                    if (m.indexOf("/") === 0) x += m;
                    else {
                        const _ = e.pathname.split("/");
                        _.pop();
                        const v = _.join("/");
                        x += v + "/" + m;
                    }
                    h.push(x);
                } else if (m.indexOf("//") === 0) {
                    const x = e.protocol + m;
                    h.push(x);
                } else h.push(m);
            }
        }
        return h;
    }
    function n(...d) {
        const h = r.getElementsByTagName("meta");
        for(let f = 0; f < h.length; f++){
            const g = h[f], p = [
                "itemprop",
                "property",
                "name"
            ].map((m)=>g.getAttribute(m)).filter((m)=>m ? d.includes(m) : !1);
            if (p.length && p) {
                const m = g.getAttribute("content");
                if (m) return m;
            }
        }
        return "";
    }
    function s() {
        let d = n("name", "og:site_name", "og:title", "twitter:title");
        return d || (d = r.title), d;
    }
    function i() {
        return n("description", "og:description", "twitter:description", "keywords");
    }
    const o = s(), a = i(), u = e.origin, c = t();
    return {
        description: a,
        url: u,
        icons: c,
        name: o
    };
}
gw = Ud.getWindowMetadata = OD;
const jD = "0.1.1";
function CD() {
    return jD;
}
class We extends Error {
    constructor(e, t = {}){
        const n = (()=>{
            var u;
            if (t.cause instanceof We) {
                if (t.cause.details) return t.cause.details;
                if (t.cause.shortMessage) return t.cause.shortMessage;
            }
            return t.cause && "details" in t.cause && typeof t.cause.details == "string" ? t.cause.details : (u = t.cause) != null && u.message ? t.cause.message : t.details;
        })(), s = t.cause instanceof We && t.cause.docsPath || t.docsPath, o = `https://oxlib.sh${s ?? ""}`, a = [
            e || "An error occurred.",
            ...t.metaMessages ? [
                "",
                ...t.metaMessages
            ] : [],
            ...n || s ? [
                "",
                n ? `Details: ${n}` : void 0,
                s ? `See: ${o}` : void 0
            ] : []
        ].filter((u)=>typeof u == "string").join(`
`);
        super(a, t.cause ? {
            cause: t.cause
        } : void 0), Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "docs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError"
        }), Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: `ox@${CD()}`
        }), this.cause = t.cause, this.details = n, this.docs = o, this.docsPath = s, this.shortMessage = e;
    }
    walk(e) {
        return yw(this, e);
    }
}
function yw(r, e) {
    return e != null && e(r) ? r : r && typeof r == "object" && "cause" in r && r.cause ? yw(r.cause, e) : e ? null : r;
}
const Bi = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function LD(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function ao(r) {
    if (!Number.isSafeInteger(r) || r < 0) throw new Error("positive integer expected, got " + r);
}
function xi(r, ...e) {
    if (!LD(r)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function kD(r) {
    if (typeof r != "function" || typeof r.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
    ao(r.outputLen), ao(r.blockLen);
}
function os(r, e = !0) {
    if (r.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function ww(r, e) {
    xi(r);
    const t = e.outputLen;
    if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
function zD(r) {
    return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function as(...r) {
    for(let e = 0; e < r.length; e++)r[e].fill(0);
}
function Tu(r) {
    return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function Lr(r, e) {
    return r << 32 - e | r >>> e;
}
const PD = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
function UD(r) {
    return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
function RD(r) {
    for(let e = 0; e < r.length; e++)r[e] = UD(r[e]);
    return r;
}
const Zf = PD ? (r)=>r : RD;
function $D(r) {
    if (typeof r != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(r));
}
function kc(r) {
    return typeof r == "string" && (r = $D(r)), xi(r), r;
}
function BD(...r) {
    let e = 0;
    for(let n = 0; n < r.length; n++){
        const s = r[n];
        xi(s), e += s.length;
    }
    const t = new Uint8Array(e);
    for(let n = 0, s = 0; n < r.length; n++){
        const i = r[n];
        t.set(i, s), s += i.length;
    }
    return t;
}
class Rd {
}
function mw(r) {
    const e = (n)=>r().update(kc(n)).digest(), t = r();
    return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = ()=>r(), e;
}
function FD(r = 32) {
    if (Bi && typeof Bi.getRandomValues == "function") return Bi.getRandomValues(new Uint8Array(r));
    if (Bi && typeof Bi.randomBytes == "function") return Uint8Array.from(Bi.randomBytes(r));
    throw new Error("crypto.getRandomValues must be defined");
}
function qD(r, e, t, n) {
    if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
    const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), u = n ? 4 : 0, c = n ? 0 : 4;
    r.setUint32(e + u, o, n), r.setUint32(e + c, a, n);
}
function QD(r, e, t) {
    return r & e ^ ~r & t;
}
function VD(r, e, t) {
    return r & e ^ r & t ^ e & t;
}
class YD extends Rd {
    constructor(e, t, n, s){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.buffer = new Uint8Array(e), this.view = Tu(this.buffer);
    }
    update(e) {
        os(this), e = kc(e), xi(e);
        const { view: t, buffer: n, blockLen: s } = this, i = e.length;
        for(let o = 0; o < i;){
            const a = Math.min(s - this.pos, i - o);
            if (a === s) {
                const u = Tu(e);
                for(; s <= i - o; o += s)this.process(u, o);
                continue;
            }
            n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        os(this), ww(e, this), this.finished = !0;
        const { buffer: t, view: n, blockLen: s, isLE: i } = this;
        let { pos: o } = this;
        t[o++] = 128, as(this.buffer.subarray(o)), this.padOffset > s - o && (this.process(n, 0), o = 0);
        for(let d = o; d < s; d++)t[d] = 0;
        qD(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
        const a = Tu(e), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = u / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let d = 0; d < c; d++)a.setUint32(4 * d, l[d], i);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const n = e.slice(0, t);
        return this.destroy(), n;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
        return e.destroyed = o, e.finished = i, e.length = s, e.pos = a, s % t && e.buffer.set(n), e;
    }
    clone() {
        return this._cloneInto();
    }
}
const vn = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Vo = /* @__PURE__ */ BigInt(2 ** 32 - 1), Jf = /* @__PURE__ */ BigInt(32);
function GD(r, e = !1) {
    return e ? {
        h: Number(r & Vo),
        l: Number(r >> Jf & Vo)
    } : {
        h: Number(r >> Jf & Vo) | 0,
        l: Number(r & Vo) | 0
    };
}
function HD(r, e = !1) {
    const t = r.length;
    let n = new Uint32Array(t), s = new Uint32Array(t);
    for(let i = 0; i < t; i++){
        const { h: o, l: a } = GD(r[i], e);
        [n[i], s[i]] = [
            o,
            a
        ];
    }
    return [
        n,
        s
    ];
}
const WD = (r, e, t)=>r << t | e >>> 32 - t, KD = (r, e, t)=>e << t | r >>> 32 - t, XD = (r, e, t)=>e << t - 32 | r >>> 64 - t, ZD = (r, e, t)=>r << t - 32 | e >>> 64 - t, JD = BigInt(0), Cs = BigInt(1), e_ = BigInt(2), t_ = BigInt(7), r_ = BigInt(256), n_ = BigInt(113), bw = [], vw = [], Ew = [];
for(let r = 0, e = Cs, t = 1, n = 0; r < 24; r++){
    [t, n] = [
        n,
        (2 * t + 3 * n) % 5
    ], bw.push(2 * (5 * n + t)), vw.push((r + 1) * (r + 2) / 2 % 64);
    let s = JD;
    for(let i = 0; i < 7; i++)e = (e << Cs ^ (e >> t_) * n_) % r_, e & e_ && (s ^= Cs << (Cs << /* @__PURE__ */ BigInt(i)) - Cs);
    Ew.push(s);
}
const Mw = HD(Ew, !0), i_ = Mw[0], s_ = Mw[1], ep = (r, e, t)=>t > 32 ? XD(r, e, t) : WD(r, e, t), tp = (r, e, t)=>t > 32 ? ZD(r, e, t) : KD(r, e, t);
function o_(r, e = 24) {
    const t = new Uint32Array(10);
    for(let n = 24 - e; n < 24; n++){
        for(let o = 0; o < 10; o++)t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
        for(let o = 0; o < 10; o += 2){
            const a = (o + 8) % 10, u = (o + 2) % 10, c = t[u], l = t[u + 1], d = ep(c, l, 1) ^ t[a], h = tp(c, l, 1) ^ t[a + 1];
            for(let f = 0; f < 50; f += 10)r[o + f] ^= d, r[o + f + 1] ^= h;
        }
        let s = r[2], i = r[3];
        for(let o = 0; o < 24; o++){
            const a = vw[o], u = ep(s, i, a), c = tp(s, i, a), l = bw[o];
            s = r[l], i = r[l + 1], r[l] = u, r[l + 1] = c;
        }
        for(let o = 0; o < 50; o += 10){
            for(let a = 0; a < 10; a++)t[a] = r[o + a];
            for(let a = 0; a < 10; a++)r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
        }
        r[0] ^= i_[n], r[1] ^= s_[n];
    }
    as(t);
}
class $d extends Rd {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(e, t, n, s = !1, i = 24){
        if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = s, this.rounds = i, ao(n), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200), this.state32 = zD(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        Zf(this.state32), o_(this.state32, this.rounds), Zf(this.state32), this.posOut = 0, this.pos = 0;
    }
    update(e) {
        os(this), e = kc(e), xi(e);
        const { blockLen: t, state: n } = this, s = e.length;
        for(let i = 0; i < s;){
            const o = Math.min(t - this.pos, s - i);
            for(let a = 0; a < o; a++)n[this.pos++] ^= e[i++];
            this.pos === t && this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = !0;
        const { state: e, suffix: t, pos: n, blockLen: s } = this;
        e[n] ^= t, t & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
    }
    writeInto(e) {
        os(this, !1), xi(e), this.finish();
        const t = this.state, { blockLen: n } = this;
        for(let s = 0, i = e.length; s < i;){
            this.posOut >= n && this.keccak();
            const o = Math.min(n - this.posOut, i - s);
            e.set(t.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
        }
        return e;
    }
    xofInto(e) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(e);
    }
    xof(e) {
        return ao(e), this.xofInto(new Uint8Array(e));
    }
    digestInto(e) {
        if (ww(e, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = !0, as(this.state);
    }
    _cloneInto(e) {
        const { blockLen: t, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
        return e || (e = new $d(t, n, s, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
    }
}
const a_ = (r, e, t)=>mw(()=>new $d(e, r, t)), c_ = a_(1, 136, 256 / 8), u_ = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), En = /* @__PURE__ */ new Uint32Array(64);
class l_ extends YD {
    constructor(e = 32){
        super(64, e, 8, !1), this.A = vn[0] | 0, this.B = vn[1] | 0, this.C = vn[2] | 0, this.D = vn[3] | 0, this.E = vn[4] | 0, this.F = vn[5] | 0, this.G = vn[6] | 0, this.H = vn[7] | 0;
    }
    get() {
        const { A: e, B: t, C: n, D: s, E: i, F: o, G: a, H: u } = this;
        return [
            e,
            t,
            n,
            s,
            i,
            o,
            a,
            u
        ];
    }
    // prettier-ignore
    set(e, t, n, s, i, o, a, u) {
        this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = u | 0;
    }
    process(e, t) {
        for(let d = 0; d < 16; d++, t += 4)En[d] = e.getUint32(t, !1);
        for(let d = 16; d < 64; d++){
            const h = En[d - 15], f = En[d - 2], g = Lr(h, 7) ^ Lr(h, 18) ^ h >>> 3, p = Lr(f, 17) ^ Lr(f, 19) ^ f >>> 10;
            En[d] = p + En[d - 7] + g + En[d - 16] | 0;
        }
        let { A: n, B: s, C: i, D: o, E: a, F: u, G: c, H: l } = this;
        for(let d = 0; d < 64; d++){
            const h = Lr(a, 6) ^ Lr(a, 11) ^ Lr(a, 25), f = l + h + QD(a, u, c) + u_[d] + En[d] | 0, p = (Lr(n, 2) ^ Lr(n, 13) ^ Lr(n, 22)) + VD(n, s, i) | 0;
            l = c, c = u, u = a, a = o + f | 0, o = i, i = s, s = n, n = f + p | 0;
        }
        n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(n, s, i, o, a, u, c, l);
    }
    roundClean() {
        as(En);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), as(this.buffer);
    }
}
const d_ = /* @__PURE__ */ mw(()=>new l_());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Bd = /* @__PURE__ */ BigInt(0), Al = /* @__PURE__ */ BigInt(1);
function mo(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Fd(r) {
    if (!mo(r)) throw new Error("Uint8Array expected");
}
function co(r, e) {
    if (typeof e != "boolean") throw new Error(r + " boolean expected, got " + e);
}
function Yo(r) {
    const e = r.toString(16);
    return e.length & 1 ? "0" + e : e;
}
function Nw(r) {
    if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
    return r === "" ? Bd : BigInt("0x" + r);
}
const xw = // @ts-ignore
typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", h_ = /* @__PURE__ */ Array.from({
    length: 256
}, (r, e)=>e.toString(16).padStart(2, "0"));
function uo(r) {
    if (Fd(r), xw) return r.toHex();
    let e = "";
    for(let t = 0; t < r.length; t++)e += h_[r[t]];
    return e;
}
const Zr = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function rp(r) {
    if (r >= Zr._0 && r <= Zr._9) return r - Zr._0;
    if (r >= Zr.A && r <= Zr.F) return r - (Zr.A - 10);
    if (r >= Zr.a && r <= Zr.f) return r - (Zr.a - 10);
}
function ja(r) {
    if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
    if (xw) return Uint8Array.fromHex(r);
    const e = r.length, t = e / 2;
    if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(t);
    for(let s = 0, i = 0; s < t; s++, i += 2){
        const o = rp(r.charCodeAt(i)), a = rp(r.charCodeAt(i + 1));
        if (o === void 0 || a === void 0) {
            const u = r[i] + r[i + 1];
            throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + i);
        }
        n[s] = o * 16 + a;
    }
    return n;
}
function vi(r) {
    return Nw(uo(r));
}
function Iw(r) {
    return Fd(r), Nw(uo(Uint8Array.from(r).reverse()));
}
function bo(r, e) {
    return ja(r.toString(16).padStart(e * 2, "0"));
}
function Tw(r, e) {
    return bo(r, e).reverse();
}
function gr(r, e, t) {
    let n;
    if (typeof e == "string") try {
        n = ja(e);
    } catch (i) {
        throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
    }
    else if (mo(e)) n = Uint8Array.from(e);
    else throw new Error(r + " must be hex string or Uint8Array");
    const s = n.length;
    if (typeof t == "number" && s !== t) throw new Error(r + " of length " + t + " expected, got " + s);
    return n;
}
function Ca(...r) {
    let e = 0;
    for(let n = 0; n < r.length; n++){
        const s = r[n];
        Fd(s), e += s.length;
    }
    const t = new Uint8Array(e);
    for(let n = 0, s = 0; n < r.length; n++){
        const i = r[n];
        t.set(i, s), s += i.length;
    }
    return t;
}
const Du = (r)=>typeof r == "bigint" && Bd <= r;
function qd(r, e, t) {
    return Du(r) && Du(e) && Du(t) && e <= r && r < t;
}
function es(r, e, t, n) {
    if (!qd(e, t, n)) throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function f_(r) {
    let e;
    for(e = 0; r > Bd; r >>= Al, e += 1);
    return e;
}
const zc = (r)=>(Al << BigInt(r)) - Al, _u = (r)=>new Uint8Array(r), np = (r)=>Uint8Array.from(r);
function p_(r, e, t) {
    if (typeof r != "number" || r < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof t != "function") throw new Error("hmacFn must be a function");
    let n = _u(r), s = _u(r), i = 0;
    const o = ()=>{
        n.fill(1), s.fill(0), i = 0;
    }, a = (...d)=>t(s, n, ...d), u = (d = _u(0))=>{
        s = a(np([
            0
        ]), d), n = a(), d.length !== 0 && (s = a(np([
            1
        ]), d), n = a());
    }, c = ()=>{
        if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let d = 0;
        const h = [];
        for(; d < e;){
            n = a();
            const f = n.slice();
            h.push(f), d += n.length;
        }
        return Ca(...h);
    };
    return (d, h)=>{
        o(), u(d);
        let f;
        for(; !(f = h(c()));)u();
        return o(), f;
    };
}
const g_ = {
    bigint: (r)=>typeof r == "bigint",
    function: (r)=>typeof r == "function",
    boolean: (r)=>typeof r == "boolean",
    string: (r)=>typeof r == "string",
    stringOrUint8Array: (r)=>typeof r == "string" || mo(r),
    isSafeInteger: (r)=>Number.isSafeInteger(r),
    array: (r)=>Array.isArray(r),
    field: (r, e)=>e.Fp.isValid(r),
    hash: (r)=>typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function Pc(r, e, t = {}) {
    const n = (s, i, o)=>{
        const a = g_[i];
        if (typeof a != "function") throw new Error("invalid validator function");
        const u = r[s];
        if (!(o && u === void 0) && !a(u, r)) throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + u);
    };
    for (const [s, i] of Object.entries(e))n(s, i, !1);
    for (const [s, i] of Object.entries(t))n(s, i, !0);
    return r;
}
function ip(r) {
    const e = /* @__PURE__ */ new WeakMap();
    return (t, ...n)=>{
        const s = e.get(t);
        if (s !== void 0) return s;
        const i = r(t, ...n);
        return e.set(t, i), i;
    };
}
function y_(r, e) {
    if (cp(r) > e) throw new P_({
        givenSize: cp(r),
        maxSize: e
    });
}
const Jr = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function sp(r) {
    if (r >= Jr.zero && r <= Jr.nine) return r - Jr.zero;
    if (r >= Jr.A && r <= Jr.F) return r - (Jr.A - 10);
    if (r >= Jr.a && r <= Jr.f) return r - (Jr.a - 10);
}
function w_(r, e = {}) {
    const { dir: t, size: n = 32 } = e;
    if (n === 0) return r;
    if (r.length > n) throw new U_({
        size: r.length,
        targetSize: n,
        type: "Bytes"
    });
    const s = new Uint8Array(n);
    for(let i = 0; i < n; i++){
        const o = t === "right";
        s[o ? i : n - i - 1] = r[o ? i : r.length - i - 1];
    }
    return s;
}
function Dw(r, e) {
    if (Wn(r) > e) throw new D_({
        givenSize: Wn(r),
        maxSize: e
    });
}
function m_(r, e) {
    if (typeof e == "number" && e > 0 && e > Wn(r) - 1) throw new Sw({
        offset: e,
        position: "start",
        size: Wn(r)
    });
}
function b_(r, e, t) {
    if (typeof e == "number" && typeof t == "number" && Wn(r) !== t - e) throw new Sw({
        offset: t,
        position: "end",
        size: Wn(r)
    });
}
function _w(r, e = {}) {
    const { dir: t, size: n = 32 } = e;
    if (n === 0) return r;
    const s = r.replace("0x", "");
    if (s.length > n * 2) throw new __({
        size: Math.ceil(s.length / 2),
        targetSize: n,
        type: "Hex"
    });
    return `0x${s[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
const v_ = "#__bigint";
function Qd(r, e, t) {
    return JSON.stringify(r, (n, s)=>typeof s == "bigint" ? s.toString() + v_ : s, t);
}
const E_ = /* @__PURE__ */ Array.from({
    length: 256
}, (r, e)=>e.toString(16).padStart(2, "0"));
function M_(r, e = {}) {
    const { strict: t = !1 } = e;
    if (!r) throw new op(r);
    if (typeof r != "string") throw new op(r);
    if (t && !/^0x[0-9a-fA-F]*$/.test(r)) throw new ap(r);
    if (!r.startsWith("0x")) throw new ap(r);
}
function N_(...r) {
    return `0x${r.reduce((e, t)=>e + t.replace("0x", ""), "")}`;
}
function Vd(r) {
    return r instanceof Uint8Array ? La(r) : Array.isArray(r) ? La(new Uint8Array(r)) : r;
}
function La(r, e = {}) {
    let t = "";
    for(let s = 0; s < r.length; s++)t += E_[r[s]];
    const n = `0x${t}`;
    return typeof e.size == "number" ? (Dw(n, e.size), Aw(n, e.size)) : n;
}
function Au(r, e = {}) {
    const { signed: t, size: n } = e, s = BigInt(r);
    let i;
    n ? t ? i = (1n << BigInt(n) * 8n - 1n) - 1n : i = 2n ** (BigInt(n) * 8n) - 1n : typeof r == "number" && (i = BigInt(Number.MAX_SAFE_INTEGER));
    const o = typeof i == "bigint" && t ? -i - 1n : 0;
    if (i && s > i || s < o) {
        const c = typeof r == "bigint" ? "n" : "";
        throw new T_({
            max: i ? `${i}${c}` : void 0,
            min: `${o}${c}`,
            signed: t,
            size: n,
            value: `${r}${c}`
        });
    }
    const u = `0x${(t && s < 0 ? (1n << BigInt(n * 8)) + BigInt(s) : s).toString(16)}`;
    return n ? x_(u, n) : u;
}
function x_(r, e) {
    return _w(r, {
        dir: "left",
        size: e
    });
}
function Aw(r, e) {
    return _w(r, {
        dir: "right",
        size: e
    });
}
function an(r, e, t, n = {}) {
    const { strict: s } = n;
    m_(r, e);
    const i = `0x${r.replace("0x", "").slice((e ?? 0) * 2, (t ?? r.length) * 2)}`;
    return s && b_(i, e, t), i;
}
function Wn(r) {
    return Math.ceil((r.length - 2) / 2);
}
function I_(r, e = {}) {
    const { strict: t = !1 } = e;
    try {
        return M_(r, {
            strict: t
        }), !0;
    } catch  {
        return !1;
    }
}
class T_ extends We {
    constructor({ max: e, min: t, signed: n, size: s, value: i }){
        super(`Number \`${i}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${n ? " signed" : " unsigned"} integer range ${e ? `(\`${t}\` to \`${e}\`)` : `(above \`${t}\`)`}`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.IntegerOutOfRangeError"
        });
    }
}
class op extends We {
    constructor(e){
        super(`Value \`${typeof e == "object" ? Qd(e) : e}\` of type \`${typeof e}\` is an invalid hex type.`, {
            metaMessages: [
                'Hex types must be represented as `"0x${string}"`.'
            ]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.InvalidHexTypeError"
        });
    }
}
class ap extends We {
    constructor(e){
        super(`Value \`${e}\` is an invalid hex value.`, {
            metaMessages: [
                'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
            ]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.InvalidHexValueError"
        });
    }
}
let D_ = class extends We {
    constructor({ givenSize: e, maxSize: t }){
        super(`Size cannot exceed \`${t}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeOverflowError"
        });
    }
};
class Sw extends We {
    constructor({ offset: e, position: t, size: n }){
        super(`Slice ${t === "start" ? "starting" : "ending"} at offset \`${e}\` is out-of-bounds (size: \`${n}\`).`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SliceOffsetOutOfBoundsError"
        });
    }
}
let __ = class extends We {
    constructor({ size: e, targetSize: t, type: n }){
        super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${t}\`).`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeExceedsPaddingSizeError"
        });
    }
};
const A_ = /* @__PURE__ */ new TextEncoder();
function S_(r) {
    if (!(r instanceof Uint8Array)) {
        if (!r) throw new Go(r);
        if (typeof r != "object") throw new Go(r);
        if (!("BYTES_PER_ELEMENT" in r)) throw new Go(r);
        if (r.BYTES_PER_ELEMENT !== 1 || r.constructor.name !== "Uint8Array") throw new Go(r);
    }
}
function O_(r) {
    return r instanceof Uint8Array ? r : typeof r == "string" ? C_(r) : j_(r);
}
function j_(r) {
    return r instanceof Uint8Array ? r : new Uint8Array(r);
}
function C_(r, e = {}) {
    const { size: t } = e;
    let n = r;
    t && (Dw(r, t), n = Aw(r, t));
    let s = n.slice(2);
    s.length % 2 && (s = `0${s}`);
    const i = s.length / 2, o = new Uint8Array(i);
    for(let a = 0, u = 0; a < i; a++){
        const c = sp(s.charCodeAt(u++)), l = sp(s.charCodeAt(u++));
        if (c === void 0 || l === void 0) throw new We(`Invalid byte sequence ("${s[u - 2]}${s[u - 1]}" in "${s}").`);
        o[a] = c * 16 + l;
    }
    return o;
}
function L_(r, e = {}) {
    const { size: t } = e, n = A_.encode(r);
    return typeof t == "number" ? (y_(n, t), k_(n, t)) : n;
}
function k_(r, e) {
    return w_(r, {
        dir: "right",
        size: e
    });
}
function cp(r) {
    return r.length;
}
function z_(r) {
    try {
        return S_(r), !0;
    } catch  {
        return !1;
    }
}
class Go extends We {
    constructor(e){
        super(`Value \`${typeof e == "object" ? Qd(e) : e}\` of type \`${typeof e}\` is an invalid Bytes value.`, {
            metaMessages: [
                "Bytes values must be of type `Bytes`."
            ]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.InvalidBytesTypeError"
        });
    }
}
class P_ extends We {
    constructor({ givenSize: e, maxSize: t }){
        super(`Size cannot exceed \`${t}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeOverflowError"
        });
    }
}
class U_ extends We {
    constructor({ size: e, targetSize: t, type: n }){
        super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${t}\`).`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeExceedsPaddingSizeError"
        });
    }
}
function Ow(r, e = {}) {
    const { as: t = typeof r == "string" ? "Hex" : "Bytes" } = e, n = c_(O_(r));
    return t === "Bytes" ? n : La(n);
}
class R_ extends Map {
    constructor(e){
        super(), Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.maxSize = e;
    }
    get(e) {
        const t = super.get(e);
        return super.has(e) && t !== void 0 && (this.delete(e), super.set(e, t)), t;
    }
    set(e, t) {
        if (super.set(e, t), this.maxSize && this.size > this.maxSize) {
            const n = this.keys().next().value;
            n && this.delete(n);
        }
        return this;
    }
}
const $_ = {
    checksum: /* @__PURE__ */ new R_(8192)
}, Su = $_.checksum;
function jw(r, e = {}) {
    const { compressed: t } = e, { prefix: n, x: s, y: i } = r;
    if (t === !1 || typeof s == "bigint" && typeof i == "bigint") {
        if (n !== 4) throw new up({
            prefix: n,
            cause: new Y_()
        });
        return;
    }
    if (t === !0 || typeof s == "bigint" && typeof i > "u") {
        if (n !== 3 && n !== 2) throw new up({
            prefix: n,
            cause: new V_()
        });
        return;
    }
    throw new Q_({
        publicKey: r
    });
}
function B_(r) {
    const e = (()=>{
        if (I_(r)) return Cw(r);
        if (z_(r)) return F_(r);
        const { prefix: t, x: n, y: s } = r;
        return typeof n == "bigint" && typeof s == "bigint" ? {
            prefix: t ?? 4,
            x: n,
            y: s
        } : {
            prefix: t,
            x: n
        };
    })();
    return jw(e), e;
}
function F_(r) {
    return Cw(La(r));
}
function Cw(r) {
    if (r.length !== 132 && r.length !== 130 && r.length !== 68) throw new G_({
        publicKey: r
    });
    if (r.length === 130) {
        const n = BigInt(an(r, 0, 32)), s = BigInt(an(r, 32, 64));
        return {
            prefix: 4,
            x: n,
            y: s
        };
    }
    if (r.length === 132) {
        const n = Number(an(r, 0, 1)), s = BigInt(an(r, 1, 33)), i = BigInt(an(r, 33, 65));
        return {
            prefix: n,
            x: s,
            y: i
        };
    }
    const e = Number(an(r, 0, 1)), t = BigInt(an(r, 1, 33));
    return {
        prefix: e,
        x: t
    };
}
function q_(r, e = {}) {
    jw(r);
    const { prefix: t, x: n, y: s } = r, { includePrefix: i = !0 } = e;
    return N_(i ? Au(t, {
        size: 1
    }) : "0x", Au(n, {
        size: 32
    }), // If the public key is not compressed, add the y coordinate.
    typeof s == "bigint" ? Au(s, {
        size: 32
    }) : "0x");
}
class Q_ extends We {
    constructor({ publicKey: e }){
        super(`Value \`${Qd(e)}\` is not a valid public key.`, {
            metaMessages: [
                "Public key must contain:",
                "- an `x` and `prefix` value (compressed)",
                "- an `x`, `y`, and `prefix` value (uncompressed)"
            ]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidError"
        });
    }
}
class up extends We {
    constructor({ prefix: e, cause: t }){
        super(`Prefix "${e}" is invalid.`, {
            cause: t
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidPrefixError"
        });
    }
}
class V_ extends We {
    constructor(){
        super("Prefix must be 2 or 3 for compressed public keys."), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidCompressedPrefixError"
        });
    }
}
class Y_ extends We {
    constructor(){
        super("Prefix must be 4 for uncompressed public keys."), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidUncompressedPrefixError"
        });
    }
}
let G_ = class extends We {
    constructor({ publicKey: e }){
        super(`Value \`${e}\` is an invalid public key size.`, {
            metaMessages: [
                "Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",
                `Received ${Wn(Vd(e))} bytes.`
            ]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidSerializedSizeError"
        });
    }
};
const H_ = /^0x[a-fA-F0-9]{40}$/;
function Lw(r, e = {}) {
    const { strict: t = !0 } = e;
    if (!H_.test(r)) throw new lp({
        address: r,
        cause: new X_()
    });
    if (t) {
        if (r.toLowerCase() === r) return;
        if (kw(r) !== r) throw new lp({
            address: r,
            cause: new Z_()
        });
    }
}
function kw(r) {
    if (Su.has(r)) return Su.get(r);
    Lw(r, {
        strict: !1
    });
    const e = r.substring(2).toLowerCase(), t = Ow(L_(e), {
        as: "Bytes"
    }), n = e.split("");
    for(let i = 0; i < 40; i += 2)t[i >> 1] >> 4 >= 8 && n[i] && (n[i] = n[i].toUpperCase()), (t[i >> 1] & 15) >= 8 && n[i + 1] && (n[i + 1] = n[i + 1].toUpperCase());
    const s = `0x${n.join("")}`;
    return Su.set(r, s), s;
}
function W_(r, e = {}) {
    const { checksum: t = !1 } = e;
    return Lw(r), t ? kw(r) : r;
}
function K_(r, e = {}) {
    const t = Ow(`0x${q_(r).slice(4)}`).substring(26);
    return W_(`0x${t}`, e);
}
class lp extends We {
    constructor({ address: e, cause: t }){
        super(`Address "${e}" is invalid.`, {
            cause: t
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidAddressError"
        });
    }
}
class X_ extends We {
    constructor(){
        super("Address is not a 20 byte (40 hexadecimal character) value."), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidInputError"
        });
    }
}
class Z_ extends We {
    constructor(){
        super("Address does not match its checksum counterpart."), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidChecksumError"
        });
    }
}
class zw extends Rd {
    constructor(e, t){
        super(), this.finished = !1, this.destroyed = !1, kD(e);
        const n = kc(t);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const s = this.blockLen, i = new Uint8Array(s);
        i.set(n.length > s ? e.create().update(n).digest() : n);
        for(let o = 0; o < i.length; o++)i[o] ^= 54;
        this.iHash.update(i), this.oHash = e.create();
        for(let o = 0; o < i.length; o++)i[o] ^= 106;
        this.oHash.update(i), as(i);
    }
    update(e) {
        return os(this), this.iHash.update(e), this;
    }
    digestInto(e) {
        os(this), xi(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: t, iHash: n, finished: s, destroyed: i, blockLen: o, outputLen: a } = this;
        return e = e, e.finished = s, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
}
const Pw = (r, e, t)=>new zw(r, e).update(t).digest();
Pw.create = (r, e)=>new zw(r, e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Jt = BigInt(0), Bt = BigInt(1), gi = /* @__PURE__ */ BigInt(2), J_ = /* @__PURE__ */ BigInt(3), Uw = /* @__PURE__ */ BigInt(4), Rw = /* @__PURE__ */ BigInt(5), $w = /* @__PURE__ */ BigInt(8);
function Kt(r, e) {
    const t = r % e;
    return t >= Jt ? t : e + t;
}
function lr(r, e, t) {
    let n = r;
    for(; e-- > Jt;)n *= n, n %= t;
    return n;
}
function Sl(r, e) {
    if (r === Jt) throw new Error("invert: expected non-zero number");
    if (e <= Jt) throw new Error("invert: expected positive modulus, got " + e);
    let t = Kt(r, e), n = e, s = Jt, i = Bt;
    for(; t !== Jt;){
        const a = n / t, u = n % t, c = s - i * a;
        n = t, t = u, s = i, i = c;
    }
    if (n !== Bt) throw new Error("invert: does not exist");
    return Kt(s, e);
}
function Bw(r, e) {
    const t = (r.ORDER + Bt) / Uw, n = r.pow(e, t);
    if (!r.eql(r.sqr(n), e)) throw new Error("Cannot find square root");
    return n;
}
function eA(r, e) {
    const t = (r.ORDER - Rw) / $w, n = r.mul(e, gi), s = r.pow(n, t), i = r.mul(e, s), o = r.mul(r.mul(i, gi), s), a = r.mul(i, r.sub(o, r.ONE));
    if (!r.eql(r.sqr(a), e)) throw new Error("Cannot find square root");
    return a;
}
function tA(r) {
    if (r < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let e = r - Bt, t = 0;
    for(; e % gi === Jt;)e /= gi, t++;
    let n = gi;
    const s = Yd(r);
    for(; dp(s, n) === 1;)if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (t === 1) return Bw;
    let i = s.pow(n, e);
    const o = (e + Bt) / gi;
    return function(u, c) {
        if (u.is0(c)) return c;
        if (dp(u, c) !== 1) throw new Error("Cannot find square root");
        let l = t, d = u.mul(u.ONE, i), h = u.pow(c, e), f = u.pow(c, o);
        for(; !u.eql(h, u.ONE);){
            if (u.is0(h)) return u.ZERO;
            let g = 1, p = u.sqr(h);
            for(; !u.eql(p, u.ONE);)if (g++, p = u.sqr(p), g === l) throw new Error("Cannot find square root");
            const m = Bt << BigInt(l - g - 1), x = u.pow(d, m);
            l = g, d = u.sqr(x), h = u.mul(h, d), f = u.mul(f, x);
        }
        return f;
    };
}
function rA(r) {
    return r % Uw === J_ ? Bw : r % $w === Rw ? eA : tA(r);
}
const nA = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function iA(r) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }, t = nA.reduce((n, s)=>(n[s] = "function", n), e);
    return Pc(r, t);
}
function sA(r, e, t) {
    if (t < Jt) throw new Error("invalid exponent, negatives unsupported");
    if (t === Jt) return r.ONE;
    if (t === Bt) return e;
    let n = r.ONE, s = e;
    for(; t > Jt;)t & Bt && (n = r.mul(n, s)), s = r.sqr(s), t >>= Bt;
    return n;
}
function Fw(r, e, t = !1) {
    const n = new Array(e.length).fill(t ? r.ZERO : void 0), s = e.reduce((o, a, u)=>r.is0(a) ? o : (n[u] = o, r.mul(o, a)), r.ONE), i = r.inv(s);
    return e.reduceRight((o, a, u)=>r.is0(a) ? o : (n[u] = r.mul(o, n[u]), r.mul(o, a)), i), n;
}
function dp(r, e) {
    const t = (r.ORDER - Bt) / gi, n = r.pow(e, t), s = r.eql(n, r.ONE), i = r.eql(n, r.ZERO), o = r.eql(n, r.neg(r.ONE));
    if (!s && !i && !o) throw new Error("invalid Legendre symbol result");
    return s ? 1 : i ? 0 : -1;
}
function qw(r, e) {
    e !== void 0 && ao(e);
    const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: n
    };
}
function Yd(r, e, t = !1, n = {}) {
    if (r <= Jt) throw new Error("invalid field: expected ORDER > 0, got " + r);
    const { nBitLength: s, nByteLength: i } = qw(r, e);
    if (i > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let o;
    const a = Object.freeze({
        ORDER: r,
        isLE: t,
        BITS: s,
        BYTES: i,
        MASK: zc(s),
        ZERO: Jt,
        ONE: Bt,
        create: (u)=>Kt(u, r),
        isValid: (u)=>{
            if (typeof u != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof u);
            return Jt <= u && u < r;
        },
        is0: (u)=>u === Jt,
        isOdd: (u)=>(u & Bt) === Bt,
        neg: (u)=>Kt(-u, r),
        eql: (u, c)=>u === c,
        sqr: (u)=>Kt(u * u, r),
        add: (u, c)=>Kt(u + c, r),
        sub: (u, c)=>Kt(u - c, r),
        mul: (u, c)=>Kt(u * c, r),
        pow: (u, c)=>sA(a, u, c),
        div: (u, c)=>Kt(u * Sl(c, r), r),
        // Same as above, but doesn't normalize
        sqrN: (u)=>u * u,
        addN: (u, c)=>u + c,
        subN: (u, c)=>u - c,
        mulN: (u, c)=>u * c,
        inv: (u)=>Sl(u, r),
        sqrt: n.sqrt || ((u)=>(o || (o = rA(r)), o(a, u))),
        toBytes: (u)=>t ? Tw(u, i) : bo(u, i),
        fromBytes: (u)=>{
            if (u.length !== i) throw new Error("Field.fromBytes: expected " + i + " bytes, got " + u.length);
            return t ? Iw(u) : vi(u);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (u)=>Fw(a, u),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (u, c, l)=>l ? c : u
    });
    return Object.freeze(a);
}
function Qw(r) {
    if (typeof r != "bigint") throw new Error("field order must be bigint");
    const e = r.toString(2).length;
    return Math.ceil(e / 8);
}
function Vw(r) {
    const e = Qw(r);
    return e + Math.ceil(e / 2);
}
function oA(r, e, t = !1) {
    const n = r.length, s = Qw(e), i = Vw(e);
    if (n < 16 || n < i || n > 1024) throw new Error("expected " + i + "-1024 bytes of input, got " + n);
    const o = t ? Iw(r) : vi(r), a = Kt(o, e - Bt) + Bt;
    return t ? Tw(a, s) : bo(a, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hp = BigInt(0), Ol = BigInt(1);
function Ou(r, e) {
    const t = e.negate();
    return r ? t : e;
}
function Yw(r, e) {
    if (!Number.isSafeInteger(r) || r <= 0 || r > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function ju(r, e) {
    Yw(r, e);
    const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1), s = 2 ** r, i = zc(r), o = BigInt(r);
    return {
        windows: t,
        windowSize: n,
        mask: i,
        maxNumber: s,
        shiftBy: o
    };
}
function fp(r, e, t) {
    const { windowSize: n, mask: s, maxNumber: i, shiftBy: o } = t;
    let a = Number(r & s), u = r >> o;
    a > n && (a -= i, u += Ol);
    const c = e * n, l = c + Math.abs(a) - 1, d = a === 0, h = a < 0, f = e % 2 !== 0;
    return {
        nextN: u,
        offset: l,
        isZero: d,
        isNeg: h,
        isNegF: f,
        offsetF: c
    };
}
function aA(r, e) {
    if (!Array.isArray(r)) throw new Error("array expected");
    r.forEach((t, n)=>{
        if (!(t instanceof e)) throw new Error("invalid point at index " + n);
    });
}
function cA(r, e) {
    if (!Array.isArray(r)) throw new Error("array of scalars expected");
    r.forEach((t, n)=>{
        if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
    });
}
const Cu = /* @__PURE__ */ new WeakMap(), Gw = /* @__PURE__ */ new WeakMap();
function Lu(r) {
    return Gw.get(r) || 1;
}
function uA(r, e) {
    return {
        constTimeNegate: Ou,
        hasPrecomputes (t) {
            return Lu(t) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder (t, n, s = r.ZERO) {
            let i = t;
            for(; n > hp;)n & Ol && (s = s.add(i)), i = i.double(), n >>= Ol;
            return s;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (t, n) {
            const { windows: s, windowSize: i } = ju(n, e), o = [];
            let a = t, u = a;
            for(let c = 0; c < s; c++){
                u = a, o.push(u);
                for(let l = 1; l < i; l++)u = u.add(a), o.push(u);
                a = u.double();
            }
            return o;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (t, n, s) {
            let i = r.ZERO, o = r.BASE;
            const a = ju(t, e);
            for(let u = 0; u < a.windows; u++){
                const { nextN: c, offset: l, isZero: d, isNeg: h, isNegF: f, offsetF: g } = fp(s, u, a);
                s = c, d ? o = o.add(Ou(f, n[g])) : i = i.add(Ou(h, n[l]));
            }
            return {
                p: i,
                f: o
            };
        },
        /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */ wNAFUnsafe (t, n, s, i = r.ZERO) {
            const o = ju(t, e);
            for(let a = 0; a < o.windows && s !== hp; a++){
                const { nextN: u, offset: c, isZero: l, isNeg: d } = fp(s, a, o);
                if (s = u, !l) {
                    const h = n[c];
                    i = i.add(d ? h.negate() : h);
                }
            }
            return i;
        },
        getPrecomputes (t, n, s) {
            let i = Cu.get(n);
            return i || (i = this.precomputeWindow(n, t), t !== 1 && Cu.set(n, s(i))), i;
        },
        wNAFCached (t, n, s) {
            const i = Lu(t);
            return this.wNAF(i, this.getPrecomputes(i, t, s), n);
        },
        wNAFCachedUnsafe (t, n, s, i) {
            const o = Lu(t);
            return o === 1 ? this.unsafeLadder(t, n, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, s), n, i);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (t, n) {
            Yw(n, e), Gw.set(t, n), Cu.delete(t);
        }
    };
}
function lA(r, e, t, n) {
    aA(t, r), cA(n, e);
    const s = t.length, i = n.length;
    if (s !== i) throw new Error("arrays of points and scalars must have equal length");
    const o = r.ZERO, a = f_(BigInt(s));
    let u = 1;
    a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
    const c = zc(u), l = new Array(Number(c) + 1).fill(o), d = Math.floor((e.BITS - 1) / u) * u;
    let h = o;
    for(let f = d; f >= 0; f -= u){
        l.fill(o);
        for(let p = 0; p < i; p++){
            const m = n[p], x = Number(m >> BigInt(f) & c);
            l[x] = l[x].add(t[p]);
        }
        let g = o;
        for(let p = l.length - 1, m = o; p > 0; p--)m = m.add(l[p]), g = g.add(m);
        if (h = h.add(g), f !== 0) for(let p = 0; p < u; p++)h = h.double();
    }
    return h;
}
function Hw(r) {
    return iA(r.Fp), Pc(r, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...qw(r.n, r.nBitLength),
        ...r,
        p: r.Fp.ORDER
    });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function pp(r) {
    r.lowS !== void 0 && co("lowS", r.lowS), r.prehash !== void 0 && co("prehash", r.prehash);
}
function dA(r) {
    const e = Hw(r);
    Pc(e, {
        a: "field",
        b: "field"
    }, {
        allowInfinityPoint: "boolean",
        allowedPrivateKeyLengths: "array",
        clearCofactor: "function",
        fromBytes: "function",
        isTorsionFree: "function",
        toBytes: "function",
        wrapPrivateKey: "boolean"
    });
    const { endo: t, Fp: n, a: s } = e;
    if (t) {
        if (!n.eql(s, n.ZERO)) throw new Error("invalid endo: CURVE.a must be 0");
        if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function") throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
    return Object.freeze({
        ...e
    });
}
class hA extends Error {
    constructor(e = ""){
        super(e);
    }
}
const cn = {
    // asn.1 DER encoding utils
    Err: hA,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (r, e)=>{
            const { Err: t } = cn;
            if (r < 0 || r > 256) throw new t("tlv.encode: wrong tag");
            if (e.length & 1) throw new t("tlv.encode: unpadded data");
            const n = e.length / 2, s = Yo(n);
            if (s.length / 2 & 128) throw new t("tlv.encode: long form length too big");
            const i = n > 127 ? Yo(s.length / 2 | 128) : "";
            return Yo(r) + i + s + e;
        },
        // v - value, l - left bytes (unparsed)
        decode (r, e) {
            const { Err: t } = cn;
            let n = 0;
            if (r < 0 || r > 256) throw new t("tlv.encode: wrong tag");
            if (e.length < 2 || e[n++] !== r) throw new t("tlv.decode: wrong tlv");
            const s = e[n++], i = !!(s & 128);
            let o = 0;
            if (!i) o = s;
            else {
                const u = s & 127;
                if (!u) throw new t("tlv.decode(long): indefinite length not supported");
                if (u > 4) throw new t("tlv.decode(long): byte length is too big");
                const c = e.subarray(n, n + u);
                if (c.length !== u) throw new t("tlv.decode: length bytes not complete");
                if (c[0] === 0) throw new t("tlv.decode(long): zero leftmost byte");
                for (const l of c)o = o << 8 | l;
                if (n += u, o < 128) throw new t("tlv.decode(long): not minimal encoding");
            }
            const a = e.subarray(n, n + o);
            if (a.length !== o) throw new t("tlv.decode: wrong value length");
            return {
                v: a,
                l: e.subarray(n + o)
            };
        }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode (r) {
            const { Err: e } = cn;
            if (r < dn) throw new e("integer: negative integers are not allowed");
            let t = Yo(r);
            if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
            return t;
        },
        decode (r) {
            const { Err: e } = cn;
            if (r[0] & 128) throw new e("invalid signature integer: negative");
            if (r[0] === 0 && !(r[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
            return vi(r);
        }
    },
    toSig (r) {
        const { Err: e, _int: t, _tlv: n } = cn, s = gr("signature", r), { v: i, l: o } = n.decode(48, s);
        if (o.length) throw new e("invalid signature: left bytes after parsing");
        const { v: a, l: u } = n.decode(2, i), { v: c, l } = n.decode(2, u);
        if (l.length) throw new e("invalid signature: left bytes after parsing");
        return {
            r: t.decode(a),
            s: t.decode(c)
        };
    },
    hexFromSig (r) {
        const { _tlv: e, _int: t } = cn, n = e.encode(2, t.encode(r.r)), s = e.encode(2, t.encode(r.s)), i = n + s;
        return e.encode(48, i);
    }
};
function ku(r, e) {
    return uo(bo(r, e));
}
const dn = BigInt(0), vt = BigInt(1);
BigInt(2);
const zu = BigInt(3), fA = BigInt(4);
function pA(r) {
    const e = dA(r), { Fp: t } = e, n = Yd(e.n, e.nBitLength), s = e.toBytes || ((v, N, O)=>{
        const z = N.toAffine();
        return Ca(Uint8Array.from([
            4
        ]), t.toBytes(z.x), t.toBytes(z.y));
    }), i = e.fromBytes || ((v)=>{
        const N = v.subarray(1), O = t.fromBytes(N.subarray(0, t.BYTES)), z = t.fromBytes(N.subarray(t.BYTES, 2 * t.BYTES));
        return {
            x: O,
            y: z
        };
    });
    function o(v) {
        const { a: N, b: O } = e, z = t.sqr(v), P = t.mul(z, v);
        return t.add(t.add(P, t.mul(v, N)), O);
    }
    function a(v, N) {
        const O = t.sqr(N), z = o(v);
        return t.eql(O, z);
    }
    if (!a(e.Gx, e.Gy)) throw new Error("bad curve params: generator point");
    const u = t.mul(t.pow(e.a, zu), fA), c = t.mul(t.sqr(e.b), BigInt(27));
    if (t.is0(t.add(u, c))) throw new Error("bad curve params: a or b");
    function l(v) {
        return qd(v, vt, e.n);
    }
    function d(v) {
        const { allowedPrivateKeyLengths: N, nByteLength: O, wrapPrivateKey: z, n: P } = e;
        if (N && typeof v != "bigint") {
            if (mo(v) && (v = uo(v)), typeof v != "string" || !N.includes(v.length)) throw new Error("invalid private key");
            v = v.padStart(O * 2, "0");
        }
        let U;
        try {
            U = typeof v == "bigint" ? v : vi(gr("private key", v, O));
        } catch  {
            throw new Error("invalid private key, expected hex or " + O + " bytes, got " + typeof v);
        }
        return z && (U = Kt(U, P)), es("private key", U, vt, P), U;
    }
    function h(v) {
        if (!(v instanceof p)) throw new Error("ProjectivePoint expected");
    }
    const f = ip((v, N)=>{
        const { px: O, py: z, pz: P } = v;
        if (t.eql(P, t.ONE)) return {
            x: O,
            y: z
        };
        const U = v.is0();
        N == null && (N = U ? t.ONE : t.inv(P));
        const R = t.mul(O, N), G = t.mul(z, N), F = t.mul(P, N);
        if (U) return {
            x: t.ZERO,
            y: t.ZERO
        };
        if (!t.eql(F, t.ONE)) throw new Error("invZ was invalid");
        return {
            x: R,
            y: G
        };
    }), g = ip((v)=>{
        if (v.is0()) {
            if (e.allowInfinityPoint && !t.is0(v.py)) return;
            throw new Error("bad point: ZERO");
        }
        const { x: N, y: O } = v.toAffine();
        if (!t.isValid(N) || !t.isValid(O)) throw new Error("bad point: x or y not FE");
        if (!a(N, O)) throw new Error("bad point: equation left != right");
        if (!v.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return !0;
    });
    class p {
        constructor(N, O, z){
            if (N == null || !t.isValid(N)) throw new Error("x required");
            if (O == null || !t.isValid(O) || t.is0(O)) throw new Error("y required");
            if (z == null || !t.isValid(z)) throw new Error("z required");
            this.px = N, this.py = O, this.pz = z, Object.freeze(this);
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(N) {
            const { x: O, y: z } = N || {};
            if (!N || !t.isValid(O) || !t.isValid(z)) throw new Error("invalid affine point");
            if (N instanceof p) throw new Error("projective point not allowed");
            const P = (U)=>t.eql(U, t.ZERO);
            return P(O) && P(z) ? p.ZERO : new p(O, z, t.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */ static normalizeZ(N) {
            const O = Fw(t, N.map((z)=>z.pz));
            return N.map((z, P)=>z.toAffine(O[P])).map(p.fromAffine);
        }
        /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */ static fromHex(N) {
            const O = p.fromAffine(i(gr("pointHex", N)));
            return O.assertValidity(), O;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(N) {
            return p.BASE.multiply(d(N));
        }
        // Multiscalar Multiplication
        static msm(N, O) {
            return lA(p, n, N, O);
        }
        // "Private method", don't use it directly
        _setWindowSize(N) {
            _.setWindowSize(this, N);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            g(this);
        }
        hasEvenY() {
            const { y: N } = this.toAffine();
            if (t.isOdd) return !t.isOdd(N);
            throw new Error("Field doesn't support isOdd");
        }
        /**
     * Compare one point to another.
     */ equals(N) {
            h(N);
            const { px: O, py: z, pz: P } = this, { px: U, py: R, pz: G } = N, F = t.eql(t.mul(O, G), t.mul(U, P)), H = t.eql(t.mul(z, G), t.mul(R, P));
            return F && H;
        }
        /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */ negate() {
            return new p(this.px, t.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a: N, b: O } = e, z = t.mul(O, zu), { px: P, py: U, pz: R } = this;
            let G = t.ZERO, F = t.ZERO, H = t.ZERO, B = t.mul(P, P), C = t.mul(U, U), T = t.mul(R, R), I = t.mul(P, U);
            return I = t.add(I, I), H = t.mul(P, R), H = t.add(H, H), G = t.mul(N, H), F = t.mul(z, T), F = t.add(G, F), G = t.sub(C, F), F = t.add(C, F), F = t.mul(G, F), G = t.mul(I, G), H = t.mul(z, H), T = t.mul(N, T), I = t.sub(B, T), I = t.mul(N, I), I = t.add(I, H), H = t.add(B, B), B = t.add(H, B), B = t.add(B, T), B = t.mul(B, I), F = t.add(F, B), T = t.mul(U, R), T = t.add(T, T), B = t.mul(T, I), G = t.sub(G, B), H = t.mul(T, C), H = t.add(H, H), H = t.add(H, H), new p(G, F, H);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(N) {
            h(N);
            const { px: O, py: z, pz: P } = this, { px: U, py: R, pz: G } = N;
            let F = t.ZERO, H = t.ZERO, B = t.ZERO;
            const C = e.a, T = t.mul(e.b, zu);
            let I = t.mul(O, U), y = t.mul(z, R), w = t.mul(P, G), M = t.add(O, z), D = t.add(U, R);
            M = t.mul(M, D), D = t.add(I, y), M = t.sub(M, D), D = t.add(O, P);
            let A = t.add(U, G);
            return D = t.mul(D, A), A = t.add(I, w), D = t.sub(D, A), A = t.add(z, P), F = t.add(R, G), A = t.mul(A, F), F = t.add(y, w), A = t.sub(A, F), B = t.mul(C, D), F = t.mul(T, w), B = t.add(F, B), F = t.sub(y, B), B = t.add(y, B), H = t.mul(F, B), y = t.add(I, I), y = t.add(y, I), w = t.mul(C, w), D = t.mul(T, D), y = t.add(y, w), w = t.sub(I, w), w = t.mul(C, w), D = t.add(D, w), I = t.mul(y, D), H = t.add(H, I), I = t.mul(A, D), F = t.mul(M, F), F = t.sub(F, I), I = t.mul(M, y), B = t.mul(A, B), B = t.add(B, I), new p(F, H, B);
        }
        subtract(N) {
            return this.add(N.negate());
        }
        is0() {
            return this.equals(p.ZERO);
        }
        wNAF(N) {
            return _.wNAFCached(this, N, p.normalizeZ);
        }
        /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */ multiplyUnsafe(N) {
            const { endo: O, n: z } = e;
            es("scalar", N, dn, z);
            const P = p.ZERO;
            if (N === dn) return P;
            if (this.is0() || N === vt) return this;
            if (!O || _.hasPrecomputes(this)) return _.wNAFCachedUnsafe(this, N, p.normalizeZ);
            let { k1neg: U, k1: R, k2neg: G, k2: F } = O.splitScalar(N), H = P, B = P, C = this;
            for(; R > dn || F > dn;)R & vt && (H = H.add(C)), F & vt && (B = B.add(C)), C = C.double(), R >>= vt, F >>= vt;
            return U && (H = H.negate()), G && (B = B.negate()), B = new p(t.mul(B.px, O.beta), B.py, B.pz), H.add(B);
        }
        /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */ multiply(N) {
            const { endo: O, n: z } = e;
            es("scalar", N, vt, z);
            let P, U;
            if (O) {
                const { k1neg: R, k1: G, k2neg: F, k2: H } = O.splitScalar(N);
                let { p: B, f: C } = this.wNAF(G), { p: T, f: I } = this.wNAF(H);
                B = _.constTimeNegate(R, B), T = _.constTimeNegate(F, T), T = new p(t.mul(T.px, O.beta), T.py, T.pz), P = B.add(T), U = C.add(I);
            } else {
                const { p: R, f: G } = this.wNAF(N);
                P = R, U = G;
            }
            return p.normalizeZ([
                P,
                U
            ])[0];
        }
        /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */ multiplyAndAddUnsafe(N, O, z) {
            const P = p.BASE, U = (G, F)=>F === dn || F === vt || !G.equals(P) ? G.multiplyUnsafe(F) : G.multiply(F), R = U(this, O).add(U(N, z));
            return R.is0() ? void 0 : R;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(N) {
            return f(this, N);
        }
        isTorsionFree() {
            const { h: N, isTorsionFree: O } = e;
            if (N === vt) return !0;
            if (O) return O(p, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
            const { h: N, clearCofactor: O } = e;
            return N === vt ? this : O ? O(p, this) : this.multiplyUnsafe(e.h);
        }
        toRawBytes(N = !0) {
            return co("isCompressed", N), this.assertValidity(), s(p, this, N);
        }
        toHex(N = !0) {
            return co("isCompressed", N), uo(this.toRawBytes(N));
        }
    }
    p.BASE = new p(e.Gx, e.Gy, t.ONE), p.ZERO = new p(t.ZERO, t.ONE, t.ZERO);
    const { endo: m, nBitLength: x } = e, _ = uA(p, m ? Math.ceil(x / 2) : x);
    return {
        CURVE: e,
        ProjectivePoint: p,
        normPrivateKeyToScalar: d,
        weierstrassEquation: o,
        isWithinCurveOrder: l
    };
}
function gA(r) {
    const e = Hw(r);
    return Pc(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...e
    });
}
function yA(r) {
    const e = gA(r), { Fp: t, n, nByteLength: s, nBitLength: i } = e, o = t.BYTES + 1, a = 2 * t.BYTES + 1;
    function u(T) {
        return Kt(T, n);
    }
    function c(T) {
        return Sl(T, n);
    }
    const { ProjectivePoint: l, normPrivateKeyToScalar: d, weierstrassEquation: h, isWithinCurveOrder: f } = pA({
        ...e,
        toBytes (T, I, y) {
            const w = I.toAffine(), M = t.toBytes(w.x), D = Ca;
            return co("isCompressed", y), y ? D(Uint8Array.from([
                I.hasEvenY() ? 2 : 3
            ]), M) : D(Uint8Array.from([
                4
            ]), M, t.toBytes(w.y));
        },
        fromBytes (T) {
            const I = T.length, y = T[0], w = T.subarray(1);
            if (I === o && (y === 2 || y === 3)) {
                const M = vi(w);
                if (!qd(M, vt, t.ORDER)) throw new Error("Point is not on curve");
                const D = h(M);
                let A;
                try {
                    A = t.sqrt(D);
                } catch (Y) {
                    const K = Y instanceof Error ? ": " + Y.message : "";
                    throw new Error("Point is not on curve" + K);
                }
                const L = (A & vt) === vt;
                return (y & 1) === 1 !== L && (A = t.neg(A)), {
                    x: M,
                    y: A
                };
            } else if (I === a && y === 4) {
                const M = t.fromBytes(w.subarray(0, t.BYTES)), D = t.fromBytes(w.subarray(t.BYTES, 2 * t.BYTES));
                return {
                    x: M,
                    y: D
                };
            } else {
                const M = o, D = a;
                throw new Error("invalid Point, expected length of " + M + ", or uncompressed " + D + ", got " + I);
            }
        }
    });
    function g(T) {
        const I = n >> vt;
        return T > I;
    }
    function p(T) {
        return g(T) ? u(-T) : T;
    }
    const m = (T, I, y)=>vi(T.slice(I, y));
    class x {
        constructor(I, y, w){
            es("r", I, vt, n), es("s", y, vt, n), this.r = I, this.s = y, w != null && (this.recovery = w), Object.freeze(this);
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(I) {
            const y = s;
            return I = gr("compactSignature", I, y * 2), new x(m(I, 0, y), m(I, y, 2 * y));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(I) {
            const { r: y, s: w } = cn.toSig(gr("DER", I));
            return new x(y, w);
        }
        /**
     * @todo remove
     * @deprecated
     */ assertValidity() {}
        addRecoveryBit(I) {
            return new x(this.r, this.s, I);
        }
        recoverPublicKey(I) {
            const { r: y, s: w, recovery: M } = this, D = P(gr("msgHash", I));
            if (M == null || ![
                0,
                1,
                2,
                3
            ].includes(M)) throw new Error("recovery id invalid");
            const A = M === 2 || M === 3 ? y + e.n : y;
            if (A >= t.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const L = M & 1 ? "03" : "02", V = l.fromHex(L + ku(A, t.BYTES)), Y = c(A), K = u(-D * Y), J = u(w * Y), ne = l.BASE.multiplyAndAddUnsafe(V, K, J);
            if (!ne) throw new Error("point at infinify");
            return ne.assertValidity(), ne;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return g(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new x(this.r, u(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ja(this.toDERHex());
        }
        toDERHex() {
            return cn.hexFromSig(this);
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ja(this.toCompactHex());
        }
        toCompactHex() {
            const I = s;
            return ku(this.r, I) + ku(this.s, I);
        }
    }
    const _ = {
        isValidPrivateKey (T) {
            try {
                return d(T), !0;
            } catch  {
                return !1;
            }
        },
        normPrivateKeyToScalar: d,
        /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */ randomPrivateKey: ()=>{
            const T = Vw(e.n);
            return oA(e.randomBytes(T), e.n);
        },
        /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */ precompute (T = 8, I = l.BASE) {
            return I._setWindowSize(T), I.multiply(BigInt(3)), I;
        }
    };
    function v(T, I = !0) {
        return l.fromPrivateKey(T).toRawBytes(I);
    }
    function N(T) {
        if (typeof T == "bigint") return !1;
        if (T instanceof l) return !0;
        const y = gr("key", T).length, w = t.BYTES, M = w + 1, D = 2 * w + 1;
        if (!(e.allowedPrivateKeyLengths || s === M)) return y === M || y === D;
    }
    function O(T, I, y = !0) {
        if (N(T) === !0) throw new Error("first arg must be private key");
        if (N(I) === !1) throw new Error("second arg must be public key");
        return l.fromHex(I).multiply(d(T)).toRawBytes(y);
    }
    const z = e.bits2int || function(T) {
        if (T.length > 8192) throw new Error("input is too large");
        const I = vi(T), y = T.length * 8 - i;
        return y > 0 ? I >> BigInt(y) : I;
    }, P = e.bits2int_modN || function(T) {
        return u(z(T));
    }, U = zc(i);
    function R(T) {
        return es("num < 2^" + i, T, dn, U), bo(T, s);
    }
    function G(T, I, y = F) {
        if ([
            "recovered",
            "canonical"
        ].some((oe)=>oe in y)) throw new Error("sign() legacy options not supported");
        const { hash: w, randomBytes: M } = e;
        let { lowS: D, prehash: A, extraEntropy: L } = y;
        D == null && (D = !0), T = gr("msgHash", T), pp(y), A && (T = gr("prehashed msgHash", w(T)));
        const V = P(T), Y = d(I), K = [
            R(Y),
            R(V)
        ];
        if (L != null && L !== !1) {
            const oe = L === !0 ? M(t.BYTES) : L;
            K.push(gr("extraEntropy", oe));
        }
        const J = Ca(...K), ne = V;
        function ie(oe) {
            const le = z(oe);
            if (!f(le)) return;
            const fe = c(le), Q = l.BASE.multiply(le).toAffine(), Z = u(Q.x);
            if (Z === dn) return;
            const W = u(fe * u(ne + Z * Y));
            if (W === dn) return;
            let ee = (Q.x === Z ? 0 : 2) | Number(Q.y & vt), se = W;
            return D && g(W) && (se = p(W), ee ^= 1), new x(Z, se, ee);
        }
        return {
            seed: J,
            k2sig: ie
        };
    }
    const F = {
        lowS: e.lowS,
        prehash: !1
    }, H = {
        lowS: e.lowS,
        prehash: !1
    };
    function B(T, I, y = F) {
        const { seed: w, k2sig: M } = G(T, I, y), D = e;
        return p_(D.hash.outputLen, D.nByteLength, D.hmac)(w, M);
    }
    l.BASE._setWindowSize(8);
    function C(T, I, y, w = H) {
        var ee;
        const M = T;
        I = gr("msgHash", I), y = gr("publicKey", y);
        const { lowS: D, prehash: A, format: L } = w;
        if (pp(w), "strict" in w) throw new Error("options.strict was renamed to lowS");
        if (L !== void 0 && L !== "compact" && L !== "der") throw new Error("format must be compact or der");
        const V = typeof M == "string" || mo(M), Y = !V && !L && typeof M == "object" && M !== null && typeof M.r == "bigint" && typeof M.s == "bigint";
        if (!V && !Y) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let K, J;
        try {
            if (Y && (K = new x(M.r, M.s)), V) {
                try {
                    L !== "compact" && (K = x.fromDER(M));
                } catch (se) {
                    if (!(se instanceof cn.Err)) throw se;
                }
                !K && L !== "der" && (K = x.fromCompact(M));
            }
            J = l.fromHex(y);
        } catch  {
            return !1;
        }
        if (!K || D && K.hasHighS()) return !1;
        A && (I = e.hash(I));
        const { r: ne, s: ie } = K, oe = P(I), le = c(ie), fe = u(oe * le), Q = u(ne * le), Z = (ee = l.BASE.multiplyAndAddUnsafe(J, fe, Q)) == null ? void 0 : ee.toAffine();
        return Z ? u(Z.x) === ne : !1;
    }
    return {
        CURVE: e,
        getPublicKey: v,
        getSharedSecret: O,
        sign: B,
        verify: C,
        ProjectivePoint: l,
        Signature: x,
        utils: _
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function wA(r) {
    return {
        hash: r,
        hmac: (e, ...t)=>Pw(r, e, BD(...t)),
        randomBytes: FD
    };
}
function mA(r, e) {
    const t = (n)=>yA({
            ...r,
            ...wA(n)
        });
    return {
        ...t(e),
        create: t
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Ww = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), gp = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), bA = BigInt(0), vA = BigInt(1), jl = BigInt(2), yp = (r, e)=>(r + e / jl) / e;
function EA(r) {
    const e = Ww, t = BigInt(3), n = BigInt(6), s = BigInt(11), i = BigInt(22), o = BigInt(23), a = BigInt(44), u = BigInt(88), c = r * r * r % e, l = c * c * r % e, d = lr(l, t, e) * l % e, h = lr(d, t, e) * l % e, f = lr(h, jl, e) * c % e, g = lr(f, s, e) * f % e, p = lr(g, i, e) * g % e, m = lr(p, a, e) * p % e, x = lr(m, u, e) * m % e, _ = lr(x, a, e) * p % e, v = lr(_, t, e) * l % e, N = lr(v, o, e) * g % e, O = lr(N, n, e) * c % e, z = lr(O, jl, e);
    if (!Cl.eql(Cl.sqr(z), r)) throw new Error("Cannot find square root");
    return z;
}
const Cl = Yd(Ww, void 0, void 0, {
    sqrt: EA
}), MA = mA({
    a: bA,
    b: BigInt(7),
    Fp: Cl,
    n: gp,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    // Allow only low-S signatures by default in sign() and verify()
    endo: {
        // Endomorphism, see above
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (r)=>{
            const e = gp, t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -vA * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = t, o = BigInt("0x100000000000000000000000000000000"), a = yp(i * r, e), u = yp(-n * r, e);
            let c = Kt(r - a * t - u * s, e), l = Kt(-a * n - u * i, e);
            const d = c > o, h = l > o;
            if (d && (c = e - c), h && (l = e - l), c > o || l > o) throw new Error("splitScalar: Endomorphism failed, k=" + r);
            return {
                k1neg: d,
                k1: c,
                k2neg: h,
                k2: l
            };
        }
    }
}, d_);
function NA(r) {
    if (r.length !== 130 && r.length !== 132) throw new IA({
        signature: r
    });
    const e = BigInt(an(r, 0, 32)), t = BigInt(an(r, 32, 64)), n = (()=>{
        const s = +`0x${r.slice(130)}`;
        if (!Number.isNaN(s)) try {
            return xA(s);
        } catch  {
            throw new TA({
                value: s
            });
        }
    })();
    return typeof n > "u" ? {
        r: e,
        s: t
    } : {
        r: e,
        s: t,
        yParity: n
    };
}
function xA(r) {
    if (r === 0 || r === 27) return 0;
    if (r === 1 || r === 28) return 1;
    if (r >= 35) return r % 2 === 0 ? 1 : 0;
    throw new DA({
        value: r
    });
}
class IA extends We {
    constructor({ signature: e }){
        super(`Value \`${e}\` is an invalid signature size.`, {
            metaMessages: [
                "Expected: 64 bytes or 65 bytes.",
                `Received ${Wn(Vd(e))} bytes.`
            ]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Signature.InvalidSerializedSizeError"
        });
    }
}
class TA extends We {
    constructor({ value: e }){
        super(`Value \`${e}\` is an invalid y-parity value. Y-parity must be 0 or 1.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Signature.InvalidYParityError"
        });
    }
}
class DA extends We {
    constructor({ value: e }){
        super(`Value \`${e}\` is an invalid v value. v must be 27, 28 or >=35.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Signature.InvalidVError"
        });
    }
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function _A(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Kw(r, e) {
    return Array.isArray(e) ? e.length === 0 ? !0 : r ? e.every((t)=>typeof t == "string") : e.every((t)=>Number.isSafeInteger(t)) : !1;
}
function ka(r, e) {
    if (typeof e != "string") throw new Error(`${r}: string expected`);
    return !0;
}
function Gd(r) {
    if (!Number.isSafeInteger(r)) throw new Error(`invalid integer: ${r}`);
}
function Ll(r) {
    if (!Array.isArray(r)) throw new Error("array expected");
}
function za(r, e) {
    if (!Kw(!0, e)) throw new Error(`${r}: array of strings expected`);
}
function AA(r, e) {
    if (!Kw(!1, e)) throw new Error(`${r}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function SA(...r) {
    const e = (i)=>i, t = (i, o)=>(a)=>i(o(a)), n = r.map((i)=>i.encode).reduceRight(t, e), s = r.map((i)=>i.decode).reduce(t, e);
    return {
        encode: n,
        decode: s
    };
}
// @__NO_SIDE_EFFECTS__
function OA(r) {
    const e = typeof r == "string" ? r.split("") : r, t = e.length;
    za("alphabet", e);
    const n = new Map(e.map((s, i)=>[
            s,
            i
        ]));
    return {
        encode: (s)=>(Ll(s), s.map((i)=>{
                if (!Number.isSafeInteger(i) || i < 0 || i >= t) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${r}`);
                return e[i];
            })),
        decode: (s)=>(Ll(s), s.map((i)=>{
                ka("alphabet.decode", i);
                const o = n.get(i);
                if (o === void 0) throw new Error(`Unknown letter: "${i}". Allowed: ${r}`);
                return o;
            }))
    };
}
// @__NO_SIDE_EFFECTS__
function jA(r = "") {
    return ka("join", r), {
        encode: (e)=>(za("join.decode", e), e.join(r)),
        decode: (e)=>(ka("join.decode", e), e.split(r))
    };
}
// @__NO_SIDE_EFFECTS__
function CA(r, e = "=") {
    return Gd(r), ka("padding", e), {
        encode (t) {
            for(za("padding.encode", t); t.length * r % 8;)t.push(e);
            return t;
        },
        decode (t) {
            za("padding.decode", t);
            let n = t.length;
            if (n * r % 8) throw new Error("padding: invalid, string should have whole number of bytes");
            for(; n > 0 && t[n - 1] === e; n--)if ((n - 1) * r % 8 === 0) throw new Error("padding: invalid, string has too much padding");
            return t.slice(0, n);
        }
    };
}
const Xw = (r, e)=>e === 0 ? r : Xw(e, r % e), Pa = /* @__NO_SIDE_EFFECTS__ */ (r, e)=>r + (e - Xw(r, e)), Pu = /* @__PURE__ */ (()=>{
    let r = [];
    for(let e = 0; e < 40; e++)r.push(2 ** e);
    return r;
})();
function wp(r, e, t, n) {
    if (Ll(r), e <= 0 || e > 32) throw new Error(`convertRadix2: wrong from=${e}`);
    if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong to=${t}`);
    if (/* @__PURE__ */ Pa(e, t) > 32) throw new Error(`convertRadix2: carry overflow from=${e} to=${t} carryBits=${/* @__PURE__ */ Pa(e, t)}`);
    let s = 0, i = 0;
    const o = Pu[e], a = Pu[t] - 1, u = [];
    for (const c of r){
        if (Gd(c), c >= o) throw new Error(`convertRadix2: invalid data word=${c} from=${e}`);
        if (s = s << e | c, i + e > 32) throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);
        for(i += e; i >= t; i -= t)u.push((s >> i - t & a) >>> 0);
        const l = Pu[i];
        if (l === void 0) throw new Error("invalid carry");
        s &= l - 1;
    }
    if (s = s << t - i & a, !n && i >= e) throw new Error("Excess padding");
    if (!n && s > 0) throw new Error(`Non-zero padding: ${s}`);
    return n && i > 0 && u.push(s >>> 0), u;
}
// @__NO_SIDE_EFFECTS__
function LA(r, e = !1) {
    if (Gd(r), r <= 0 || r > 32) throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ Pa(8, r) > 32 || /* @__PURE__ */ Pa(r, 8) > 32) throw new Error("radix2: carry overflow");
    return {
        encode: (t)=>{
            if (!_A(t)) throw new Error("radix2.encode input should be Uint8Array");
            return wp(Array.from(t), 8, r, !e);
        },
        decode: (t)=>(AA("radix2.decode", t), Uint8Array.from(wp(t, r, 8, e)))
    };
}
const kA = /* @__PURE__ */ SA(/* @__PURE__ */ LA(5), /* @__PURE__ */ OA("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ CA(5), /* @__PURE__ */ jA(""));
function zA(r) {
    return K_(PA(r));
}
function PA(r) {
    const { payload: e, signature: t } = r, { r: n, s, yParity: i } = t, a = new MA.Signature(BigInt(n), BigInt(s)).addRecoveryBit(i).recoverPublicKey(Vd(e).substring(2));
    return B_(a);
}
function UA(r) {
    if (r.length >= 255) throw new TypeError("Alphabet too long");
    const e = new Uint8Array(256);
    for(let c = 0; c < e.length; c++)e[c] = 255;
    for(let c = 0; c < r.length; c++){
        const l = r.charAt(c), d = l.charCodeAt(0);
        if (e[d] !== 255) throw new TypeError(l + " is ambiguous");
        e[d] = c;
    }
    const t = r.length, n = r.charAt(0), s = Math.log(t) / Math.log(256), i = Math.log(256) / Math.log(t);
    function o(c) {
        if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (c.length === 0) return "";
        let l = 0, d = 0, h = 0;
        const f = c.length;
        for(; h !== f && c[h] === 0;)h++, l++;
        const g = (f - h) * i + 1 >>> 0, p = new Uint8Array(g);
        for(; h !== f;){
            let _ = c[h], v = 0;
            for(let N = g - 1; (_ !== 0 || v < d) && N !== -1; N--, v++)_ += 256 * p[N] >>> 0, p[N] = _ % t >>> 0, _ = _ / t >>> 0;
            if (_ !== 0) throw new Error("Non-zero carry");
            d = v, h++;
        }
        let m = g - d;
        for(; m !== g && p[m] === 0;)m++;
        let x = n.repeat(l);
        for(; m < g; ++m)x += r.charAt(p[m]);
        return x;
    }
    function a(c) {
        if (typeof c != "string") throw new TypeError("Expected String");
        if (c.length === 0) return new Uint8Array();
        let l = 0, d = 0, h = 0;
        for(; c[l] === n;)d++, l++;
        const f = (c.length - l) * s + 1 >>> 0, g = new Uint8Array(f);
        for(; l < c.length;){
            const _ = c.charCodeAt(l);
            if (_ > 255) return;
            let v = e[_];
            if (v === 255) return;
            let N = 0;
            for(let O = f - 1; (v !== 0 || N < h) && O !== -1; O--, N++)v += t * g[O] >>> 0, g[O] = v % 256 >>> 0, v = v / 256 >>> 0;
            if (v !== 0) throw new Error("Non-zero carry");
            h = N, l++;
        }
        let p = f - h;
        for(; p !== f && g[p] === 0;)p++;
        const m = new Uint8Array(d + (f - p));
        let x = d;
        for(; p !== f;)m[x++] = g[p++];
        return m;
    }
    function u(c) {
        const l = a(c);
        if (l) return l;
        throw new Error("Non-base" + t + " character");
    }
    return {
        encode: o,
        decodeUnsafe: a,
        decode: u
    };
}
var RA = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const vo = UA(RA);
function $A(r) {
    const e = r.length;
    let t = 0, n = 0;
    for(; n < e;){
        let s = r.charCodeAt(n++);
        if (s & 4294967168) if (!(s & 4294965248)) t += 2;
        else {
            if (s >= 55296 && s <= 56319 && n < e) {
                const i = r.charCodeAt(n);
                (i & 64512) === 56320 && (++n, s = ((s & 1023) << 10) + (i & 1023) + 65536);
            }
            s & 4294901760 ? t += 4 : t += 3;
        }
        else {
            t++;
            continue;
        }
    }
    return t;
}
function BA(r, e, t) {
    const n = r.length;
    let s = t, i = 0;
    for(; i < n;){
        let o = r.charCodeAt(i++);
        if (o & 4294967168) if (!(o & 4294965248)) e[s++] = o >> 6 & 31 | 192;
        else {
            if (o >= 55296 && o <= 56319 && i < n) {
                const a = r.charCodeAt(i);
                (a & 64512) === 56320 && (++i, o = ((o & 1023) << 10) + (a & 1023) + 65536);
            }
            o & 4294901760 ? (e[s++] = o >> 18 & 7 | 240, e[s++] = o >> 12 & 63 | 128, e[s++] = o >> 6 & 63 | 128) : (e[s++] = o >> 12 & 15 | 224, e[s++] = o >> 6 & 63 | 128);
        }
        else {
            e[s++] = o;
            continue;
        }
        e[s++] = o & 63 | 128;
    }
}
const FA = new TextEncoder(), qA = 50;
function QA(r, e, t) {
    FA.encodeInto(r, e.subarray(t));
}
function VA(r, e, t) {
    r.length > qA ? QA(r, e, t) : BA(r, e, t);
}
const YA = 4096;
function Zw(r, e, t) {
    let n = e;
    const s = n + t, i = [];
    let o = "";
    for(; n < s;){
        const a = r[n++];
        if (!(a & 128)) i.push(a);
        else if ((a & 224) === 192) {
            const u = r[n++] & 63;
            i.push((a & 31) << 6 | u);
        } else if ((a & 240) === 224) {
            const u = r[n++] & 63, c = r[n++] & 63;
            i.push((a & 31) << 12 | u << 6 | c);
        } else if ((a & 248) === 240) {
            const u = r[n++] & 63, c = r[n++] & 63, l = r[n++] & 63;
            let d = (a & 7) << 18 | u << 12 | c << 6 | l;
            d > 65535 && (d -= 65536, i.push(d >>> 10 & 1023 | 55296), d = 56320 | d & 1023), i.push(d);
        } else i.push(a);
        i.length >= YA && (o += String.fromCharCode(...i), i.length = 0);
    }
    return i.length > 0 && (o += String.fromCharCode(...i)), o;
}
const GA = new TextDecoder(), HA = 200;
function WA(r, e, t) {
    const n = r.subarray(e, e + t);
    return GA.decode(n);
}
function KA(r, e, t) {
    return t > HA ? WA(r, e, t) : Zw(r, e, t);
}
class Ho {
    constructor(e, t){
        this.type = e, this.data = t;
    }
}
class or extends Error {
    constructor(e){
        super(e);
        const t = Object.create(or.prototype);
        Object.setPrototypeOf(this, t), Object.defineProperty(this, "name", {
            configurable: !0,
            enumerable: !1,
            value: or.name
        });
    }
}
const Ls = 4294967295;
function XA(r, e, t) {
    const n = t / 4294967296, s = t;
    r.setUint32(e, n), r.setUint32(e + 4, s);
}
function Jw(r, e, t) {
    const n = Math.floor(t / 4294967296), s = t;
    r.setUint32(e, n), r.setUint32(e + 4, s);
}
function em(r, e) {
    const t = r.getInt32(e), n = r.getUint32(e + 4);
    return t * 4294967296 + n;
}
function ZA(r, e) {
    const t = r.getUint32(e), n = r.getUint32(e + 4);
    return t * 4294967296 + n;
}
const JA = -1, eS = 4294967296 - 1, tS = 17179869184 - 1;
function rS({ sec: r, nsec: e }) {
    if (r >= 0 && e >= 0 && r <= tS) if (e === 0 && r <= eS) {
        const t = new Uint8Array(4);
        return new DataView(t.buffer).setUint32(0, r), t;
    } else {
        const t = r / 4294967296, n = r & 4294967295, s = new Uint8Array(8), i = new DataView(s.buffer);
        return i.setUint32(0, e << 2 | t & 3), i.setUint32(4, n), s;
    }
    else {
        const t = new Uint8Array(12), n = new DataView(t.buffer);
        return n.setUint32(0, e), Jw(n, 4, r), t;
    }
}
function nS(r) {
    const e = r.getTime(), t = Math.floor(e / 1e3), n = (e - t * 1e3) * 1e6, s = Math.floor(n / 1e9);
    return {
        sec: t + s,
        nsec: n - s * 1e9
    };
}
function iS(r) {
    if (r instanceof Date) {
        const e = nS(r);
        return rS(e);
    } else return null;
}
function sS(r) {
    const e = new DataView(r.buffer, r.byteOffset, r.byteLength);
    switch(r.byteLength){
        case 4:
            return {
                sec: e.getUint32(0),
                nsec: 0
            };
        case 8:
            {
                const t = e.getUint32(0), n = e.getUint32(4), s = (t & 3) * 4294967296 + n, i = t >>> 2;
                return {
                    sec: s,
                    nsec: i
                };
            }
        case 12:
            {
                const t = em(e, 4), n = e.getUint32(0);
                return {
                    sec: t,
                    nsec: n
                };
            }
        default:
            throw new or(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${r.length}`);
    }
}
function oS(r) {
    const e = sS(r);
    return new Date(e.sec * 1e3 + e.nsec / 1e6);
}
const aS = {
    type: JA,
    encode: iS,
    decode: oS
};
class Ua {
    constructor(){
        this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(aS);
    }
    register({ type: e, encode: t, decode: n }) {
        if (e >= 0) this.encoders[e] = t, this.decoders[e] = n;
        else {
            const s = -1 - e;
            this.builtInEncoders[s] = t, this.builtInDecoders[s] = n;
        }
    }
    tryToEncode(e, t) {
        for(let n = 0; n < this.builtInEncoders.length; n++){
            const s = this.builtInEncoders[n];
            if (s != null) {
                const i = s(e, t);
                if (i != null) {
                    const o = -1 - n;
                    return new Ho(o, i);
                }
            }
        }
        for(let n = 0; n < this.encoders.length; n++){
            const s = this.encoders[n];
            if (s != null) {
                const i = s(e, t);
                if (i != null) {
                    const o = n;
                    return new Ho(o, i);
                }
            }
        }
        return e instanceof Ho ? e : null;
    }
    decode(e, t, n) {
        const s = t < 0 ? this.builtInDecoders[-1 - t] : this.decoders[t];
        return s ? s(e, t, n) : new Ho(t, e);
    }
}
Ua.defaultCodec = new Ua();
function cS(r) {
    return r instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && r instanceof SharedArrayBuffer;
}
function kl(r) {
    return r instanceof Uint8Array ? r : ArrayBuffer.isView(r) ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : cS(r) ? new Uint8Array(r) : Uint8Array.from(r);
}
const uS = 100, lS = 2048;
let dS = class tm {
    constructor(e){
        this.entered = !1, this.extensionCodec = (e == null ? void 0 : e.extensionCodec) ?? Ua.defaultCodec, this.context = e == null ? void 0 : e.context, this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ?? !1, this.maxDepth = (e == null ? void 0 : e.maxDepth) ?? uS, this.initialBufferSize = (e == null ? void 0 : e.initialBufferSize) ?? lS, this.sortKeys = (e == null ? void 0 : e.sortKeys) ?? !1, this.forceFloat32 = (e == null ? void 0 : e.forceFloat32) ?? !1, this.ignoreUndefined = (e == null ? void 0 : e.ignoreUndefined) ?? !1, this.forceIntegerToFloat = (e == null ? void 0 : e.forceIntegerToFloat) ?? !1, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
    }
    clone() {
        return new tm({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            maxDepth: this.maxDepth,
            initialBufferSize: this.initialBufferSize,
            sortKeys: this.sortKeys,
            forceFloat32: this.forceFloat32,
            ignoreUndefined: this.ignoreUndefined,
            forceIntegerToFloat: this.forceIntegerToFloat
        });
    }
    reinitializeState() {
        this.pos = 0;
    }
    /**
   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
   *
   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
   */ encodeSharedRef(e) {
        if (this.entered) return this.clone().encodeSharedRef(e);
        try {
            return this.entered = !0, this.reinitializeState(), this.doEncode(e, 1), this.bytes.subarray(0, this.pos);
        } finally{
            this.entered = !1;
        }
    }
    /**
   * @returns Encodes the object and returns a copy of the encoder's internal buffer.
   */ encode(e) {
        if (this.entered) return this.clone().encode(e);
        try {
            return this.entered = !0, this.reinitializeState(), this.doEncode(e, 1), this.bytes.slice(0, this.pos);
        } finally{
            this.entered = !1;
        }
    }
    doEncode(e, t) {
        if (t > this.maxDepth) throw new Error(`Too deep objects in depth ${t}`);
        e == null ? this.encodeNil() : typeof e == "boolean" ? this.encodeBoolean(e) : typeof e == "number" ? this.forceIntegerToFloat ? this.encodeNumberAsFloat(e) : this.encodeNumber(e) : typeof e == "string" ? this.encodeString(e) : this.useBigInt64 && typeof e == "bigint" ? this.encodeBigInt64(e) : this.encodeObject(e, t);
    }
    ensureBufferSizeToWrite(e) {
        const t = this.pos + e;
        this.view.byteLength < t && this.resizeBuffer(t * 2);
    }
    resizeBuffer(e) {
        const t = new ArrayBuffer(e), n = new Uint8Array(t), s = new DataView(t);
        n.set(this.bytes), this.view = s, this.bytes = n;
    }
    encodeNil() {
        this.writeU8(192);
    }
    encodeBoolean(e) {
        e === !1 ? this.writeU8(194) : this.writeU8(195);
    }
    encodeNumber(e) {
        !this.forceIntegerToFloat && Number.isSafeInteger(e) ? e >= 0 ? e < 128 ? this.writeU8(e) : e < 256 ? (this.writeU8(204), this.writeU8(e)) : e < 65536 ? (this.writeU8(205), this.writeU16(e)) : e < 4294967296 ? (this.writeU8(206), this.writeU32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(207), this.writeU64(e)) : e >= -32 ? this.writeU8(224 | e + 32) : e >= -128 ? (this.writeU8(208), this.writeI8(e)) : e >= -32768 ? (this.writeU8(209), this.writeI16(e)) : e >= -2147483648 ? (this.writeU8(210), this.writeI32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(211), this.writeI64(e)) : this.encodeNumberAsFloat(e);
    }
    encodeNumberAsFloat(e) {
        this.forceFloat32 ? (this.writeU8(202), this.writeF32(e)) : (this.writeU8(203), this.writeF64(e));
    }
    encodeBigInt64(e) {
        e >= BigInt(0) ? (this.writeU8(207), this.writeBigUint64(e)) : (this.writeU8(211), this.writeBigInt64(e));
    }
    writeStringHeader(e) {
        if (e < 32) this.writeU8(160 + e);
        else if (e < 256) this.writeU8(217), this.writeU8(e);
        else if (e < 65536) this.writeU8(218), this.writeU16(e);
        else if (e < 4294967296) this.writeU8(219), this.writeU32(e);
        else throw new Error(`Too long string: ${e} bytes in UTF-8`);
    }
    encodeString(e) {
        const n = $A(e);
        this.ensureBufferSizeToWrite(5 + n), this.writeStringHeader(n), VA(e, this.bytes, this.pos), this.pos += n;
    }
    encodeObject(e, t) {
        const n = this.extensionCodec.tryToEncode(e, this.context);
        if (n != null) this.encodeExtension(n);
        else if (Array.isArray(e)) this.encodeArray(e, t);
        else if (ArrayBuffer.isView(e)) this.encodeBinary(e);
        else if (typeof e == "object") this.encodeMap(e, t);
        else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(e)}`);
    }
    encodeBinary(e) {
        const t = e.byteLength;
        if (t < 256) this.writeU8(196), this.writeU8(t);
        else if (t < 65536) this.writeU8(197), this.writeU16(t);
        else if (t < 4294967296) this.writeU8(198), this.writeU32(t);
        else throw new Error(`Too large binary: ${t}`);
        const n = kl(e);
        this.writeU8a(n);
    }
    encodeArray(e, t) {
        const n = e.length;
        if (n < 16) this.writeU8(144 + n);
        else if (n < 65536) this.writeU8(220), this.writeU16(n);
        else if (n < 4294967296) this.writeU8(221), this.writeU32(n);
        else throw new Error(`Too large array: ${n}`);
        for (const s of e)this.doEncode(s, t + 1);
    }
    countWithoutUndefined(e, t) {
        let n = 0;
        for (const s of t)e[s] !== void 0 && n++;
        return n;
    }
    encodeMap(e, t) {
        const n = Object.keys(e);
        this.sortKeys && n.sort();
        const s = this.ignoreUndefined ? this.countWithoutUndefined(e, n) : n.length;
        if (s < 16) this.writeU8(128 + s);
        else if (s < 65536) this.writeU8(222), this.writeU16(s);
        else if (s < 4294967296) this.writeU8(223), this.writeU32(s);
        else throw new Error(`Too large map object: ${s}`);
        for (const i of n){
            const o = e[i];
            this.ignoreUndefined && o === void 0 || (this.encodeString(i), this.doEncode(o, t + 1));
        }
    }
    encodeExtension(e) {
        if (typeof e.data == "function") {
            const n = e.data(this.pos + 6), s = n.length;
            if (s >= 4294967296) throw new Error(`Too large extension object: ${s}`);
            this.writeU8(201), this.writeU32(s), this.writeI8(e.type), this.writeU8a(n);
            return;
        }
        const t = e.data.length;
        if (t === 1) this.writeU8(212);
        else if (t === 2) this.writeU8(213);
        else if (t === 4) this.writeU8(214);
        else if (t === 8) this.writeU8(215);
        else if (t === 16) this.writeU8(216);
        else if (t < 256) this.writeU8(199), this.writeU8(t);
        else if (t < 65536) this.writeU8(200), this.writeU16(t);
        else if (t < 4294967296) this.writeU8(201), this.writeU32(t);
        else throw new Error(`Too large extension object: ${t}`);
        this.writeI8(e.type), this.writeU8a(e.data);
    }
    writeU8(e) {
        this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, e), this.pos++;
    }
    writeU8a(e) {
        const t = e.length;
        this.ensureBufferSizeToWrite(t), this.bytes.set(e, this.pos), this.pos += t;
    }
    writeI8(e) {
        this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, e), this.pos++;
    }
    writeU16(e) {
        this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, e), this.pos += 2;
    }
    writeI16(e) {
        this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, e), this.pos += 2;
    }
    writeU32(e) {
        this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, e), this.pos += 4;
    }
    writeI32(e) {
        this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, e), this.pos += 4;
    }
    writeF32(e) {
        this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, e), this.pos += 4;
    }
    writeF64(e) {
        this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, e), this.pos += 8;
    }
    writeU64(e) {
        this.ensureBufferSizeToWrite(8), XA(this.view, this.pos, e), this.pos += 8;
    }
    writeI64(e) {
        this.ensureBufferSizeToWrite(8), Jw(this.view, this.pos, e), this.pos += 8;
    }
    writeBigUint64(e) {
        this.ensureBufferSizeToWrite(8), this.view.setBigUint64(this.pos, e), this.pos += 8;
    }
    writeBigInt64(e) {
        this.ensureBufferSizeToWrite(8), this.view.setBigInt64(this.pos, e), this.pos += 8;
    }
};
function hS(r, e) {
    return new dS(e).encodeSharedRef(r);
}
function Uu(r) {
    return `${r < 0 ? "-" : ""}0x${Math.abs(r).toString(16).padStart(2, "0")}`;
}
const fS = 16, pS = 16;
class gS {
    constructor(e = fS, t = pS){
        this.hit = 0, this.miss = 0, this.maxKeyLength = e, this.maxLengthPerKey = t, this.caches = [];
        for(let n = 0; n < this.maxKeyLength; n++)this.caches.push([]);
    }
    canBeCached(e) {
        return e > 0 && e <= this.maxKeyLength;
    }
    find(e, t, n) {
        const s = this.caches[n - 1];
        e: for (const i of s){
            const o = i.bytes;
            for(let a = 0; a < n; a++)if (o[a] !== e[t + a]) continue e;
            return i.str;
        }
        return null;
    }
    store(e, t) {
        const n = this.caches[e.length - 1], s = {
            bytes: e,
            str: t
        };
        n.length >= this.maxLengthPerKey ? n[Math.random() * n.length | 0] = s : n.push(s);
    }
    decode(e, t, n) {
        const s = this.find(e, t, n);
        if (s != null) return this.hit++, s;
        this.miss++;
        const i = Zw(e, t, n), o = Uint8Array.prototype.slice.call(e, t, t + n);
        return this.store(o, i), i;
    }
}
const zl = "array", Zs = "map_key", rm = "map_value", yS = (r)=>{
    if (typeof r == "string" || typeof r == "number") return r;
    throw new or("The type of key must be string or number but " + typeof r);
};
class wS {
    constructor(){
        this.stack = [], this.stackHeadPosition = -1;
    }
    get length() {
        return this.stackHeadPosition + 1;
    }
    top() {
        return this.stack[this.stackHeadPosition];
    }
    pushArrayState(e) {
        const t = this.getUninitializedStateFromPool();
        t.type = zl, t.position = 0, t.size = e, t.array = new Array(e);
    }
    pushMapState(e) {
        const t = this.getUninitializedStateFromPool();
        t.type = Zs, t.readCount = 0, t.size = e, t.map = {};
    }
    getUninitializedStateFromPool() {
        if (this.stackHeadPosition++, this.stackHeadPosition === this.stack.length) {
            const e = {
                type: void 0,
                size: 0,
                array: void 0,
                position: 0,
                readCount: 0,
                map: void 0,
                key: null
            };
            this.stack.push(e);
        }
        return this.stack[this.stackHeadPosition];
    }
    release(e) {
        if (this.stack[this.stackHeadPosition] !== e) throw new Error("Invalid stack state. Released state is not on top of the stack.");
        if (e.type === zl) {
            const n = e;
            n.size = 0, n.array = void 0, n.position = 0, n.type = void 0;
        }
        if (e.type === Zs || e.type === rm) {
            const n = e;
            n.size = 0, n.map = void 0, n.readCount = 0, n.type = void 0;
        }
        this.stackHeadPosition--;
    }
    reset() {
        this.stack.length = 0, this.stackHeadPosition = -1;
    }
}
const ks = -1, Hd = new DataView(new ArrayBuffer(0)), mS = new Uint8Array(Hd.buffer);
try {
    Hd.getInt8(0);
} catch (r) {
    if (!(r instanceof RangeError)) throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
}
const mp = new RangeError("Insufficient data"), bS = new gS();
let vS = class nm {
    constructor(e){
        this.totalPos = 0, this.pos = 0, this.view = Hd, this.bytes = mS, this.headByte = ks, this.stack = new wS(), this.entered = !1, this.extensionCodec = (e == null ? void 0 : e.extensionCodec) ?? Ua.defaultCodec, this.context = e == null ? void 0 : e.context, this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ?? !1, this.rawStrings = (e == null ? void 0 : e.rawStrings) ?? !1, this.maxStrLength = (e == null ? void 0 : e.maxStrLength) ?? Ls, this.maxBinLength = (e == null ? void 0 : e.maxBinLength) ?? Ls, this.maxArrayLength = (e == null ? void 0 : e.maxArrayLength) ?? Ls, this.maxMapLength = (e == null ? void 0 : e.maxMapLength) ?? Ls, this.maxExtLength = (e == null ? void 0 : e.maxExtLength) ?? Ls, this.keyDecoder = (e == null ? void 0 : e.keyDecoder) !== void 0 ? e.keyDecoder : bS, this.mapKeyConverter = (e == null ? void 0 : e.mapKeyConverter) ?? yS;
    }
    clone() {
        return new nm({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            rawStrings: this.rawStrings,
            maxStrLength: this.maxStrLength,
            maxBinLength: this.maxBinLength,
            maxArrayLength: this.maxArrayLength,
            maxMapLength: this.maxMapLength,
            maxExtLength: this.maxExtLength,
            keyDecoder: this.keyDecoder
        });
    }
    reinitializeState() {
        this.totalPos = 0, this.headByte = ks, this.stack.reset();
    }
    setBuffer(e) {
        const t = kl(e);
        this.bytes = t, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength), this.pos = 0;
    }
    appendBuffer(e) {
        if (this.headByte === ks && !this.hasRemaining(1)) this.setBuffer(e);
        else {
            const t = this.bytes.subarray(this.pos), n = kl(e), s = new Uint8Array(t.length + n.length);
            s.set(t), s.set(n, t.length), this.setBuffer(s);
        }
    }
    hasRemaining(e) {
        return this.view.byteLength - this.pos >= e;
    }
    createExtraByteError(e) {
        const { view: t, pos: n } = this;
        return new RangeError(`Extra ${t.byteLength - n} of ${t.byteLength} byte(s) found at buffer[${e}]`);
    }
    /**
   * @throws {@link DecodeError}
   * @throws {@link RangeError}
   */ decode(e) {
        if (this.entered) return this.clone().decode(e);
        try {
            this.entered = !0, this.reinitializeState(), this.setBuffer(e);
            const t = this.doDecodeSync();
            if (this.hasRemaining(1)) throw this.createExtraByteError(this.pos);
            return t;
        } finally{
            this.entered = !1;
        }
    }
    *decodeMulti(e) {
        if (this.entered) {
            yield* this.clone().decodeMulti(e);
            return;
        }
        try {
            for(this.entered = !0, this.reinitializeState(), this.setBuffer(e); this.hasRemaining(1);)yield this.doDecodeSync();
        } finally{
            this.entered = !1;
        }
    }
    async decodeAsync(e) {
        if (this.entered) return this.clone().decodeAsync(e);
        try {
            this.entered = !0;
            let t = !1, n;
            for await (const a of e){
                if (t) throw this.entered = !1, this.createExtraByteError(this.totalPos);
                this.appendBuffer(a);
                try {
                    n = this.doDecodeSync(), t = !0;
                } catch (u) {
                    if (!(u instanceof RangeError)) throw u;
                }
                this.totalPos += this.pos;
            }
            if (t) {
                if (this.hasRemaining(1)) throw this.createExtraByteError(this.totalPos);
                return n;
            }
            const { headByte: s, pos: i, totalPos: o } = this;
            throw new RangeError(`Insufficient data in parsing ${Uu(s)} at ${o} (${i} in the current buffer)`);
        } finally{
            this.entered = !1;
        }
    }
    decodeArrayStream(e) {
        return this.decodeMultiAsync(e, !0);
    }
    decodeStream(e) {
        return this.decodeMultiAsync(e, !1);
    }
    async *decodeMultiAsync(e, t) {
        if (this.entered) {
            yield* this.clone().decodeMultiAsync(e, t);
            return;
        }
        try {
            this.entered = !0;
            let n = t, s = -1;
            for await (const i of e){
                if (t && s === 0) throw this.createExtraByteError(this.totalPos);
                this.appendBuffer(i), n && (s = this.readArraySize(), n = !1, this.complete());
                try {
                    for(; yield this.doDecodeSync(), --s !== 0;);
                } catch (o) {
                    if (!(o instanceof RangeError)) throw o;
                }
                this.totalPos += this.pos;
            }
        } finally{
            this.entered = !1;
        }
    }
    doDecodeSync() {
        e: for(;;){
            const e = this.readHeadByte();
            let t;
            if (e >= 224) t = e - 256;
            else if (e < 192) if (e < 128) t = e;
            else if (e < 144) {
                const s = e - 128;
                if (s !== 0) {
                    this.pushMapState(s), this.complete();
                    continue e;
                } else t = {};
            } else if (e < 160) {
                const s = e - 144;
                if (s !== 0) {
                    this.pushArrayState(s), this.complete();
                    continue e;
                } else t = [];
            } else {
                const s = e - 160;
                t = this.decodeString(s, 0);
            }
            else if (e === 192) t = null;
            else if (e === 194) t = !1;
            else if (e === 195) t = !0;
            else if (e === 202) t = this.readF32();
            else if (e === 203) t = this.readF64();
            else if (e === 204) t = this.readU8();
            else if (e === 205) t = this.readU16();
            else if (e === 206) t = this.readU32();
            else if (e === 207) this.useBigInt64 ? t = this.readU64AsBigInt() : t = this.readU64();
            else if (e === 208) t = this.readI8();
            else if (e === 209) t = this.readI16();
            else if (e === 210) t = this.readI32();
            else if (e === 211) this.useBigInt64 ? t = this.readI64AsBigInt() : t = this.readI64();
            else if (e === 217) {
                const s = this.lookU8();
                t = this.decodeString(s, 1);
            } else if (e === 218) {
                const s = this.lookU16();
                t = this.decodeString(s, 2);
            } else if (e === 219) {
                const s = this.lookU32();
                t = this.decodeString(s, 4);
            } else if (e === 220) {
                const s = this.readU16();
                if (s !== 0) {
                    this.pushArrayState(s), this.complete();
                    continue e;
                } else t = [];
            } else if (e === 221) {
                const s = this.readU32();
                if (s !== 0) {
                    this.pushArrayState(s), this.complete();
                    continue e;
                } else t = [];
            } else if (e === 222) {
                const s = this.readU16();
                if (s !== 0) {
                    this.pushMapState(s), this.complete();
                    continue e;
                } else t = {};
            } else if (e === 223) {
                const s = this.readU32();
                if (s !== 0) {
                    this.pushMapState(s), this.complete();
                    continue e;
                } else t = {};
            } else if (e === 196) {
                const s = this.lookU8();
                t = this.decodeBinary(s, 1);
            } else if (e === 197) {
                const s = this.lookU16();
                t = this.decodeBinary(s, 2);
            } else if (e === 198) {
                const s = this.lookU32();
                t = this.decodeBinary(s, 4);
            } else if (e === 212) t = this.decodeExtension(1, 0);
            else if (e === 213) t = this.decodeExtension(2, 0);
            else if (e === 214) t = this.decodeExtension(4, 0);
            else if (e === 215) t = this.decodeExtension(8, 0);
            else if (e === 216) t = this.decodeExtension(16, 0);
            else if (e === 199) {
                const s = this.lookU8();
                t = this.decodeExtension(s, 1);
            } else if (e === 200) {
                const s = this.lookU16();
                t = this.decodeExtension(s, 2);
            } else if (e === 201) {
                const s = this.lookU32();
                t = this.decodeExtension(s, 4);
            } else throw new or(`Unrecognized type byte: ${Uu(e)}`);
            this.complete();
            const n = this.stack;
            for(; n.length > 0;){
                const s = n.top();
                if (s.type === zl) if (s.array[s.position] = t, s.position++, s.position === s.size) t = s.array, n.release(s);
                else continue e;
                else if (s.type === Zs) {
                    if (t === "__proto__") throw new or("The key __proto__ is not allowed");
                    s.key = this.mapKeyConverter(t), s.type = rm;
                    continue e;
                } else if (s.map[s.key] = t, s.readCount++, s.readCount === s.size) t = s.map, n.release(s);
                else {
                    s.key = null, s.type = Zs;
                    continue e;
                }
            }
            return t;
        }
    }
    readHeadByte() {
        return this.headByte === ks && (this.headByte = this.readU8()), this.headByte;
    }
    complete() {
        this.headByte = ks;
    }
    readArraySize() {
        const e = this.readHeadByte();
        switch(e){
            case 220:
                return this.readU16();
            case 221:
                return this.readU32();
            default:
                {
                    if (e < 160) return e - 144;
                    throw new or(`Unrecognized array type byte: ${Uu(e)}`);
                }
        }
    }
    pushMapState(e) {
        if (e > this.maxMapLength) throw new or(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);
        this.stack.pushMapState(e);
    }
    pushArrayState(e) {
        if (e > this.maxArrayLength) throw new or(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);
        this.stack.pushArrayState(e);
    }
    decodeString(e, t) {
        return !this.rawStrings || this.stateIsMapKey() ? this.decodeUtf8String(e, t) : this.decodeBinary(e, t);
    }
    /**
   * @throws {@link RangeError}
   */ decodeUtf8String(e, t) {
        var i;
        if (e > this.maxStrLength) throw new or(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);
        if (this.bytes.byteLength < this.pos + t + e) throw mp;
        const n = this.pos + t;
        let s;
        return this.stateIsMapKey() && (i = this.keyDecoder) != null && i.canBeCached(e) ? s = this.keyDecoder.decode(this.bytes, n, e) : s = KA(this.bytes, n, e), this.pos += t + e, s;
    }
    stateIsMapKey() {
        return this.stack.length > 0 ? this.stack.top().type === Zs : !1;
    }
    /**
   * @throws {@link RangeError}
   */ decodeBinary(e, t) {
        if (e > this.maxBinLength) throw new or(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);
        if (!this.hasRemaining(e + t)) throw mp;
        const n = this.pos + t, s = this.bytes.subarray(n, n + e);
        return this.pos += t + e, s;
    }
    decodeExtension(e, t) {
        if (e > this.maxExtLength) throw new or(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);
        const n = this.view.getInt8(this.pos + t), s = this.decodeBinary(e, t + 1);
        return this.extensionCodec.decode(s, n, this.context);
    }
    lookU8() {
        return this.view.getUint8(this.pos);
    }
    lookU16() {
        return this.view.getUint16(this.pos);
    }
    lookU32() {
        return this.view.getUint32(this.pos);
    }
    readU8() {
        const e = this.view.getUint8(this.pos);
        return this.pos++, e;
    }
    readI8() {
        const e = this.view.getInt8(this.pos);
        return this.pos++, e;
    }
    readU16() {
        const e = this.view.getUint16(this.pos);
        return this.pos += 2, e;
    }
    readI16() {
        const e = this.view.getInt16(this.pos);
        return this.pos += 2, e;
    }
    readU32() {
        const e = this.view.getUint32(this.pos);
        return this.pos += 4, e;
    }
    readI32() {
        const e = this.view.getInt32(this.pos);
        return this.pos += 4, e;
    }
    readU64() {
        const e = ZA(this.view, this.pos);
        return this.pos += 8, e;
    }
    readI64() {
        const e = em(this.view, this.pos);
        return this.pos += 8, e;
    }
    readU64AsBigInt() {
        const e = this.view.getBigUint64(this.pos);
        return this.pos += 8, e;
    }
    readI64AsBigInt() {
        const e = this.view.getBigInt64(this.pos);
        return this.pos += 8, e;
    }
    readF32() {
        const e = this.view.getFloat32(this.pos);
        return this.pos += 4, e;
    }
    readF64() {
        const e = this.view.getFloat64(this.pos);
        return this.pos += 8, e;
    }
};
function ES(r, e) {
    return new vS(e).decode(r);
}
function Wd(r) {
    return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function im(r = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Wd(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function Js(r, e) {
    e || (e = r.reduce((s, i)=>s + i.length, 0));
    const t = im(e);
    let n = 0;
    for (const s of r)t.set(s, n), n += s.length;
    return Wd(t);
}
function MS(r, e) {
    if (r.length >= 255) throw new TypeError("Alphabet too long");
    for(var t = new Uint8Array(256), n = 0; n < t.length; n++)t[n] = 255;
    for(var s = 0; s < r.length; s++){
        var i = r.charAt(s), o = i.charCodeAt(0);
        if (t[o] !== 255) throw new TypeError(i + " is ambiguous");
        t[o] = s;
    }
    var a = r.length, u = r.charAt(0), c = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
    function d(g) {
        if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (g.length === 0) return "";
        for(var p = 0, m = 0, x = 0, _ = g.length; x !== _ && g[x] === 0;)x++, p++;
        for(var v = (_ - x) * l + 1 >>> 0, N = new Uint8Array(v); x !== _;){
            for(var O = g[x], z = 0, P = v - 1; (O !== 0 || z < m) && P !== -1; P--, z++)O += 256 * N[P] >>> 0, N[P] = O % a >>> 0, O = O / a >>> 0;
            if (O !== 0) throw new Error("Non-zero carry");
            m = z, x++;
        }
        for(var U = v - m; U !== v && N[U] === 0;)U++;
        for(var R = u.repeat(p); U < v; ++U)R += r.charAt(N[U]);
        return R;
    }
    function h(g) {
        if (typeof g != "string") throw new TypeError("Expected String");
        if (g.length === 0) return new Uint8Array();
        var p = 0;
        if (g[p] !== " ") {
            for(var m = 0, x = 0; g[p] === u;)m++, p++;
            for(var _ = (g.length - p) * c + 1 >>> 0, v = new Uint8Array(_); g[p];){
                var N = t[g.charCodeAt(p)];
                if (N === 255) return;
                for(var O = 0, z = _ - 1; (N !== 0 || O < x) && z !== -1; z--, O++)N += a * v[z] >>> 0, v[z] = N % 256 >>> 0, N = N / 256 >>> 0;
                if (N !== 0) throw new Error("Non-zero carry");
                x = O, p++;
            }
            if (g[p] !== " ") {
                for(var P = _ - x; P !== _ && v[P] === 0;)P++;
                for(var U = new Uint8Array(m + (_ - P)), R = m; P !== _;)U[R++] = v[P++];
                return U;
            }
        }
    }
    function f(g) {
        var p = h(g);
        if (p) return p;
        throw new Error(`Non-${e} character`);
    }
    return {
        encode: d,
        decodeUnsafe: h,
        decode: f
    };
}
var NS = MS, xS = NS;
const IS = (r)=>{
    if (r instanceof Uint8Array && r.constructor.name === "Uint8Array") return r;
    if (r instanceof ArrayBuffer) return new Uint8Array(r);
    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
    throw new Error("Unknown type, must be binary type");
}, TS = (r)=>new TextEncoder().encode(r), DS = (r)=>new TextDecoder().decode(r);
class _S {
    constructor(e, t, n){
        this.name = e, this.prefix = t, this.baseEncode = n;
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type");
    }
}
class AS {
    constructor(e, t, n){
        if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
    }
    or(e) {
        return sm(this, e);
    }
}
class SS {
    constructor(e){
        this.decoders = e;
    }
    or(e) {
        return sm(this, e);
    }
    decode(e) {
        const t = e[0], n = this.decoders[t];
        if (n) return n.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
}
const sm = (r, e)=>new SS({
        ...r.decoders || {
            [r.prefix]: r
        },
        ...e.decoders || {
            [e.prefix]: e
        }
    });
class OS {
    constructor(e, t, n, s){
        this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new _S(e, t, n), this.decoder = new AS(e, t, s);
    }
    encode(e) {
        return this.encoder.encode(e);
    }
    decode(e) {
        return this.decoder.decode(e);
    }
}
const Uc = ({ name: r, prefix: e, encode: t, decode: n })=>new OS(r, e, t, n), Eo = ({ prefix: r, name: e, alphabet: t })=>{
    const { encode: n, decode: s } = xS(t, e);
    return Uc({
        prefix: r,
        name: e,
        encode: n,
        decode: (i)=>IS(s(i))
    });
}, jS = (r, e, t, n)=>{
    const s = {};
    for(let l = 0; l < e.length; ++l)s[e[l]] = l;
    let i = r.length;
    for(; r[i - 1] === "=";)--i;
    const o = new Uint8Array(i * t / 8 | 0);
    let a = 0, u = 0, c = 0;
    for(let l = 0; l < i; ++l){
        const d = s[r[l]];
        if (d === void 0) throw new SyntaxError(`Non-${n} character`);
        u = u << t | d, a += t, a >= 8 && (a -= 8, o[c++] = 255 & u >> a);
    }
    if (a >= t || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
    return o;
}, CS = (r, e, t)=>{
    const n = e[e.length - 1] === "=", s = (1 << t) - 1;
    let i = "", o = 0, a = 0;
    for(let u = 0; u < r.length; ++u)for(a = a << 8 | r[u], o += 8; o > t;)o -= t, i += e[s & a >> o];
    if (o && (i += e[s & a << t - o]), n) for(; i.length * t & 7;)i += "=";
    return i;
}, _t = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n })=>Uc({
        prefix: e,
        name: r,
        encode (s) {
            return CS(s, n, t);
        },
        decode (s) {
            return jS(s, n, t, r);
        }
    }), LS = Uc({
    prefix: "\0",
    name: "identity",
    encode: (r)=>DS(r),
    decode: (r)=>TS(r)
}), kS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    identity: LS
}, Symbol.toStringTag, {
    value: "Module"
})), zS = _t({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
}), PS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base2: zS
}, Symbol.toStringTag, {
    value: "Module"
})), US = _t({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
}), RS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base8: US
}, Symbol.toStringTag, {
    value: "Module"
})), $S = Eo({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
}), BS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base10: $S
}, Symbol.toStringTag, {
    value: "Module"
})), FS = _t({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
}), qS = _t({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
}), QS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base16: FS,
    base16upper: qS
}, Symbol.toStringTag, {
    value: "Module"
})), VS = _t({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
}), YS = _t({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
}), GS = _t({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
}), HS = _t({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
}), WS = _t({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
}), KS = _t({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
}), XS = _t({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
}), ZS = _t({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
}), JS = _t({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
}), eO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base32: VS,
    base32hex: WS,
    base32hexpad: XS,
    base32hexpadupper: ZS,
    base32hexupper: KS,
    base32pad: GS,
    base32padupper: HS,
    base32upper: YS,
    base32z: JS
}, Symbol.toStringTag, {
    value: "Module"
})), tO = Eo({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), rO = Eo({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), nO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base36: tO,
    base36upper: rO
}, Symbol.toStringTag, {
    value: "Module"
})), iO = Eo({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), sO = Eo({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), oO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base58btc: iO,
    base58flickr: sO
}, Symbol.toStringTag, {
    value: "Module"
})), aO = _t({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
}), cO = _t({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
}), uO = _t({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
}), lO = _t({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
}), dO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base64: aO,
    base64pad: cO,
    base64url: uO,
    base64urlpad: lO
}, Symbol.toStringTag, {
    value: "Module"
})), om = Array.from(""), hO = om.reduce((r, e, t)=>(r[t] = e, r), []), fO = om.reduce((r, e, t)=>(r[e.codePointAt(0)] = t, r), []);
function pO(r) {
    return r.reduce((e, t)=>(e += hO[t], e), "");
}
function gO(r) {
    const e = [];
    for (const t of r){
        const n = fO[t.codePointAt(0)];
        if (n === void 0) throw new Error(`Non-base256emoji character: ${t}`);
        e.push(n);
    }
    return new Uint8Array(e);
}
const yO = Uc({
    prefix: "",
    name: "base256emoji",
    encode: pO,
    decode: gO
}), wO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base256emoji: yO
}, Symbol.toStringTag, {
    value: "Module"
}));
new TextEncoder();
new TextDecoder();
const bp = {
    ...kS,
    ...PS,
    ...RS,
    ...BS,
    ...QS,
    ...eO,
    ...nO,
    ...oO,
    ...dO,
    ...wO
};
function am(r, e, t, n) {
    return {
        name: r,
        prefix: e,
        encoder: {
            name: r,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: n
        }
    };
}
const vp = am("utf8", "u", (r)=>"u" + new TextDecoder("utf8").decode(r), (r)=>new TextEncoder().encode(r.substring(1))), Ru = am("ascii", "a", (r)=>{
    let e = "a";
    for(let t = 0; t < r.length; t++)e += String.fromCharCode(r[t]);
    return e;
}, (r)=>{
    r = r.substring(1);
    const e = im(r.length);
    for(let t = 0; t < r.length; t++)e[t] = r.charCodeAt(t);
    return e;
}), cm = {
    utf8: vp,
    "utf-8": vp,
    hex: bp.base16,
    latin1: Ru,
    ascii: Ru,
    binary: Ru,
    ...bp
};
function mr(r, e = "utf8") {
    const t = cm[e];
    if (!t) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Wd(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
function tr(r, e = "utf8") {
    const t = cm[e];
    if (!t) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1);
}
const mO = {
    waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe",
        batchFetchMessages: "waku_batchFetchMessages"
    },
    irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe",
        batchFetchMessages: "irn_batchFetchMessages"
    },
    iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe",
        batchFetchMessages: "iridium_batchFetchMessages"
    }
}, bO = "Input must be an string, Buffer or Uint8Array";
function vO(r) {
    let e;
    if (r instanceof Uint8Array) e = r;
    else if (typeof r == "string") e = new TextEncoder().encode(r);
    else throw new Error(bO);
    return e;
}
function EO(r) {
    return Array.prototype.map.call(r, function(e) {
        return (e < 16 ? "0" : "") + e.toString(16);
    }).join("");
}
function Wo(r) {
    return (4294967296 + r).toString(16).substring(1);
}
function MO(r, e, t) {
    let n = `
` + r + " = ";
    for(let s = 0; s < e.length; s += 2){
        if (t === 32) n += Wo(e[s]).toUpperCase(), n += " ", n += Wo(e[s + 1]).toUpperCase();
        else if (t === 64) n += Wo(e[s + 1]).toUpperCase(), n += Wo(e[s]).toUpperCase();
        else throw new Error("Invalid size " + t);
        s % 6 === 4 ? n += `
` + new Array(r.length + 4).join(" ") : s < e.length - 2 && (n += " ");
    }
    console.log(n);
}
function NO(r, e, t) {
    let n = /* @__PURE__ */ new Date().getTime();
    const s = new Uint8Array(e);
    for(let o = 0; o < e; o++)s[o] = o % 256;
    const i = /* @__PURE__ */ new Date().getTime();
    console.log("Generated random input in " + (i - n) + "ms"), n = i;
    for(let o = 0; o < t; o++){
        const a = r(s), u = /* @__PURE__ */ new Date().getTime(), c = u - n;
        n = u, console.log("Hashed in " + c + "ms: " + a.substring(0, 20) + "..."), console.log(Math.round(e / (1 << 20) / (c / 1e3) * 100) / 100 + " MB PER SECOND");
    }
}
var um = {
    normalizeInput: vO,
    toHex: EO,
    debugPrint: MO,
    testSpeed: NO
};
const ba = um;
function Ko(r, e, t) {
    const n = r[e] + r[t];
    let s = r[e + 1] + r[t + 1];
    n >= 4294967296 && s++, r[e] = n, r[e + 1] = s;
}
function Ep(r, e, t, n) {
    let s = r[e] + t;
    t < 0 && (s += 4294967296);
    let i = r[e + 1] + n;
    s >= 4294967296 && i++, r[e] = s, r[e + 1] = i;
}
function lm(r, e) {
    return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24;
}
function Mn(r, e, t, n, s, i) {
    const o = Gs[s], a = Gs[s + 1], u = Gs[i], c = Gs[i + 1];
    Ko(Ne, r, e), Ep(Ne, r, o, a);
    let l = Ne[n] ^ Ne[r], d = Ne[n + 1] ^ Ne[r + 1];
    Ne[n] = d, Ne[n + 1] = l, Ko(Ne, t, n), l = Ne[e] ^ Ne[t], d = Ne[e + 1] ^ Ne[t + 1], Ne[e] = l >>> 24 ^ d << 8, Ne[e + 1] = d >>> 24 ^ l << 8, Ko(Ne, r, e), Ep(Ne, r, u, c), l = Ne[n] ^ Ne[r], d = Ne[n + 1] ^ Ne[r + 1], Ne[n] = l >>> 16 ^ d << 16, Ne[n + 1] = d >>> 16 ^ l << 16, Ko(Ne, t, n), l = Ne[e] ^ Ne[t], d = Ne[e + 1] ^ Ne[t + 1], Ne[e] = d >>> 31 ^ l << 1, Ne[e + 1] = l >>> 31 ^ d << 1;
}
const dm = new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
]), xO = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
], St = new Uint8Array(xO.map(function(r) {
    return r * 2;
})), Ne = new Uint32Array(32), Gs = new Uint32Array(32);
function hm(r, e) {
    let t = 0;
    for(t = 0; t < 16; t++)Ne[t] = r.h[t], Ne[t + 16] = dm[t];
    for(Ne[24] = Ne[24] ^ r.t, Ne[25] = Ne[25] ^ r.t / 4294967296, e && (Ne[28] = ~Ne[28], Ne[29] = ~Ne[29]), t = 0; t < 32; t++)Gs[t] = lm(r.b, 4 * t);
    for(t = 0; t < 12; t++)Mn(0, 8, 16, 24, St[t * 16 + 0], St[t * 16 + 1]), Mn(2, 10, 18, 26, St[t * 16 + 2], St[t * 16 + 3]), Mn(4, 12, 20, 28, St[t * 16 + 4], St[t * 16 + 5]), Mn(6, 14, 22, 30, St[t * 16 + 6], St[t * 16 + 7]), Mn(0, 10, 20, 30, St[t * 16 + 8], St[t * 16 + 9]), Mn(2, 12, 22, 24, St[t * 16 + 10], St[t * 16 + 11]), Mn(4, 14, 16, 26, St[t * 16 + 12], St[t * 16 + 13]), Mn(6, 8, 18, 28, St[t * 16 + 14], St[t * 16 + 15]);
    for(t = 0; t < 16; t++)r.h[t] = r.h[t] ^ Ne[t] ^ Ne[t + 16];
}
const Nn = new Uint8Array([
    0,
    0,
    0,
    0,
    //  0: outlen, keylen, fanout, depth
    0,
    0,
    0,
    0,
    //  4: leaf length, sequential mode
    0,
    0,
    0,
    0,
    //  8: node offset
    0,
    0,
    0,
    0,
    // 12: node offset
    0,
    0,
    0,
    0,
    // 16: node depth, inner length, rfu
    0,
    0,
    0,
    0,
    // 20: rfu
    0,
    0,
    0,
    0,
    // 24: rfu
    0,
    0,
    0,
    0,
    // 28: rfu
    0,
    0,
    0,
    0,
    // 32: salt
    0,
    0,
    0,
    0,
    // 36: salt
    0,
    0,
    0,
    0,
    // 40: salt
    0,
    0,
    0,
    0,
    // 44: salt
    0,
    0,
    0,
    0,
    // 48: personal
    0,
    0,
    0,
    0,
    // 52: personal
    0,
    0,
    0,
    0,
    // 56: personal
    0,
    0,
    0,
    0
]);
function fm(r, e, t, n) {
    if (r === 0 || r > 64) throw new Error("Illegal output length, expected 0 < length <= 64");
    if (e && e.length > 64) throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
    if (t && t.length !== 16) throw new Error("Illegal salt, expected Uint8Array with length is 16");
    if (n && n.length !== 16) throw new Error("Illegal personal, expected Uint8Array with length is 16");
    const s = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen: r
    };
    Nn.fill(0), Nn[0] = r, e && (Nn[1] = e.length), Nn[2] = 1, Nn[3] = 1, t && Nn.set(t, 32), n && Nn.set(n, 48);
    for(let i = 0; i < 16; i++)s.h[i] = dm[i] ^ lm(Nn, i * 4);
    return e && (Kd(s, e), s.c = 128), s;
}
function Kd(r, e) {
    for(let t = 0; t < e.length; t++)r.c === 128 && (r.t += r.c, hm(r, !1), r.c = 0), r.b[r.c++] = e[t];
}
function pm(r) {
    for(r.t += r.c; r.c < 128;)r.b[r.c++] = 0;
    hm(r, !0);
    const e = new Uint8Array(r.outlen);
    for(let t = 0; t < r.outlen; t++)e[t] = r.h[t >> 2] >> 8 * (t & 3);
    return e;
}
function gm(r, e, t, n, s) {
    t = t || 64, r = ba.normalizeInput(r), n && (n = ba.normalizeInput(n)), s && (s = ba.normalizeInput(s));
    const i = fm(t, e, n, s);
    return Kd(i, r), pm(i);
}
function IO(r, e, t, n, s) {
    const i = gm(r, e, t, n, s);
    return ba.toHex(i);
}
var TO = {
    blake2b: gm,
    blake2bHex: IO,
    blake2bInit: fm,
    blake2bUpdate: Kd,
    blake2bFinal: pm
};
const ym = um;
function DO(r, e) {
    return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24;
}
function xn(r, e, t, n, s, i) {
    ze[r] = ze[r] + ze[e] + s, ze[n] = Xo(ze[n] ^ ze[r], 16), ze[t] = ze[t] + ze[n], ze[e] = Xo(ze[e] ^ ze[t], 12), ze[r] = ze[r] + ze[e] + i, ze[n] = Xo(ze[n] ^ ze[r], 8), ze[t] = ze[t] + ze[n], ze[e] = Xo(ze[e] ^ ze[t], 7);
}
function Xo(r, e) {
    return r >>> e ^ r << 32 - e;
}
const wm = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Ot = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
]), ze = new Uint32Array(16), Nt = new Uint32Array(16);
function mm(r, e) {
    let t = 0;
    for(t = 0; t < 8; t++)ze[t] = r.h[t], ze[t + 8] = wm[t];
    for(ze[12] ^= r.t, ze[13] ^= r.t / 4294967296, e && (ze[14] = ~ze[14]), t = 0; t < 16; t++)Nt[t] = DO(r.b, 4 * t);
    for(t = 0; t < 10; t++)xn(0, 4, 8, 12, Nt[Ot[t * 16 + 0]], Nt[Ot[t * 16 + 1]]), xn(1, 5, 9, 13, Nt[Ot[t * 16 + 2]], Nt[Ot[t * 16 + 3]]), xn(2, 6, 10, 14, Nt[Ot[t * 16 + 4]], Nt[Ot[t * 16 + 5]]), xn(3, 7, 11, 15, Nt[Ot[t * 16 + 6]], Nt[Ot[t * 16 + 7]]), xn(0, 5, 10, 15, Nt[Ot[t * 16 + 8]], Nt[Ot[t * 16 + 9]]), xn(1, 6, 11, 12, Nt[Ot[t * 16 + 10]], Nt[Ot[t * 16 + 11]]), xn(2, 7, 8, 13, Nt[Ot[t * 16 + 12]], Nt[Ot[t * 16 + 13]]), xn(3, 4, 9, 14, Nt[Ot[t * 16 + 14]], Nt[Ot[t * 16 + 15]]);
    for(t = 0; t < 8; t++)r.h[t] ^= ze[t] ^ ze[t + 8];
}
function bm(r, e) {
    if (!(r > 0 && r <= 32)) throw new Error("Incorrect output length, should be in [1, 32]");
    const t = e ? e.length : 0;
    if (e && !(t > 0 && t <= 32)) throw new Error("Incorrect key length, should be in [1, 32]");
    const n = {
        h: new Uint32Array(wm),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen: r
    };
    return n.h[0] ^= 16842752 ^ t << 8 ^ r, t > 0 && (Xd(n, e), n.c = 64), n;
}
function Xd(r, e) {
    for(let t = 0; t < e.length; t++)r.c === 64 && (r.t += r.c, mm(r, !1), r.c = 0), r.b[r.c++] = e[t];
}
function vm(r) {
    for(r.t += r.c; r.c < 64;)r.b[r.c++] = 0;
    mm(r, !0);
    const e = new Uint8Array(r.outlen);
    for(let t = 0; t < r.outlen; t++)e[t] = r.h[t >> 2] >> 8 * (t & 3) & 255;
    return e;
}
function Em(r, e, t) {
    t = t || 32, r = ym.normalizeInput(r);
    const n = bm(t, e);
    return Xd(n, r), vm(n);
}
function _O(r, e, t) {
    const n = Em(r, e, t);
    return ym.toHex(n);
}
var AO = {
    blake2s: Em,
    blake2sHex: _O,
    blake2sInit: bm,
    blake2sUpdate: Xd,
    blake2sFinal: vm
};
const zs = TO, Ps = AO;
var SO = {
    blake2b: zs.blake2b,
    blake2bHex: zs.blake2bHex,
    blake2bInit: zs.blake2bInit,
    blake2bUpdate: zs.blake2bUpdate,
    blake2bFinal: zs.blake2bFinal,
    blake2s: Ps.blake2s,
    blake2sHex: Ps.blake2sHex,
    blake2sInit: Ps.blake2sInit,
    blake2sUpdate: Ps.blake2sUpdate,
    blake2sFinal: Ps.blake2sFinal
};
const OO = ":";
function va(r) {
    const [e, t] = r.split(OO);
    return {
        namespace: e,
        reference: t
    };
}
function Mm(r, e) {
    return r.includes(":") ? [
        r
    ] : e.chains || [];
}
var jO = Object.defineProperty, CO = Object.defineProperties, LO = Object.getOwnPropertyDescriptors, Mp = Object.getOwnPropertySymbols, kO = Object.prototype.hasOwnProperty, zO = Object.prototype.propertyIsEnumerable, Pl = (r, e, t)=>e in r ? jO(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Np = (r, e)=>{
    for(var t in e || (e = {}))kO.call(e, t) && Pl(r, t, e[t]);
    if (Mp) for (var t of Mp(e))zO.call(e, t) && Pl(r, t, e[t]);
    return r;
}, PO = (r, e)=>CO(r, LO(e)), xp = (r, e, t)=>Pl(r, typeof e != "symbol" ? e + "" : e, t);
const UO = "ReactNative", cr = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown"
}, RO = "js";
function Ra() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Xn() {
    return !Ni() && !!Pd() && navigator.product === UO;
}
function $O() {
    return Xn() && ("TURBOPACK compile-time value", "object") < "u" && typeof (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Platform) < "u" && (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Platform.OS) === "android";
}
function BO() {
    return Xn() && ("TURBOPACK compile-time value", "object") < "u" && typeof (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Platform) < "u" && (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Platform.OS) === "ios";
}
function ys() {
    return !Ra() && !!Pd() && !!Ni();
}
function Mo() {
    return Xn() ? cr.reactNative : Ra() ? cr.node : ys() ? cr.browser : cr.unknown;
}
function Ip() {
    var r;
    try {
        return Xn() && ("TURBOPACK compile-time value", "object") < "u" && typeof (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Application) < "u" ? (r = /*TURBOPACK member replacement*/ __turbopack_context__.g.Application) == null ? void 0 : r.applicationId : void 0;
    } catch  {
        return;
    }
}
function FO(r, e) {
    const t = new URLSearchParams(r);
    return Object.entries(e).sort(([n], [s])=>n.localeCompare(s)).forEach(([n, s])=>{
        s != null && t.set(n, String(s));
    }), t.toString();
}
function qO(r) {
    var e, t;
    const n = Nm();
    try {
        return r != null && r.url && n.url && new URL(r.url).host !== new URL(n.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${r.url} differs from the actual page url:${n.url}. This is probably unintended and can lead to issues.`), r.url = n.url), (e = r == null ? void 0 : r.icons) != null && e.length && r.icons.length > 0 && (r.icons = r.icons.filter((s)=>s !== "")), PO(Np(Np({}, n), r), {
            url: (r == null ? void 0 : r.url) || n.url,
            name: (r == null ? void 0 : r.name) || n.name,
            description: (r == null ? void 0 : r.description) || n.description,
            icons: (t = r == null ? void 0 : r.icons) != null && t.length && r.icons.length > 0 ? r.icons : n.icons
        });
    } catch (s) {
        return console.warn("Error populating app metadata", s), r || n;
    }
}
function Nm() {
    return gw() || {
        name: "",
        description: "",
        url: "",
        icons: [
            ""
        ]
    };
}
function QO() {
    if (Mo() === cr.reactNative && ("TURBOPACK compile-time value", "object") < "u" && typeof (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Platform) < "u") {
        const { OS: t, Version: n } = /*TURBOPACK member replacement*/ __turbopack_context__.g.Platform;
        return [
            t,
            n
        ].join("-");
    }
    const r = gD();
    if (r === null) return "unknown";
    const e = r.os ? r.os.replace(" ", "").toLowerCase() : "unknown";
    return r.type === "browser" ? [
        e,
        r.name,
        r.version
    ].join("-") : [
        e,
        r.version
    ].join("-");
}
function VO() {
    var r;
    const e = Mo();
    return e === cr.browser ? [
        e,
        ((r = pw()) == null ? void 0 : r.host) || "unknown"
    ].join(":") : e;
}
function xm(r, e, t) {
    const n = QO(), s = VO();
    return [
        [
            r,
            e
        ].join("-"),
        [
            RO,
            t
        ].join("-"),
        n,
        s
    ].join("/");
}
function YO({ protocol: r, version: e, relayUrl: t, sdkVersion: n, auth: s, projectId: i, useOnCloseEvent: o, bundleId: a, packageName: u }) {
    const c = t.split("?"), l = xm(r, e, n), d = {
        auth: s,
        ua: l,
        projectId: i,
        useOnCloseEvent: o,
        packageName: u || void 0,
        bundleId: a || void 0
    }, h = FO(c[1] || "", d);
    return c[0] + "?" + h;
}
function yi(r, e) {
    return r.filter((t)=>e.includes(t)).length === r.length;
}
function Ul(r) {
    return Object.fromEntries(r.entries());
}
function Rl(r) {
    return new Map(Object.entries(r));
}
function di(r = ue.FIVE_MINUTES, e) {
    const t = ue.toMiliseconds(r || ue.FIVE_MINUTES);
    let n, s, i, o;
    return {
        resolve: (a)=>{
            i && n && (clearTimeout(i), n(a), o = Promise.resolve(a));
        },
        reject: (a)=>{
            i && s && (clearTimeout(i), s(a));
        },
        done: ()=>new Promise((a, u)=>{
                if (o) return a(o);
                i = setTimeout(()=>{
                    const c = new Error(e);
                    o = Promise.reject(c), u(c);
                }, t), n = a, s = u;
            })
    };
}
function Yr(r, e, t) {
    return new Promise(async (n, s)=>{
        const i = setTimeout(()=>s(new Error(t)), e);
        try {
            const o = await r;
            n(o);
        } catch (o) {
            s(o);
        }
        clearTimeout(i);
    });
}
function Im(r, e) {
    if (typeof e == "string" && e.startsWith(`${r}:`)) return e;
    if (r.toLowerCase() === "topic") {
        if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
        return `topic:${e}`;
    } else if (r.toLowerCase() === "id") {
        if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
        return `id:${e}`;
    }
    throw new Error(`Unknown expirer target type: ${r}`);
}
function GO(r) {
    return Im("topic", r);
}
function HO(r) {
    return Im("id", r);
}
function Tm(r) {
    const [e, t] = r.split(":"), n = {
        id: void 0,
        topic: void 0
    };
    if (e === "topic" && typeof t == "string") n.topic = t;
    else if (e === "id" && Number.isInteger(Number(t))) n.id = Number(t);
    else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);
    return n;
}
function dt(r, e) {
    return ue.fromMiliseconds(Date.now() + ue.toMiliseconds(r));
}
function jn(r) {
    return Date.now() >= ue.toMiliseconds(r);
}
function Pe(r, e) {
    return `${r}${e ? `:${e}` : ""}`;
}
function Ei(r = [], e = []) {
    return [
        .../* @__PURE__ */ new Set([
            ...r,
            ...e
        ])
    ];
}
async function WO({ id: r, topic: e, wcDeepLink: t }) {
    var n;
    try {
        if (!t) return;
        const s = typeof t == "string" ? JSON.parse(t) : t, i = s == null ? void 0 : s.href;
        if (typeof i != "string") return;
        const o = KO(i, r, e), a = Mo();
        if (a === cr.browser) {
            if (!((n = Ni()) != null && n.hasFocus())) {
                console.warn("Document does not have focus, skipping deeplink.");
                return;
            }
            XO(o);
        } else a === cr.reactNative && typeof (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking) < "u" && await /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking.openURL(o);
    } catch (s) {
        console.error(s);
    }
}
function KO(r, e, t) {
    const n = `requestId=${e}&sessionTopic=${t}`;
    r.endsWith("/") && (r = r.slice(0, -1));
    let s = `${r}`;
    if (r.startsWith("https://t.me")) {
        const i = r.includes("?") ? "&startapp=" : "?startapp=";
        s = `${s}${i}${t4(n, !0)}`;
    } else s = `${s}/wc?${n}`;
    return s;
}
function XO(r) {
    let e = "_self";
    e4() ? e = "_top" : (JO() || r.startsWith("https://") || r.startsWith("http://")) && (e = "_blank"), window.open(r, e, "noreferrer noopener");
}
async function ZO(r, e) {
    let t = "";
    try {
        if (ys() && (t = localStorage.getItem(e), t)) return t;
        t = await r.getItem(e);
    } catch (n) {
        console.error(n);
    }
    return t;
}
function Tp(r, e) {
    if (!r.includes(e)) return null;
    const t = r.split(/([&,?,=])/), n = t.indexOf(e);
    return t[n + 2];
}
function Dp() {
    return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (r)=>{
        const e = Math.random() * 16 | 0;
        return (r === "x" ? e : e & 3 | 8).toString(16);
    });
}
function Zd() {
    return typeof process < "u" && process.env.IS_VITEST === "true";
}
function JO() {
    return ("TURBOPACK compile-time value", "undefined") < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function e4() {
    try {
        return window.self !== window.top;
    } catch  {
        return !1;
    }
}
function t4(r, e = !1) {
    const t = ye.Buffer.from(r).toString("base64");
    return e ? t.replace(/[=]/g, "") : t;
}
function Dm(r) {
    return ye.Buffer.from(r, "base64").toString("utf-8");
}
function r4(r) {
    return new Promise((e)=>setTimeout(e, r));
}
let n4 = class {
    constructor({ limit: e }){
        xp(this, "limit"), xp(this, "set"), this.limit = e, this.set = /* @__PURE__ */ new Set();
    }
    add(e) {
        if (!this.set.has(e)) {
            if (this.set.size >= this.limit) {
                const t = this.set.values().next().value;
                t && this.set.delete(t);
            }
            this.set.add(e);
        }
    }
    has(e) {
        return this.set.has(e);
    }
};
const Zo = BigInt(2 ** 32 - 1), _p = BigInt(32);
function _m(r, e = !1) {
    return e ? {
        h: Number(r & Zo),
        l: Number(r >> _p & Zo)
    } : {
        h: Number(r >> _p & Zo) | 0,
        l: Number(r & Zo) | 0
    };
}
function Am(r, e = !1) {
    const t = r.length;
    let n = new Uint32Array(t), s = new Uint32Array(t);
    for(let i = 0; i < t; i++){
        const { h: o, l: a } = _m(r[i], e);
        [n[i], s[i]] = [
            o,
            a
        ];
    }
    return [
        n,
        s
    ];
}
const Ap = (r, e, t)=>r >>> t, Sp = (r, e, t)=>r << 32 - t | e >>> t, Cn = (r, e, t)=>r >>> t | e << 32 - t, Ln = (r, e, t)=>r << 32 - t | e >>> t, Hs = (r, e, t)=>r << 64 - t | e >>> t - 32, Ws = (r, e, t)=>r >>> t - 32 | e << 64 - t, i4 = (r, e)=>e, s4 = (r, e)=>r, o4 = (r, e, t)=>r << t | e >>> 32 - t, a4 = (r, e, t)=>e << t | r >>> 32 - t, c4 = (r, e, t)=>e << t - 32 | r >>> 64 - t, u4 = (r, e, t)=>r << t - 32 | e >>> 64 - t;
function Dr(r, e, t, n) {
    const s = (e >>> 0) + (n >>> 0);
    return {
        h: r + t + (s / 2 ** 32 | 0) | 0,
        l: s | 0
    };
}
const Jd = (r, e, t)=>(r >>> 0) + (e >>> 0) + (t >>> 0), eh = (r, e, t, n)=>e + t + n + (r / 2 ** 32 | 0) | 0, l4 = (r, e, t, n)=>(r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0), d4 = (r, e, t, n, s)=>e + t + n + s + (r / 2 ** 32 | 0) | 0, h4 = (r, e, t, n, s)=>(r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0), f4 = (r, e, t, n, s, i)=>e + t + n + s + i + (r / 2 ** 32 | 0) | 0, Fi = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Rc(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function yn(r) {
    if (!Number.isSafeInteger(r) || r < 0) throw new Error("positive integer expected, got " + r);
}
function Sr(r, ...e) {
    if (!Rc(r)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function $c(r) {
    if (typeof r != "function" || typeof r.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
    yn(r.outputLen), yn(r.blockLen);
}
function Kn(r, e = !0) {
    if (r.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function th(r, e) {
    Sr(r);
    const t = e.outputLen;
    if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
function lo(r) {
    return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function br(...r) {
    for(let e = 0; e < r.length; e++)r[e].fill(0);
}
function $u(r) {
    return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function kr(r, e) {
    return r << 32 - e | r >>> e;
}
const Sm = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
function Om(r) {
    return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
const sn = Sm ? (r)=>r : (r)=>Om(r);
function p4(r) {
    for(let e = 0; e < r.length; e++)r[e] = Om(r[e]);
    return r;
}
const kn = Sm ? (r)=>r : p4, jm = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", g4 = Array.from({
    length: 256
}, (r, e)=>e.toString(16).padStart(2, "0"));
function ts(r) {
    if (Sr(r), jm) return r.toHex();
    let e = "";
    for(let t = 0; t < r.length; t++)e += g4[r[t]];
    return e;
}
const en = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function Op(r) {
    if (r >= en._0 && r <= en._9) return r - en._0;
    if (r >= en.A && r <= en.F) return r - (en.A - 10);
    if (r >= en.a && r <= en.f) return r - (en.a - 10);
}
function $a(r) {
    if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
    if (jm) return Uint8Array.fromHex(r);
    const e = r.length, t = e / 2;
    if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(t);
    for(let s = 0, i = 0; s < t; s++, i += 2){
        const o = Op(r.charCodeAt(i)), a = Op(r.charCodeAt(i + 1));
        if (o === void 0 || a === void 0) {
            const u = r[i] + r[i + 1];
            throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + i);
        }
        n[s] = o * 16 + a;
    }
    return n;
}
function Cm(r) {
    if (typeof r != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(r));
}
function Ar(r) {
    return typeof r == "string" && (r = Cm(r)), Sr(r), r;
}
function Fn(...r) {
    let e = 0;
    for(let n = 0; n < r.length; n++){
        const s = r[n];
        Sr(s), e += s.length;
    }
    const t = new Uint8Array(e);
    for(let n = 0, s = 0; n < r.length; n++){
        const i = r[n];
        t.set(i, s), s += i.length;
    }
    return t;
}
class Bc {
}
function No(r) {
    const e = (n)=>r().update(Ar(n)).digest(), t = r();
    return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = ()=>r(), e;
}
function y4(r) {
    const e = (n, s)=>r(s).update(Ar(n)).digest(), t = r({});
    return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (n)=>r(n), e;
}
function Li(r = 32) {
    if (Fi && typeof Fi.getRandomValues == "function") return Fi.getRandomValues(new Uint8Array(r));
    if (Fi && typeof Fi.randomBytes == "function") return Uint8Array.from(Fi.randomBytes(r));
    throw new Error("crypto.getRandomValues must be defined");
}
const w4 = BigInt(0), Us = BigInt(1), m4 = BigInt(2), b4 = BigInt(7), v4 = BigInt(256), E4 = BigInt(113), Lm = [], km = [], zm = [];
for(let r = 0, e = Us, t = 1, n = 0; r < 24; r++){
    [t, n] = [
        n,
        (2 * t + 3 * n) % 5
    ], Lm.push(2 * (5 * n + t)), km.push((r + 1) * (r + 2) / 2 % 64);
    let s = w4;
    for(let i = 0; i < 7; i++)e = (e << Us ^ (e >> b4) * E4) % v4, e & m4 && (s ^= Us << (Us << BigInt(i)) - Us);
    zm.push(s);
}
const Pm = Am(zm, !0), M4 = Pm[0], N4 = Pm[1], jp = (r, e, t)=>t > 32 ? c4(r, e, t) : o4(r, e, t), Cp = (r, e, t)=>t > 32 ? u4(r, e, t) : a4(r, e, t);
function x4(r, e = 24) {
    const t = new Uint32Array(10);
    for(let n = 24 - e; n < 24; n++){
        for(let o = 0; o < 10; o++)t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
        for(let o = 0; o < 10; o += 2){
            const a = (o + 8) % 10, u = (o + 2) % 10, c = t[u], l = t[u + 1], d = jp(c, l, 1) ^ t[a], h = Cp(c, l, 1) ^ t[a + 1];
            for(let f = 0; f < 50; f += 10)r[o + f] ^= d, r[o + f + 1] ^= h;
        }
        let s = r[2], i = r[3];
        for(let o = 0; o < 24; o++){
            const a = km[o], u = jp(s, i, a), c = Cp(s, i, a), l = Lm[o];
            s = r[l], i = r[l + 1], r[l] = u, r[l + 1] = c;
        }
        for(let o = 0; o < 50; o += 10){
            for(let a = 0; a < 10; a++)t[a] = r[o + a];
            for(let a = 0; a < 10; a++)r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
        }
        r[0] ^= M4[n], r[1] ^= N4[n];
    }
    br(t);
}
let I4 = class Um extends Bc {
    constructor(e, t, n, s = !1, i = 24){
        if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = s, this.rounds = i, yn(n), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200), this.state32 = lo(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        kn(this.state32), x4(this.state32, this.rounds), kn(this.state32), this.posOut = 0, this.pos = 0;
    }
    update(e) {
        Kn(this), e = Ar(e), Sr(e);
        const { blockLen: t, state: n } = this, s = e.length;
        for(let i = 0; i < s;){
            const o = Math.min(t - this.pos, s - i);
            for(let a = 0; a < o; a++)n[this.pos++] ^= e[i++];
            this.pos === t && this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = !0;
        const { state: e, suffix: t, pos: n, blockLen: s } = this;
        e[n] ^= t, t & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
    }
    writeInto(e) {
        Kn(this, !1), Sr(e), this.finish();
        const t = this.state, { blockLen: n } = this;
        for(let s = 0, i = e.length; s < i;){
            this.posOut >= n && this.keccak();
            const o = Math.min(n - this.posOut, i - s);
            e.set(t.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
        }
        return e;
    }
    xofInto(e) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(e);
    }
    xof(e) {
        return yn(e), this.xofInto(new Uint8Array(e));
    }
    digestInto(e) {
        if (th(e, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = !0, br(this.state);
    }
    _cloneInto(e) {
        const { blockLen: t, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
        return e || (e = new Um(t, n, s, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
    }
};
const T4 = (r, e, t)=>No(()=>new I4(e, r, t)), D4 = T4(1, 136, 256 / 8);
function _4(r, e, t, n) {
    if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
    const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), u = n ? 4 : 0, c = n ? 0 : 4;
    r.setUint32(e + u, o, n), r.setUint32(e + c, a, n);
}
function A4(r, e, t) {
    return r & e ^ ~r & t;
}
function S4(r, e, t) {
    return r & e ^ r & t ^ e & t;
}
let Rm = class extends Bc {
    constructor(e, t, n, s){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.buffer = new Uint8Array(e), this.view = $u(this.buffer);
    }
    update(e) {
        Kn(this), e = Ar(e), Sr(e);
        const { view: t, buffer: n, blockLen: s } = this, i = e.length;
        for(let o = 0; o < i;){
            const a = Math.min(s - this.pos, i - o);
            if (a === s) {
                const u = $u(e);
                for(; s <= i - o; o += s)this.process(u, o);
                continue;
            }
            n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        Kn(this), th(e, this), this.finished = !0;
        const { buffer: t, view: n, blockLen: s, isLE: i } = this;
        let { pos: o } = this;
        t[o++] = 128, br(this.buffer.subarray(o)), this.padOffset > s - o && (this.process(n, 0), o = 0);
        for(let d = o; d < s; d++)t[d] = 0;
        _4(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
        const a = $u(e), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = u / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let d = 0; d < c; d++)a.setUint32(4 * d, l[d], i);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const n = e.slice(0, t);
        return this.destroy(), n;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
        return e.destroyed = o, e.finished = i, e.length = s, e.pos = a, s % t && e.buffer.set(n), e;
    }
    clone() {
        return this._cloneInto();
    }
};
const In = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), jt = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
]), Ct = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]), O4 = Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Tn = new Uint32Array(64);
class j4 extends Rm {
    constructor(e = 32){
        super(64, e, 8, !1), this.A = In[0] | 0, this.B = In[1] | 0, this.C = In[2] | 0, this.D = In[3] | 0, this.E = In[4] | 0, this.F = In[5] | 0, this.G = In[6] | 0, this.H = In[7] | 0;
    }
    get() {
        const { A: e, B: t, C: n, D: s, E: i, F: o, G: a, H: u } = this;
        return [
            e,
            t,
            n,
            s,
            i,
            o,
            a,
            u
        ];
    }
    set(e, t, n, s, i, o, a, u) {
        this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = u | 0;
    }
    process(e, t) {
        for(let d = 0; d < 16; d++, t += 4)Tn[d] = e.getUint32(t, !1);
        for(let d = 16; d < 64; d++){
            const h = Tn[d - 15], f = Tn[d - 2], g = kr(h, 7) ^ kr(h, 18) ^ h >>> 3, p = kr(f, 17) ^ kr(f, 19) ^ f >>> 10;
            Tn[d] = p + Tn[d - 7] + g + Tn[d - 16] | 0;
        }
        let { A: n, B: s, C: i, D: o, E: a, F: u, G: c, H: l } = this;
        for(let d = 0; d < 64; d++){
            const h = kr(a, 6) ^ kr(a, 11) ^ kr(a, 25), f = l + h + A4(a, u, c) + O4[d] + Tn[d] | 0, g = (kr(n, 2) ^ kr(n, 13) ^ kr(n, 22)) + S4(n, s, i) | 0;
            l = c, c = u, u = a, a = o + f | 0, o = i, i = s, s = n, n = f + g | 0;
        }
        n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(n, s, i, o, a, u, c, l);
    }
    roundClean() {
        br(Tn);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), br(this.buffer);
    }
}
const $m = Am([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((r)=>BigInt(r))), C4 = $m[0], L4 = $m[1], Dn = new Uint32Array(80), _n = new Uint32Array(80);
let rh = class extends Rm {
    constructor(e = 64){
        super(128, e, 16, !1), this.Ah = Ct[0] | 0, this.Al = Ct[1] | 0, this.Bh = Ct[2] | 0, this.Bl = Ct[3] | 0, this.Ch = Ct[4] | 0, this.Cl = Ct[5] | 0, this.Dh = Ct[6] | 0, this.Dl = Ct[7] | 0, this.Eh = Ct[8] | 0, this.El = Ct[9] | 0, this.Fh = Ct[10] | 0, this.Fl = Ct[11] | 0, this.Gh = Ct[12] | 0, this.Gl = Ct[13] | 0, this.Hh = Ct[14] | 0, this.Hl = Ct[15] | 0;
    }
    get() {
        const { Ah: e, Al: t, Bh: n, Bl: s, Ch: i, Cl: o, Dh: a, Dl: u, Eh: c, El: l, Fh: d, Fl: h, Gh: f, Gl: g, Hh: p, Hl: m } = this;
        return [
            e,
            t,
            n,
            s,
            i,
            o,
            a,
            u,
            c,
            l,
            d,
            h,
            f,
            g,
            p,
            m
        ];
    }
    set(e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, m) {
        this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = c | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = h | 0, this.Gh = f | 0, this.Gl = g | 0, this.Hh = p | 0, this.Hl = m | 0;
    }
    process(e, t) {
        for(let v = 0; v < 16; v++, t += 4)Dn[v] = e.getUint32(t), _n[v] = e.getUint32(t += 4);
        for(let v = 16; v < 80; v++){
            const N = Dn[v - 15] | 0, O = _n[v - 15] | 0, z = Cn(N, O, 1) ^ Cn(N, O, 8) ^ Ap(N, O, 7), P = Ln(N, O, 1) ^ Ln(N, O, 8) ^ Sp(N, O, 7), U = Dn[v - 2] | 0, R = _n[v - 2] | 0, G = Cn(U, R, 19) ^ Hs(U, R, 61) ^ Ap(U, R, 6), F = Ln(U, R, 19) ^ Ws(U, R, 61) ^ Sp(U, R, 6), H = l4(P, F, _n[v - 7], _n[v - 16]), B = d4(H, z, G, Dn[v - 7], Dn[v - 16]);
            Dn[v] = B | 0, _n[v] = H | 0;
        }
        let { Ah: n, Al: s, Bh: i, Bl: o, Ch: a, Cl: u, Dh: c, Dl: l, Eh: d, El: h, Fh: f, Fl: g, Gh: p, Gl: m, Hh: x, Hl: _ } = this;
        for(let v = 0; v < 80; v++){
            const N = Cn(d, h, 14) ^ Cn(d, h, 18) ^ Hs(d, h, 41), O = Ln(d, h, 14) ^ Ln(d, h, 18) ^ Ws(d, h, 41), z = d & f ^ ~d & p, P = h & g ^ ~h & m, U = h4(_, O, P, L4[v], _n[v]), R = f4(U, x, N, z, C4[v], Dn[v]), G = U | 0, F = Cn(n, s, 28) ^ Hs(n, s, 34) ^ Hs(n, s, 39), H = Ln(n, s, 28) ^ Ws(n, s, 34) ^ Ws(n, s, 39), B = n & i ^ n & a ^ i & a, C = s & o ^ s & u ^ o & u;
            x = p | 0, _ = m | 0, p = f | 0, m = g | 0, f = d | 0, g = h | 0, ({ h: d, l: h } = Dr(c | 0, l | 0, R | 0, G | 0)), c = a | 0, l = u | 0, a = i | 0, u = o | 0, i = n | 0, o = s | 0;
            const T = Jd(G, H, C);
            n = eh(T, R, F, B), s = T | 0;
        }
        ({ h: n, l: s } = Dr(this.Ah | 0, this.Al | 0, n | 0, s | 0)), ({ h: i, l: o } = Dr(this.Bh | 0, this.Bl | 0, i | 0, o | 0)), ({ h: a, l: u } = Dr(this.Ch | 0, this.Cl | 0, a | 0, u | 0)), ({ h: c, l } = Dr(this.Dh | 0, this.Dl | 0, c | 0, l | 0)), ({ h: d, l: h } = Dr(this.Eh | 0, this.El | 0, d | 0, h | 0)), ({ h: f, l: g } = Dr(this.Fh | 0, this.Fl | 0, f | 0, g | 0)), ({ h: p, l: m } = Dr(this.Gh | 0, this.Gl | 0, p | 0, m | 0)), ({ h: x, l: _ } = Dr(this.Hh | 0, this.Hl | 0, x | 0, _ | 0)), this.set(n, s, i, o, a, u, c, l, d, h, f, g, p, m, x, _);
    }
    roundClean() {
        br(Dn, _n);
    }
    destroy() {
        br(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
};
class k4 extends rh {
    constructor(){
        super(48), this.Ah = jt[0] | 0, this.Al = jt[1] | 0, this.Bh = jt[2] | 0, this.Bl = jt[3] | 0, this.Ch = jt[4] | 0, this.Cl = jt[5] | 0, this.Dh = jt[6] | 0, this.Dl = jt[7] | 0, this.Eh = jt[8] | 0, this.El = jt[9] | 0, this.Fh = jt[10] | 0, this.Fl = jt[11] | 0, this.Gh = jt[12] | 0, this.Gl = jt[13] | 0, this.Hh = jt[14] | 0, this.Hl = jt[15] | 0;
    }
}
const Lt = Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
]);
class z4 extends rh {
    constructor(){
        super(32), this.Ah = Lt[0] | 0, this.Al = Lt[1] | 0, this.Bh = Lt[2] | 0, this.Bl = Lt[3] | 0, this.Ch = Lt[4] | 0, this.Cl = Lt[5] | 0, this.Dh = Lt[6] | 0, this.Dl = Lt[7] | 0, this.Eh = Lt[8] | 0, this.El = Lt[9] | 0, this.Fh = Lt[10] | 0, this.Fl = Lt[11] | 0, this.Gh = Lt[12] | 0, this.Gl = Lt[13] | 0, this.Hh = Lt[14] | 0, this.Hl = Lt[15] | 0;
    }
}
const Fc = No(()=>new j4()), P4 = No(()=>new rh()), U4 = No(()=>new k4()), R4 = No(()=>new z4()), $4 = Uint8Array.from([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9
]), lt = Uint32Array.from([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
]), he = new Uint32Array(32);
function An(r, e, t, n, s, i) {
    const o = s[i], a = s[i + 1];
    let u = he[2 * r], c = he[2 * r + 1], l = he[2 * e], d = he[2 * e + 1], h = he[2 * t], f = he[2 * t + 1], g = he[2 * n], p = he[2 * n + 1], m = Jd(u, l, o);
    c = eh(m, c, d, a), u = m | 0, ({ Dh: p, Dl: g } = {
        Dh: p ^ c,
        Dl: g ^ u
    }), ({ Dh: p, Dl: g } = {
        Dh: i4(p, g),
        Dl: s4(p)
    }), ({ h: f, l: h } = Dr(f, h, p, g)), ({ Bh: d, Bl: l } = {
        Bh: d ^ f,
        Bl: l ^ h
    }), ({ Bh: d, Bl: l } = {
        Bh: Cn(d, l, 24),
        Bl: Ln(d, l, 24)
    }), he[2 * r] = u, he[2 * r + 1] = c, he[2 * e] = l, he[2 * e + 1] = d, he[2 * t] = h, he[2 * t + 1] = f, he[2 * n] = g, he[2 * n + 1] = p;
}
function Sn(r, e, t, n, s, i) {
    const o = s[i], a = s[i + 1];
    let u = he[2 * r], c = he[2 * r + 1], l = he[2 * e], d = he[2 * e + 1], h = he[2 * t], f = he[2 * t + 1], g = he[2 * n], p = he[2 * n + 1], m = Jd(u, l, o);
    c = eh(m, c, d, a), u = m | 0, ({ Dh: p, Dl: g } = {
        Dh: p ^ c,
        Dl: g ^ u
    }), ({ Dh: p, Dl: g } = {
        Dh: Cn(p, g, 16),
        Dl: Ln(p, g, 16)
    }), ({ h: f, l: h } = Dr(f, h, p, g)), ({ Bh: d, Bl: l } = {
        Bh: d ^ f,
        Bl: l ^ h
    }), ({ Bh: d, Bl: l } = {
        Bh: Hs(d, l, 63),
        Bl: Ws(d, l, 63)
    }), he[2 * r] = u, he[2 * r + 1] = c, he[2 * e] = l, he[2 * e + 1] = d, he[2 * t] = h, he[2 * t + 1] = f, he[2 * n] = g, he[2 * n + 1] = p;
}
function B4(r, e = {}, t, n, s) {
    if (yn(t), r < 0 || r > t) throw new Error("outputLen bigger than keyLen");
    const { key: i, salt: o, personalization: a } = e;
    if (i !== void 0 && (i.length < 1 || i.length > t)) throw new Error("key length must be undefined or 1.." + t);
    if (o !== void 0 && o.length !== n) throw new Error("salt must be undefined or " + n);
    if (a !== void 0 && a.length !== s) throw new Error("personalization must be undefined or " + s);
}
class F4 extends Bc {
    constructor(e, t){
        super(), this.finished = !1, this.destroyed = !1, this.length = 0, this.pos = 0, yn(e), yn(t), this.blockLen = e, this.outputLen = t, this.buffer = new Uint8Array(e), this.buffer32 = lo(this.buffer);
    }
    update(e) {
        Kn(this), e = Ar(e), Sr(e);
        const { blockLen: t, buffer: n, buffer32: s } = this, i = e.length, o = e.byteOffset, a = e.buffer;
        for(let u = 0; u < i;){
            this.pos === t && (kn(s), this.compress(s, 0, !1), kn(s), this.pos = 0);
            const c = Math.min(t - this.pos, i - u), l = o + u;
            if (c === t && !(l % 4) && u + c < i) {
                const d = new Uint32Array(a, l, Math.floor((i - u) / 4));
                kn(d);
                for(let h = 0; u + t < i; h += s.length, u += t)this.length += t, this.compress(d, h, !1);
                kn(d);
                continue;
            }
            n.set(e.subarray(u, u + c), this.pos), this.pos += c, this.length += c, u += c;
        }
        return this;
    }
    digestInto(e) {
        Kn(this), th(e, this);
        const { pos: t, buffer32: n } = this;
        this.finished = !0, br(this.buffer.subarray(t)), kn(n), this.compress(n, 0, !0), kn(n);
        const s = lo(e);
        this.get().forEach((i, o)=>s[o] = sn(i));
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const n = e.slice(0, t);
        return this.destroy(), n;
    }
    _cloneInto(e) {
        const { buffer: t, length: n, finished: s, destroyed: i, outputLen: o, pos: a } = this;
        return e || (e = new this.constructor({
            dkLen: o
        })), e.set(...this.get()), e.buffer.set(t), e.destroyed = i, e.finished = s, e.length = n, e.pos = a, e.outputLen = o, e;
    }
    clone() {
        return this._cloneInto();
    }
}
class q4 extends F4 {
    constructor(e = {}){
        const t = e.dkLen === void 0 ? 64 : e.dkLen;
        super(128, t), this.v0l = lt[0] | 0, this.v0h = lt[1] | 0, this.v1l = lt[2] | 0, this.v1h = lt[3] | 0, this.v2l = lt[4] | 0, this.v2h = lt[5] | 0, this.v3l = lt[6] | 0, this.v3h = lt[7] | 0, this.v4l = lt[8] | 0, this.v4h = lt[9] | 0, this.v5l = lt[10] | 0, this.v5h = lt[11] | 0, this.v6l = lt[12] | 0, this.v6h = lt[13] | 0, this.v7l = lt[14] | 0, this.v7h = lt[15] | 0, B4(t, e, 64, 16, 16);
        let { key: n, personalization: s, salt: i } = e, o = 0;
        if (n !== void 0 && (n = Ar(n), o = n.length), this.v0l ^= this.outputLen | o << 8 | 65536 | 1 << 24, i !== void 0) {
            i = Ar(i);
            const a = lo(i);
            this.v4l ^= sn(a[0]), this.v4h ^= sn(a[1]), this.v5l ^= sn(a[2]), this.v5h ^= sn(a[3]);
        }
        if (s !== void 0) {
            s = Ar(s);
            const a = lo(s);
            this.v6l ^= sn(a[0]), this.v6h ^= sn(a[1]), this.v7l ^= sn(a[2]), this.v7h ^= sn(a[3]);
        }
        if (n !== void 0) {
            const a = new Uint8Array(this.blockLen);
            a.set(n), this.update(a);
        }
    }
    get() {
        let { v0l: e, v0h: t, v1l: n, v1h: s, v2l: i, v2h: o, v3l: a, v3h: u, v4l: c, v4h: l, v5l: d, v5h: h, v6l: f, v6h: g, v7l: p, v7h: m } = this;
        return [
            e,
            t,
            n,
            s,
            i,
            o,
            a,
            u,
            c,
            l,
            d,
            h,
            f,
            g,
            p,
            m
        ];
    }
    set(e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, m) {
        this.v0l = e | 0, this.v0h = t | 0, this.v1l = n | 0, this.v1h = s | 0, this.v2l = i | 0, this.v2h = o | 0, this.v3l = a | 0, this.v3h = u | 0, this.v4l = c | 0, this.v4h = l | 0, this.v5l = d | 0, this.v5h = h | 0, this.v6l = f | 0, this.v6h = g | 0, this.v7l = p | 0, this.v7h = m | 0;
    }
    compress(e, t, n) {
        this.get().forEach((u, c)=>he[c] = u), he.set(lt, 16);
        let { h: s, l: i } = _m(BigInt(this.length));
        he[24] = lt[8] ^ i, he[25] = lt[9] ^ s, n && (he[28] = ~he[28], he[29] = ~he[29]);
        let o = 0;
        const a = $4;
        for(let u = 0; u < 12; u++)An(0, 4, 8, 12, e, t + 2 * a[o++]), Sn(0, 4, 8, 12, e, t + 2 * a[o++]), An(1, 5, 9, 13, e, t + 2 * a[o++]), Sn(1, 5, 9, 13, e, t + 2 * a[o++]), An(2, 6, 10, 14, e, t + 2 * a[o++]), Sn(2, 6, 10, 14, e, t + 2 * a[o++]), An(3, 7, 11, 15, e, t + 2 * a[o++]), Sn(3, 7, 11, 15, e, t + 2 * a[o++]), An(0, 5, 10, 15, e, t + 2 * a[o++]), Sn(0, 5, 10, 15, e, t + 2 * a[o++]), An(1, 6, 11, 12, e, t + 2 * a[o++]), Sn(1, 6, 11, 12, e, t + 2 * a[o++]), An(2, 7, 8, 13, e, t + 2 * a[o++]), Sn(2, 7, 8, 13, e, t + 2 * a[o++]), An(3, 4, 9, 14, e, t + 2 * a[o++]), Sn(3, 4, 9, 14, e, t + 2 * a[o++]);
        this.v0l ^= he[0] ^ he[16], this.v0h ^= he[1] ^ he[17], this.v1l ^= he[2] ^ he[18], this.v1h ^= he[3] ^ he[19], this.v2l ^= he[4] ^ he[20], this.v2h ^= he[5] ^ he[21], this.v3l ^= he[6] ^ he[22], this.v3h ^= he[7] ^ he[23], this.v4l ^= he[8] ^ he[24], this.v4h ^= he[9] ^ he[25], this.v5l ^= he[10] ^ he[26], this.v5h ^= he[11] ^ he[27], this.v6l ^= he[12] ^ he[28], this.v6h ^= he[13] ^ he[29], this.v7l ^= he[14] ^ he[30], this.v7h ^= he[15] ^ he[31], br(he);
    }
    destroy() {
        this.destroyed = !0, br(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
const Q4 = y4((r)=>new q4(r)), V4 = "https://rpc.walletconnect.org/v1";
function Bm(r) {
    const e = `Ethereum Signed Message:
${r.length}`, t = new TextEncoder().encode(e + r);
    return "0x" + ye.Buffer.from(D4(t)).toString("hex");
}
async function Y4(r, e, t, n, s, i) {
    switch(t.t){
        case "eip191":
            return await G4(r, e, t.s);
        case "eip1271":
            return await H4(r, e, t.s, n, s, i);
        default:
            throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`);
    }
}
function G4(r, e, t) {
    const n = NA(t);
    return zA({
        payload: Bm(e),
        signature: n
    }).toLowerCase() === r.toLowerCase();
}
async function H4(r, e, t, n, s, i) {
    const o = va(n);
    if (!o.namespace || !o.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`);
    try {
        const a = "0x1626ba7e", u = "0000000000000000000000000000000000000000000000000000000000000040", c = t.substring(2), l = (c.length / 2).toString(16).padStart(64, "0"), d = (e.startsWith("0x") ? e : Bm(e)).substring(2), h = a + d + u + l + c, f = await fetch(`${i || V4}/?chainId=${n}&projectId=${s}`, {
            headers: {
                "Content-Type": "application/json"
            },
            method: "POST",
            body: JSON.stringify({
                id: W4(),
                jsonrpc: "2.0",
                method: "eth_call",
                params: [
                    {
                        to: r,
                        data: h
                    },
                    "latest"
                ]
            })
        }), { result: g } = await f.json();
        return g ? g.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
    } catch (a) {
        return console.error("isValidEip1271Signature: ", a), !1;
    }
}
function W4() {
    return Date.now() + Math.floor(Math.random() * 1e3);
}
function K4(r) {
    const e = atob(r), t = new Uint8Array(e.length);
    for(let o = 0; o < e.length; o++)t[o] = e.charCodeAt(o);
    const n = t[0];
    if (n === 0) throw new Error("No signatures found");
    const s = 1 + n * 64;
    if (t.length < s) throw new Error("Transaction data too short for claimed signature count");
    if (t.length < 100) throw new Error("Transaction too short");
    const i = ye.Buffer.from(r, "base64").slice(1, 65);
    return vo.encode(i);
}
function X4(r) {
    const e = new Uint8Array(ye.Buffer.from(r, "base64")), t = Array.from("TransactionData::").map((i)=>i.charCodeAt(0)), n = new Uint8Array(t.length + e.length);
    n.set(t), n.set(e, t.length);
    const s = Q4(n, {
        dkLen: 32
    });
    return vo.encode(s);
}
function Lp(r) {
    const e = new Uint8Array(Fc(Z4(r)));
    return vo.encode(e);
}
function Z4(r) {
    if (r instanceof Uint8Array) return r;
    if (Array.isArray(r)) return new Uint8Array(r);
    if (typeof r == "object" && r != null && r.data) return new Uint8Array(Object.values(r.data));
    if (typeof r == "object" && r) return new Uint8Array(Object.values(r));
    throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function kp(r) {
    const e = ye.Buffer.from(r, "base64"), t = ES(e).txn;
    if (!t) throw new Error("Invalid signed transaction: missing 'txn' field");
    const n = hS(t), s = ye.Buffer.from("TX"), i = ye.Buffer.concat([
        s,
        ye.Buffer.from(n)
    ]), o = R4(i);
    return kA.encode(o).replace(/=+$/, "");
}
function Bu(r) {
    const e = [];
    let t = BigInt(r);
    for(; t >= BigInt(128);)e.push(Number(t & BigInt(127) | BigInt(128))), t >>= BigInt(7);
    return e.push(Number(t)), ye.Buffer.from(e);
}
function J4(r) {
    const e = ye.Buffer.from(r.signed.bodyBytes, "base64"), t = ye.Buffer.from(r.signed.authInfoBytes, "base64"), n = ye.Buffer.from(r.signature.signature, "base64"), s = [];
    s.push(ye.Buffer.from([
        10
    ])), s.push(Bu(e.length)), s.push(e), s.push(ye.Buffer.from([
        18
    ])), s.push(Bu(t.length)), s.push(t), s.push(ye.Buffer.from([
        26
    ])), s.push(Bu(n.length)), s.push(n);
    const i = ye.Buffer.concat(s), o = Fc(i);
    return ye.Buffer.from(o).toString("hex").toUpperCase();
}
function e3(r) {
    var e, t;
    const n = [];
    try {
        if (typeof r == "string") return n.push(r), n;
        if (typeof r != "object") return n;
        r != null && r.id && n.push(r.id);
        const s = (t = (e = r == null ? void 0 : r.capabilities) == null ? void 0 : e.caip345) == null ? void 0 : t.transactionHashes;
        s && n.push(...s);
    } catch (s) {
        console.warn("getWalletSendCallsHashes failed: ", s);
    }
    return n;
}
var t3 = Object.defineProperty, r3 = Object.defineProperties, n3 = Object.getOwnPropertyDescriptors, zp = Object.getOwnPropertySymbols, i3 = Object.prototype.hasOwnProperty, s3 = Object.prototype.propertyIsEnumerable, Pp = (r, e, t)=>e in r ? t3(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, o3 = (r, e)=>{
    for(var t in e || (e = {}))i3.call(e, t) && Pp(r, t, e[t]);
    if (zp) for (var t of zp(e))s3.call(e, t) && Pp(r, t, e[t]);
    return r;
}, a3 = (r, e)=>r3(r, n3(e));
const c3 = "did:pkh:", nh = (r)=>r == null ? void 0 : r.split(":"), u3 = (r)=>{
    const e = r && nh(r);
    if (e) return r.includes(c3) ? e[3] : e[1];
}, $l = (r)=>{
    const e = r && nh(r);
    if (e) return e[2] + ":" + e[3];
}, Ba = (r)=>{
    const e = r && nh(r);
    if (e) return e.pop();
};
async function Up(r) {
    const { cacao: e, projectId: t } = r, { s: n, p: s } = e, i = Fm(s, s.iss), o = Ba(s.iss);
    return await Y4(o, i, n, $l(s.iss), t);
}
const Fm = (r, e)=>{
    const t = `${r.domain} wants you to sign in with your Ethereum account:`, n = Ba(e);
    if (!r.aud && !r.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
    let s = r.statement || void 0;
    const i = `URI: ${r.aud || r.uri}`, o = `Version: ${r.version}`, a = `Chain ID: ${u3(e)}`, u = `Nonce: ${r.nonce}`, c = `Issued At: ${r.iat}`, l = r.exp ? `Expiration Time: ${r.exp}` : void 0, d = r.nbf ? `Not Before: ${r.nbf}` : void 0, h = r.requestId ? `Request ID: ${r.requestId}` : void 0, f = r.resources ? `Resources:${r.resources.map((p)=>`
- ${p}`).join("")}` : void 0, g = Ea(r.resources);
    if (g) {
        const p = ho(g);
        s = m3(s, p);
    }
    return [
        t,
        n,
        "",
        s,
        "",
        i,
        o,
        a,
        u,
        c,
        l,
        d,
        h,
        f
    ].filter((p)=>p != null).join(`
`);
};
function l3(r) {
    return ye.Buffer.from(JSON.stringify(r)).toString("base64");
}
function d3(r) {
    return JSON.parse(ye.Buffer.from(r, "base64").toString("utf-8"));
}
function Ii(r) {
    if (!r) throw new Error("No recap provided, value is undefined");
    if (!r.att) throw new Error("No `att` property found");
    const e = Object.keys(r.att);
    if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
    e.forEach((t)=>{
        const n = r.att[t];
        if (Array.isArray(n)) throw new Error(`Resource must be an object: ${t}`);
        if (typeof n != "object") throw new Error(`Resource must be an object: ${t}`);
        if (!Object.keys(n).length) throw new Error(`Resource object is empty: ${t}`);
        Object.keys(n).forEach((s)=>{
            const i = n[s];
            if (!Array.isArray(i)) throw new Error(`Ability limits ${s} must be an array of objects, found: ${i}`);
            if (!i.length) throw new Error(`Value of ${s} is empty array, must be an array with objects`);
            i.forEach((o)=>{
                if (typeof o != "object") throw new Error(`Ability limits (${s}) must be an array of objects, found: ${o}`);
            });
        });
    });
}
function h3(r, e, t, n = {}) {
    return t == null || t.sort((s, i)=>s.localeCompare(i)), {
        att: {
            [r]: f3(e, t, n)
        }
    };
}
function f3(r, e, t = {}) {
    e = e == null ? void 0 : e.sort((s, i)=>s.localeCompare(i));
    const n = e.map((s)=>({
            [`${r}/${s}`]: [
                t
            ]
        }));
    return Object.assign({}, ...n);
}
function qm(r) {
    return Ii(r), `urn:recap:${l3(r).replace(/=/g, "")}`;
}
function ho(r) {
    const e = d3(r.replace("urn:recap:", ""));
    return Ii(e), e;
}
function p3(r, e, t) {
    const n = h3(r, e, t);
    return qm(n);
}
function g3(r) {
    return r && r.includes("urn:recap:");
}
function y3(r, e) {
    const t = ho(r), n = ho(e), s = w3(t, n);
    return qm(s);
}
function w3(r, e) {
    Ii(r), Ii(e);
    const t = Object.keys(r.att).concat(Object.keys(e.att)).sort((s, i)=>s.localeCompare(i)), n = {
        att: {}
    };
    return t.forEach((s)=>{
        var i, o;
        Object.keys(((i = r.att) == null ? void 0 : i[s]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[s]) || {})).sort((a, u)=>a.localeCompare(u)).forEach((a)=>{
            var u, c;
            n.att[s] = a3(o3({}, n.att[s]), {
                [a]: ((u = r.att[s]) == null ? void 0 : u[a]) || ((c = e.att[s]) == null ? void 0 : c[a])
            });
        });
    }), n;
}
function m3(r = "", e) {
    Ii(e);
    const t = "I further authorize the stated URI to perform the following actions on my behalf: ";
    if (r.includes(t)) return r;
    const n = [];
    let s = 0;
    Object.keys(e.att).forEach((a)=>{
        const u = Object.keys(e.att[a]).map((d)=>({
                ability: d.split("/")[0],
                action: d.split("/")[1]
            }));
        u.sort((d, h)=>d.action.localeCompare(h.action));
        const c = {};
        u.forEach((d)=>{
            c[d.ability] || (c[d.ability] = []), c[d.ability].push(d.action);
        });
        const l = Object.keys(c).map((d)=>(s++, `(${s}) '${d}': '${c[d].join("', '")}' for '${a}'.`));
        n.push(l.join(", ").replace(".,", "."));
    });
    const i = n.join(" "), o = `${t}${i}`;
    return `${r ? r + " " : ""}${o}`;
}
function Rp(r) {
    var e;
    const t = ho(r);
    Ii(t);
    const n = (e = t.att) == null ? void 0 : e.eip155;
    return n ? Object.keys(n).map((s)=>s.split("/")[1]) : [];
}
function $p(r) {
    const e = ho(r);
    Ii(e);
    const t = [];
    return Object.values(e.att).forEach((n)=>{
        Object.values(n).forEach((s)=>{
            var i;
            (i = s == null ? void 0 : s[0]) != null && i.chains && t.push(s[0].chains);
        });
    }), [
        ...new Set(t.flat())
    ];
}
function Ea(r) {
    if (!r) return;
    const e = r == null ? void 0 : r[r.length - 1];
    return g3(e) ? e : void 0;
}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */ function Qm(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Bl(r) {
    if (typeof r != "boolean") throw new Error(`boolean expected, not ${r}`);
}
function Fu(r) {
    if (!Number.isSafeInteger(r) || r < 0) throw new Error("positive integer expected, got " + r);
}
function Xt(r, ...e) {
    if (!Qm(r)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function Bp(r, e = !0) {
    if (r.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function b3(r, e) {
    Xt(r);
    const t = e.outputLen;
    if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
function Hn(r) {
    return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function cs(...r) {
    for(let e = 0; e < r.length; e++)r[e].fill(0);
}
function v3(r) {
    return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
const E3 = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
function M3(r) {
    if (typeof r != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(r));
}
function Fl(r) {
    if (typeof r == "string") r = M3(r);
    else if (Qm(r)) r = ql(r);
    else throw new Error("Uint8Array expected, got " + typeof r);
    return r;
}
function N3(r, e) {
    if (e == null || typeof e != "object") throw new Error("options must be defined");
    return Object.assign(r, e);
}
function x3(r, e) {
    if (r.length !== e.length) return !1;
    let t = 0;
    for(let n = 0; n < r.length; n++)t |= r[n] ^ e[n];
    return t === 0;
}
const I3 = (r, e)=>{
    function t(n, ...s) {
        if (Xt(n), !E3) throw new Error("Non little-endian hardware is not yet supported");
        if (r.nonceLength !== void 0) {
            const c = s[0];
            if (!c) throw new Error("nonce / iv required");
            r.varSizeNonce ? Xt(c) : Xt(c, r.nonceLength);
        }
        const i = r.tagLength;
        i && s[1] !== void 0 && Xt(s[1]);
        const o = e(n, ...s), a = (c, l)=>{
            if (l !== void 0) {
                if (c !== 2) throw new Error("cipher output not supported");
                Xt(l);
            }
        };
        let u = !1;
        return {
            encrypt (c, l) {
                if (u) throw new Error("cannot encrypt() twice with same key + nonce");
                return u = !0, Xt(c), a(o.encrypt.length, l), o.encrypt(c, l);
            },
            decrypt (c, l) {
                if (Xt(c), i && c.length < i) throw new Error("invalid ciphertext length: smaller than tagLength=" + i);
                return a(o.decrypt.length, l), o.decrypt(c, l);
            }
        };
    }
    return Object.assign(t, r), t;
};
function Fp(r, e, t = !0) {
    if (e === void 0) return new Uint8Array(r);
    if (e.length !== r) throw new Error("invalid output length, expected " + r + ", got: " + e.length);
    if (t && !D3(e)) throw new Error("invalid output, must be aligned");
    return e;
}
function qp(r, e, t, n) {
    if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
    const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i);
    r.setUint32(e + 4, o, n), r.setUint32(e + 0, a, n);
}
function T3(r, e, t) {
    Bl(t);
    const n = new Uint8Array(16), s = v3(n);
    return qp(s, 0, BigInt(e), t), qp(s, 8, BigInt(r), t), n;
}
function D3(r) {
    return r.byteOffset % 4 === 0;
}
function ql(r) {
    return Uint8Array.from(r);
}
const Vm = (r)=>Uint8Array.from(r.split("").map((e)=>e.charCodeAt(0))), _3 = Vm("expand 16-byte k"), A3 = Vm("expand 32-byte k"), S3 = Hn(_3), O3 = Hn(A3);
function Le(r, e) {
    return r << e | r >>> 32 - e;
}
function Ql(r) {
    return r.byteOffset % 4 === 0;
}
const Jo = 64, j3 = 16, Ym = 2 ** 32 - 1, Qp = new Uint32Array();
function C3(r, e, t, n, s, i, o, a) {
    const u = s.length, c = new Uint8Array(Jo), l = Hn(c), d = Ql(s) && Ql(i), h = d ? Hn(s) : Qp, f = d ? Hn(i) : Qp;
    for(let g = 0; g < u; o++){
        if (r(e, t, n, l, o, a), o >= Ym) throw new Error("arx: counter overflow");
        const p = Math.min(Jo, u - g);
        if (d && p === Jo) {
            const m = g / 4;
            if (g % 4 !== 0) throw new Error("arx: invalid block position");
            for(let x = 0, _; x < j3; x++)_ = m + x, f[_] = h[_] ^ l[x];
            g += Jo;
            continue;
        }
        for(let m = 0, x; m < p; m++)x = g + m, i[x] = s[x] ^ c[m];
        g += p;
    }
}
function L3(r, e) {
    const { allowShortKeys: t, extendNonceFn: n, counterLength: s, counterRight: i, rounds: o } = N3({
        allowShortKeys: !1,
        counterLength: 8,
        counterRight: !1,
        rounds: 20
    }, e);
    if (typeof r != "function") throw new Error("core must be a function");
    return Fu(s), Fu(o), Bl(i), Bl(t), (a, u, c, l, d = 0)=>{
        Xt(a), Xt(u), Xt(c);
        const h = c.length;
        if (l === void 0 && (l = new Uint8Array(h)), Xt(l), Fu(d), d < 0 || d >= Ym) throw new Error("arx: counter overflow");
        if (l.length < h) throw new Error(`arx: output (${l.length}) is shorter than data (${h})`);
        const f = [];
        let g = a.length, p, m;
        if (g === 32) f.push(p = ql(a)), m = O3;
        else if (g === 16 && t) p = new Uint8Array(32), p.set(a), p.set(a, 16), m = S3, f.push(p);
        else throw new Error(`arx: invalid 32-byte key, got length=${g}`);
        Ql(u) || f.push(u = ql(u));
        const x = Hn(p);
        if (n) {
            if (u.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
            n(m, x, Hn(u.subarray(0, 16)), x), u = u.subarray(16);
        }
        const _ = 16 - s;
        if (_ !== u.length) throw new Error(`arx: nonce must be ${_} or 16 bytes`);
        if (_ !== 12) {
            const N = new Uint8Array(12);
            N.set(u, i ? 0 : 12 - u.length), u = N, f.push(u);
        }
        const v = Hn(u);
        return C3(r, m, x, v, c, l, d, o), cs(...f), l;
    };
}
const xt = (r, e)=>r[e++] & 255 | (r[e++] & 255) << 8;
class k3 {
    constructor(e){
        this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = Fl(e), Xt(e, 32);
        const t = xt(e, 0), n = xt(e, 2), s = xt(e, 4), i = xt(e, 6), o = xt(e, 8), a = xt(e, 10), u = xt(e, 12), c = xt(e, 14);
        this.r[0] = t & 8191, this.r[1] = (t >>> 13 | n << 3) & 8191, this.r[2] = (n >>> 10 | s << 6) & 7939, this.r[3] = (s >>> 7 | i << 9) & 8191, this.r[4] = (i >>> 4 | o << 12) & 255, this.r[5] = o >>> 1 & 8190, this.r[6] = (o >>> 14 | a << 2) & 8191, this.r[7] = (a >>> 11 | u << 5) & 8065, this.r[8] = (u >>> 8 | c << 8) & 8191, this.r[9] = c >>> 5 & 127;
        for(let l = 0; l < 8; l++)this.pad[l] = xt(e, 16 + 2 * l);
    }
    process(e, t, n = !1) {
        const s = n ? 0 : 2048, { h: i, r: o } = this, a = o[0], u = o[1], c = o[2], l = o[3], d = o[4], h = o[5], f = o[6], g = o[7], p = o[8], m = o[9], x = xt(e, t + 0), _ = xt(e, t + 2), v = xt(e, t + 4), N = xt(e, t + 6), O = xt(e, t + 8), z = xt(e, t + 10), P = xt(e, t + 12), U = xt(e, t + 14);
        let R = i[0] + (x & 8191), G = i[1] + ((x >>> 13 | _ << 3) & 8191), F = i[2] + ((_ >>> 10 | v << 6) & 8191), H = i[3] + ((v >>> 7 | N << 9) & 8191), B = i[4] + ((N >>> 4 | O << 12) & 8191), C = i[5] + (O >>> 1 & 8191), T = i[6] + ((O >>> 14 | z << 2) & 8191), I = i[7] + ((z >>> 11 | P << 5) & 8191), y = i[8] + ((P >>> 8 | U << 8) & 8191), w = i[9] + (U >>> 5 | s), M = 0, D = M + R * a + G * (5 * m) + F * (5 * p) + H * (5 * g) + B * (5 * f);
        M = D >>> 13, D &= 8191, D += C * (5 * h) + T * (5 * d) + I * (5 * l) + y * (5 * c) + w * (5 * u), M += D >>> 13, D &= 8191;
        let A = M + R * u + G * a + F * (5 * m) + H * (5 * p) + B * (5 * g);
        M = A >>> 13, A &= 8191, A += C * (5 * f) + T * (5 * h) + I * (5 * d) + y * (5 * l) + w * (5 * c), M += A >>> 13, A &= 8191;
        let L = M + R * c + G * u + F * a + H * (5 * m) + B * (5 * p);
        M = L >>> 13, L &= 8191, L += C * (5 * g) + T * (5 * f) + I * (5 * h) + y * (5 * d) + w * (5 * l), M += L >>> 13, L &= 8191;
        let V = M + R * l + G * c + F * u + H * a + B * (5 * m);
        M = V >>> 13, V &= 8191, V += C * (5 * p) + T * (5 * g) + I * (5 * f) + y * (5 * h) + w * (5 * d), M += V >>> 13, V &= 8191;
        let Y = M + R * d + G * l + F * c + H * u + B * a;
        M = Y >>> 13, Y &= 8191, Y += C * (5 * m) + T * (5 * p) + I * (5 * g) + y * (5 * f) + w * (5 * h), M += Y >>> 13, Y &= 8191;
        let K = M + R * h + G * d + F * l + H * c + B * u;
        M = K >>> 13, K &= 8191, K += C * a + T * (5 * m) + I * (5 * p) + y * (5 * g) + w * (5 * f), M += K >>> 13, K &= 8191;
        let J = M + R * f + G * h + F * d + H * l + B * c;
        M = J >>> 13, J &= 8191, J += C * u + T * a + I * (5 * m) + y * (5 * p) + w * (5 * g), M += J >>> 13, J &= 8191;
        let ne = M + R * g + G * f + F * h + H * d + B * l;
        M = ne >>> 13, ne &= 8191, ne += C * c + T * u + I * a + y * (5 * m) + w * (5 * p), M += ne >>> 13, ne &= 8191;
        let ie = M + R * p + G * g + F * f + H * h + B * d;
        M = ie >>> 13, ie &= 8191, ie += C * l + T * c + I * u + y * a + w * (5 * m), M += ie >>> 13, ie &= 8191;
        let oe = M + R * m + G * p + F * g + H * f + B * h;
        M = oe >>> 13, oe &= 8191, oe += C * d + T * l + I * c + y * u + w * a, M += oe >>> 13, oe &= 8191, M = (M << 2) + M | 0, M = M + D | 0, D = M & 8191, M = M >>> 13, A += M, i[0] = D, i[1] = A, i[2] = L, i[3] = V, i[4] = Y, i[5] = K, i[6] = J, i[7] = ne, i[8] = ie, i[9] = oe;
    }
    finalize() {
        const { h: e, pad: t } = this, n = new Uint16Array(10);
        let s = e[1] >>> 13;
        e[1] &= 8191;
        for(let a = 2; a < 10; a++)e[a] += s, s = e[a] >>> 13, e[a] &= 8191;
        e[0] += s * 5, s = e[0] >>> 13, e[0] &= 8191, e[1] += s, s = e[1] >>> 13, e[1] &= 8191, e[2] += s, n[0] = e[0] + 5, s = n[0] >>> 13, n[0] &= 8191;
        for(let a = 1; a < 10; a++)n[a] = e[a] + s, s = n[a] >>> 13, n[a] &= 8191;
        n[9] -= 8192;
        let i = (s ^ 1) - 1;
        for(let a = 0; a < 10; a++)n[a] &= i;
        i = ~i;
        for(let a = 0; a < 10; a++)e[a] = e[a] & i | n[a];
        e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
        let o = e[0] + t[0];
        e[0] = o & 65535;
        for(let a = 1; a < 8; a++)o = (e[a] + t[a] | 0) + (o >>> 16) | 0, e[a] = o & 65535;
        cs(n);
    }
    update(e) {
        Bp(this), e = Fl(e), Xt(e);
        const { buffer: t, blockLen: n } = this, s = e.length;
        for(let i = 0; i < s;){
            const o = Math.min(n - this.pos, s - i);
            if (o === n) {
                for(; n <= s - i; i += n)this.process(e, i);
                continue;
            }
            t.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === n && (this.process(t, 0, !1), this.pos = 0);
        }
        return this;
    }
    destroy() {
        cs(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(e) {
        Bp(this), b3(e, this), this.finished = !0;
        const { buffer: t, h: n } = this;
        let { pos: s } = this;
        if (s) {
            for(t[s++] = 1; s < 16; s++)t[s] = 0;
            this.process(t, 0, !0);
        }
        this.finalize();
        let i = 0;
        for(let o = 0; o < 8; o++)e[i++] = n[o] >>> 0, e[i++] = n[o] >>> 8;
        return e;
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const n = e.slice(0, t);
        return this.destroy(), n;
    }
}
function z3(r) {
    const e = (n, s)=>r(s).update(Fl(n)).digest(), t = r(new Uint8Array(32));
    return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (n)=>r(n), e;
}
const P3 = z3((r)=>new k3(r));
function U3(r, e, t, n, s, i = 20) {
    let o = r[0], a = r[1], u = r[2], c = r[3], l = e[0], d = e[1], h = e[2], f = e[3], g = e[4], p = e[5], m = e[6], x = e[7], _ = s, v = t[0], N = t[1], O = t[2], z = o, P = a, U = u, R = c, G = l, F = d, H = h, B = f, C = g, T = p, I = m, y = x, w = _, M = v, D = N, A = O;
    for(let V = 0; V < i; V += 2)z = z + G | 0, w = Le(w ^ z, 16), C = C + w | 0, G = Le(G ^ C, 12), z = z + G | 0, w = Le(w ^ z, 8), C = C + w | 0, G = Le(G ^ C, 7), P = P + F | 0, M = Le(M ^ P, 16), T = T + M | 0, F = Le(F ^ T, 12), P = P + F | 0, M = Le(M ^ P, 8), T = T + M | 0, F = Le(F ^ T, 7), U = U + H | 0, D = Le(D ^ U, 16), I = I + D | 0, H = Le(H ^ I, 12), U = U + H | 0, D = Le(D ^ U, 8), I = I + D | 0, H = Le(H ^ I, 7), R = R + B | 0, A = Le(A ^ R, 16), y = y + A | 0, B = Le(B ^ y, 12), R = R + B | 0, A = Le(A ^ R, 8), y = y + A | 0, B = Le(B ^ y, 7), z = z + F | 0, A = Le(A ^ z, 16), I = I + A | 0, F = Le(F ^ I, 12), z = z + F | 0, A = Le(A ^ z, 8), I = I + A | 0, F = Le(F ^ I, 7), P = P + H | 0, w = Le(w ^ P, 16), y = y + w | 0, H = Le(H ^ y, 12), P = P + H | 0, w = Le(w ^ P, 8), y = y + w | 0, H = Le(H ^ y, 7), U = U + B | 0, M = Le(M ^ U, 16), C = C + M | 0, B = Le(B ^ C, 12), U = U + B | 0, M = Le(M ^ U, 8), C = C + M | 0, B = Le(B ^ C, 7), R = R + G | 0, D = Le(D ^ R, 16), T = T + D | 0, G = Le(G ^ T, 12), R = R + G | 0, D = Le(D ^ R, 8), T = T + D | 0, G = Le(G ^ T, 7);
    let L = 0;
    n[L++] = o + z | 0, n[L++] = a + P | 0, n[L++] = u + U | 0, n[L++] = c + R | 0, n[L++] = l + G | 0, n[L++] = d + F | 0, n[L++] = h + H | 0, n[L++] = f + B | 0, n[L++] = g + C | 0, n[L++] = p + T | 0, n[L++] = m + I | 0, n[L++] = x + y | 0, n[L++] = _ + w | 0, n[L++] = v + M | 0, n[L++] = N + D | 0, n[L++] = O + A | 0;
}
const R3 = L3(U3, {
    counterRight: !1,
    counterLength: 4,
    allowShortKeys: !1
}), $3 = new Uint8Array(16), Vp = (r, e)=>{
    r.update(e);
    const t = e.length % 16;
    t && r.update($3.subarray(t));
}, B3 = new Uint8Array(32);
function Yp(r, e, t, n, s) {
    const i = r(e, t, B3), o = P3.create(i);
    s && Vp(o, s), Vp(o, n);
    const a = T3(n.length, s ? s.length : 0, !0);
    o.update(a);
    const u = o.digest();
    return cs(i, a), u;
}
const F3 = (r)=>(e, t, n)=>({
            encrypt (s, i) {
                const o = s.length;
                i = Fp(o + 16, i, !1), i.set(s);
                const a = i.subarray(0, -16);
                r(e, t, a, a, 1);
                const u = Yp(r, e, t, a, n);
                return i.set(u, o), cs(u), i;
            },
            decrypt (s, i) {
                i = Fp(s.length - 16, i, !1);
                const o = s.subarray(0, -16), a = s.subarray(-16), u = Yp(r, e, t, o, n);
                if (!x3(a, u)) throw new Error("invalid tag");
                return i.set(s.subarray(0, -16)), r(e, t, i, i, 1), cs(u), i;
            }
        }), Gm = I3({
    blockSize: 64,
    nonceLength: 12,
    tagLength: 16
}, F3(R3));
let Hm = class extends Bc {
    constructor(e, t){
        super(), this.finished = !1, this.destroyed = !1, $c(e);
        const n = Ar(t);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const s = this.blockLen, i = new Uint8Array(s);
        i.set(n.length > s ? e.create().update(n).digest() : n);
        for(let o = 0; o < i.length; o++)i[o] ^= 54;
        this.iHash.update(i), this.oHash = e.create();
        for(let o = 0; o < i.length; o++)i[o] ^= 106;
        this.oHash.update(i), br(i);
    }
    update(e) {
        return Kn(this), this.iHash.update(e), this;
    }
    digestInto(e) {
        Kn(this), Sr(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: t, iHash: n, finished: s, destroyed: i, blockLen: o, outputLen: a } = this;
        return e = e, e.finished = s, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
};
const qc = (r, e, t)=>new Hm(r, e).update(t).digest();
qc.create = (r, e)=>new Hm(r, e);
function q3(r, e, t) {
    return $c(r), t === void 0 && (t = new Uint8Array(r.outputLen)), qc(r, Ar(t), Ar(e));
}
const qu = Uint8Array.from([
    0
]), Gp = Uint8Array.of();
function Q3(r, e, t, n = 32) {
    $c(r), yn(n);
    const s = r.outputLen;
    if (n > 255 * s) throw new Error("Length should be <= 255*HashLen");
    const i = Math.ceil(n / s);
    t === void 0 && (t = Gp);
    const o = new Uint8Array(i * s), a = qc.create(r, e), u = a._cloneInto(), c = new Uint8Array(a.outputLen);
    for(let l = 0; l < i; l++)qu[0] = l + 1, u.update(l === 0 ? Gp : c).update(t).update(qu).digestInto(c), o.set(c, s * l), a._cloneInto(u);
    return a.destroy(), u.destroy(), br(c, qu), o.slice(0, n);
}
const V3 = (r, e, t, n, s)=>Q3(r, q3(r, e, t), n, s), Qc = Fc, ih = BigInt(0), Vl = BigInt(1);
function Fa(r, e = "") {
    if (typeof r != "boolean") {
        const t = e && `"${e}"`;
        throw new Error(t + "expected boolean, got type=" + typeof r);
    }
    return r;
}
function wi(r, e, t = "") {
    const n = Rc(r), s = r == null ? void 0 : r.length, i = e !== void 0;
    if (!n || i && s !== e) {
        const o = t && `"${t}" `, a = i ? ` of length ${e}` : "", u = n ? `length=${s}` : `type=${typeof r}`;
        throw new Error(o + "expected Uint8Array" + a + ", got " + u);
    }
    return r;
}
function ea(r) {
    const e = r.toString(16);
    return e.length & 1 ? "0" + e : e;
}
function Wm(r) {
    if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
    return r === "" ? ih : BigInt("0x" + r);
}
function Vc(r) {
    return Wm(ts(r));
}
function qa(r) {
    return Sr(r), Wm(ts(Uint8Array.from(r).reverse()));
}
function sh(r, e) {
    return $a(r.toString(16).padStart(e * 2, "0"));
}
function oh(r, e) {
    return sh(r, e).reverse();
}
function Rt(r, e, t) {
    let n;
    if (typeof e == "string") try {
        n = $a(e);
    } catch (i) {
        throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
    }
    else if (Rc(e)) n = Uint8Array.from(e);
    else throw new Error(r + " must be hex string or Uint8Array");
    const s = n.length;
    if (typeof t == "number" && s !== t) throw new Error(r + " of length " + t + " expected, got " + s);
    return n;
}
const Qu = (r)=>typeof r == "bigint" && ih <= r;
function Y3(r, e, t) {
    return Qu(r) && Qu(e) && Qu(t) && e <= r && r < t;
}
function Yl(r, e, t, n) {
    if (!Y3(e, t, n)) throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function Km(r) {
    let e;
    for(e = 0; r > ih; r >>= Vl, e += 1);
    return e;
}
const xo = (r)=>(Vl << BigInt(r)) - Vl;
function G3(r, e, t) {
    if (typeof r != "number" || r < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof t != "function") throw new Error("hmacFn must be a function");
    const n = (h)=>new Uint8Array(h), s = (h)=>Uint8Array.of(h);
    let i = n(r), o = n(r), a = 0;
    const u = ()=>{
        i.fill(1), o.fill(0), a = 0;
    }, c = (...h)=>t(o, i, ...h), l = (h = n(0))=>{
        o = c(s(0), h), i = c(), h.length !== 0 && (o = c(s(1), h), i = c());
    }, d = ()=>{
        if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let h = 0;
        const f = [];
        for(; h < e;){
            i = c();
            const g = i.slice();
            f.push(g), h += i.length;
        }
        return Fn(...f);
    };
    return (h, f)=>{
        u(), l(h);
        let g;
        for(; !(g = f(d()));)l();
        return u(), g;
    };
}
function Yc(r, e, t = {}) {
    if (!r || typeof r != "object") throw new Error("expected valid options object");
    function n(s, i, o) {
        const a = r[s];
        if (o && a === void 0) return;
        const u = typeof a;
        if (u !== i || a === null) throw new Error(`param "${s}" is invalid: expected ${i}, got ${u}`);
    }
    Object.entries(e).forEach(([s, i])=>n(s, i, !1)), Object.entries(t).forEach(([s, i])=>n(s, i, !0));
}
function Hp(r) {
    const e = /* @__PURE__ */ new WeakMap();
    return (t, ...n)=>{
        const s = e.get(t);
        if (s !== void 0) return s;
        const i = r(t, ...n);
        return e.set(t, i), i;
    };
}
const er = BigInt(0), Ft = BigInt(1), mi = BigInt(2), Xm = BigInt(3), Zm = BigInt(4), Jm = BigInt(5), H3 = BigInt(7), e1 = BigInt(8), W3 = BigInt(9), t1 = BigInt(16);
function ar(r, e) {
    const t = r % e;
    return t >= er ? t : e + t;
}
function Tr(r, e, t) {
    let n = r;
    for(; e-- > er;)n *= n, n %= t;
    return n;
}
function Wp(r, e) {
    if (r === er) throw new Error("invert: expected non-zero number");
    if (e <= er) throw new Error("invert: expected positive modulus, got " + e);
    let t = ar(r, e), n = e, s = er, i = Ft;
    for(; t !== er;){
        const o = n / t, a = n % t, u = s - i * o;
        n = t, t = a, s = i, i = u;
    }
    if (n !== Ft) throw new Error("invert: does not exist");
    return ar(s, e);
}
function ah(r, e, t) {
    if (!r.eql(r.sqr(e), t)) throw new Error("Cannot find square root");
}
function r1(r, e) {
    const t = (r.ORDER + Ft) / Zm, n = r.pow(e, t);
    return ah(r, n, e), n;
}
function K3(r, e) {
    const t = (r.ORDER - Jm) / e1, n = r.mul(e, mi), s = r.pow(n, t), i = r.mul(e, s), o = r.mul(r.mul(i, mi), s), a = r.mul(i, r.sub(o, r.ONE));
    return ah(r, a, e), a;
}
function X3(r) {
    const e = Zn(r), t = n1(r), n = t(e, e.neg(e.ONE)), s = t(e, n), i = t(e, e.neg(n)), o = (r + H3) / t1;
    return (a, u)=>{
        let c = a.pow(u, o), l = a.mul(c, n);
        const d = a.mul(c, s), h = a.mul(c, i), f = a.eql(a.sqr(l), u), g = a.eql(a.sqr(d), u);
        c = a.cmov(c, l, f), l = a.cmov(h, d, g);
        const p = a.eql(a.sqr(l), u), m = a.cmov(c, l, p);
        return ah(a, m, u), m;
    };
}
function n1(r) {
    if (r < Xm) throw new Error("sqrt is not defined for small field");
    let e = r - Ft, t = 0;
    for(; e % mi === er;)e /= mi, t++;
    let n = mi;
    const s = Zn(r);
    for(; Kp(s, n) === 1;)if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (t === 1) return r1;
    let i = s.pow(n, e);
    const o = (e + Ft) / mi;
    return function(a, u) {
        if (a.is0(u)) return u;
        if (Kp(a, u) !== 1) throw new Error("Cannot find square root");
        let c = t, l = a.mul(a.ONE, i), d = a.pow(u, e), h = a.pow(u, o);
        for(; !a.eql(d, a.ONE);){
            if (a.is0(d)) return a.ZERO;
            let f = 1, g = a.sqr(d);
            for(; !a.eql(g, a.ONE);)if (f++, g = a.sqr(g), f === c) throw new Error("Cannot find square root");
            const p = Ft << BigInt(c - f - 1), m = a.pow(l, p);
            c = f, l = a.sqr(m), d = a.mul(d, l), h = a.mul(h, m);
        }
        return h;
    };
}
function Z3(r) {
    return r % Zm === Xm ? r1 : r % e1 === Jm ? K3 : r % t1 === W3 ? X3(r) : n1(r);
}
const J3 = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function ej(r) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, t = J3.reduce((n, s)=>(n[s] = "function", n), e);
    return Yc(r, t), r;
}
function tj(r, e, t) {
    if (t < er) throw new Error("invalid exponent, negatives unsupported");
    if (t === er) return r.ONE;
    if (t === Ft) return e;
    let n = r.ONE, s = e;
    for(; t > er;)t & Ft && (n = r.mul(n, s)), s = r.sqr(s), t >>= Ft;
    return n;
}
function i1(r, e, t = !1) {
    const n = new Array(e.length).fill(t ? r.ZERO : void 0), s = e.reduce((o, a, u)=>r.is0(a) ? o : (n[u] = o, r.mul(o, a)), r.ONE), i = r.inv(s);
    return e.reduceRight((o, a, u)=>r.is0(a) ? o : (n[u] = r.mul(o, n[u]), r.mul(o, a)), i), n;
}
function Kp(r, e) {
    const t = (r.ORDER - Ft) / mi, n = r.pow(e, t), s = r.eql(n, r.ONE), i = r.eql(n, r.ZERO), o = r.eql(n, r.neg(r.ONE));
    if (!s && !i && !o) throw new Error("invalid Legendre symbol result");
    return s ? 1 : i ? 0 : -1;
}
function s1(r, e) {
    e !== void 0 && yn(e);
    const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: n
    };
}
function Zn(r, e, t = !1, n = {}) {
    if (r <= er) throw new Error("invalid field: expected ORDER > 0, got " + r);
    let s, i, o = !1, a;
    if (typeof e == "object" && e != null) {
        if (n.sqrt || t) throw new Error("cannot specify opts in two arguments");
        const h = e;
        h.BITS && (s = h.BITS), h.sqrt && (i = h.sqrt), typeof h.isLE == "boolean" && (t = h.isLE), typeof h.modFromBytes == "boolean" && (o = h.modFromBytes), a = h.allowedLengths;
    } else typeof e == "number" && (s = e), n.sqrt && (i = n.sqrt);
    const { nBitLength: u, nByteLength: c } = s1(r, s);
    if (c > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let l;
    const d = Object.freeze({
        ORDER: r,
        isLE: t,
        BITS: u,
        BYTES: c,
        MASK: xo(u),
        ZERO: er,
        ONE: Ft,
        allowedLengths: a,
        create: (h)=>ar(h, r),
        isValid: (h)=>{
            if (typeof h != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof h);
            return er <= h && h < r;
        },
        is0: (h)=>h === er,
        isValidNot0: (h)=>!d.is0(h) && d.isValid(h),
        isOdd: (h)=>(h & Ft) === Ft,
        neg: (h)=>ar(-h, r),
        eql: (h, f)=>h === f,
        sqr: (h)=>ar(h * h, r),
        add: (h, f)=>ar(h + f, r),
        sub: (h, f)=>ar(h - f, r),
        mul: (h, f)=>ar(h * f, r),
        pow: (h, f)=>tj(d, h, f),
        div: (h, f)=>ar(h * Wp(f, r), r),
        sqrN: (h)=>h * h,
        addN: (h, f)=>h + f,
        subN: (h, f)=>h - f,
        mulN: (h, f)=>h * f,
        inv: (h)=>Wp(h, r),
        sqrt: i || ((h)=>(l || (l = Z3(r)), l(d, h))),
        toBytes: (h)=>t ? oh(h, c) : sh(h, c),
        fromBytes: (h, f = !0)=>{
            if (a) {
                if (!a.includes(h.length) || h.length > c) throw new Error("Field.fromBytes: expected " + a + " bytes, got " + h.length);
                const p = new Uint8Array(c);
                p.set(h, t ? 0 : p.length - h.length), h = p;
            }
            if (h.length !== c) throw new Error("Field.fromBytes: expected " + c + " bytes, got " + h.length);
            let g = t ? qa(h) : Vc(h);
            if (o && (g = ar(g, r)), !f && !d.isValid(g)) throw new Error("invalid field element: outside of range 0..ORDER");
            return g;
        },
        invertBatch: (h)=>i1(d, h),
        cmov: (h, f, g)=>g ? f : h
    });
    return Object.freeze(d);
}
function o1(r) {
    if (typeof r != "bigint") throw new Error("field order must be bigint");
    const e = r.toString(2).length;
    return Math.ceil(e / 8);
}
function a1(r) {
    const e = o1(r);
    return e + Math.ceil(e / 2);
}
function rj(r, e, t = !1) {
    const n = r.length, s = o1(e), i = a1(e);
    if (n < 16 || n < i || n > 1024) throw new Error("expected " + i + "-1024 bytes of input, got " + n);
    const o = t ? qa(r) : Vc(r), a = ar(o, e - Ft) + Ft;
    return t ? oh(a, s) : sh(a, s);
}
const us = BigInt(0), bi = BigInt(1);
function Qa(r, e) {
    const t = e.negate();
    return r ? t : e;
}
function Vu(r, e) {
    const t = i1(r.Fp, e.map((n)=>n.Z));
    return e.map((n, s)=>r.fromAffine(n.toAffine(t[s])));
}
function c1(r, e) {
    if (!Number.isSafeInteger(r) || r <= 0 || r > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function Yu(r, e) {
    c1(r, e);
    const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1), s = 2 ** r, i = xo(r), o = BigInt(r);
    return {
        windows: t,
        windowSize: n,
        mask: i,
        maxNumber: s,
        shiftBy: o
    };
}
function Xp(r, e, t) {
    const { windowSize: n, mask: s, maxNumber: i, shiftBy: o } = t;
    let a = Number(r & s), u = r >> o;
    a > n && (a -= i, u += bi);
    const c = e * n, l = c + Math.abs(a) - 1, d = a === 0, h = a < 0, f = e % 2 !== 0;
    return {
        nextN: u,
        offset: l,
        isZero: d,
        isNeg: h,
        isNegF: f,
        offsetF: c
    };
}
function nj(r, e) {
    if (!Array.isArray(r)) throw new Error("array expected");
    r.forEach((t, n)=>{
        if (!(t instanceof e)) throw new Error("invalid point at index " + n);
    });
}
function ij(r, e) {
    if (!Array.isArray(r)) throw new Error("array of scalars expected");
    r.forEach((t, n)=>{
        if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
    });
}
const Gu = /* @__PURE__ */ new WeakMap(), u1 = /* @__PURE__ */ new WeakMap();
function Hu(r) {
    return u1.get(r) || 1;
}
function Zp(r) {
    if (r !== us) throw new Error("invalid wNAF");
}
class sj {
    constructor(e, t){
        this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = t;
    }
    _unsafeLadder(e, t, n = this.ZERO) {
        let s = e;
        for(; t > us;)t & bi && (n = n.add(s)), s = s.double(), t >>= bi;
        return n;
    }
    precomputeWindow(e, t) {
        const { windows: n, windowSize: s } = Yu(t, this.bits), i = [];
        let o = e, a = o;
        for(let u = 0; u < n; u++){
            a = o, i.push(a);
            for(let c = 1; c < s; c++)a = a.add(o), i.push(a);
            o = a.double();
        }
        return i;
    }
    wNAF(e, t, n) {
        if (!this.Fn.isValid(n)) throw new Error("invalid scalar");
        let s = this.ZERO, i = this.BASE;
        const o = Yu(e, this.bits);
        for(let a = 0; a < o.windows; a++){
            const { nextN: u, offset: c, isZero: l, isNeg: d, isNegF: h, offsetF: f } = Xp(n, a, o);
            n = u, l ? i = i.add(Qa(h, t[f])) : s = s.add(Qa(d, t[c]));
        }
        return Zp(n), {
            p: s,
            f: i
        };
    }
    wNAFUnsafe(e, t, n, s = this.ZERO) {
        const i = Yu(e, this.bits);
        for(let o = 0; o < i.windows && n !== us; o++){
            const { nextN: a, offset: u, isZero: c, isNeg: l } = Xp(n, o, i);
            if (n = a, !c) {
                const d = t[u];
                s = s.add(l ? d.negate() : d);
            }
        }
        return Zp(n), s;
    }
    getPrecomputes(e, t, n) {
        let s = Gu.get(t);
        return s || (s = this.precomputeWindow(t, e), e !== 1 && (typeof n == "function" && (s = n(s)), Gu.set(t, s))), s;
    }
    cached(e, t, n) {
        const s = Hu(e);
        return this.wNAF(s, this.getPrecomputes(s, e, n), t);
    }
    unsafe(e, t, n, s) {
        const i = Hu(e);
        return i === 1 ? this._unsafeLadder(e, t, s) : this.wNAFUnsafe(i, this.getPrecomputes(i, e, n), t, s);
    }
    createCache(e, t) {
        c1(t, this.bits), u1.set(e, t), Gu.delete(e);
    }
    hasCache(e) {
        return Hu(e) !== 1;
    }
}
function oj(r, e, t, n) {
    let s = e, i = r.ZERO, o = r.ZERO;
    for(; t > us || n > us;)t & bi && (i = i.add(s)), n & bi && (o = o.add(s)), s = s.double(), t >>= bi, n >>= bi;
    return {
        p1: i,
        p2: o
    };
}
function aj(r, e, t, n) {
    nj(t, r), ij(n, e);
    const s = t.length, i = n.length;
    if (s !== i) throw new Error("arrays of points and scalars must have equal length");
    const o = r.ZERO, a = Km(BigInt(s));
    let u = 1;
    a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
    const c = xo(u), l = new Array(Number(c) + 1).fill(o), d = Math.floor((e.BITS - 1) / u) * u;
    let h = o;
    for(let f = d; f >= 0; f -= u){
        l.fill(o);
        for(let p = 0; p < i; p++){
            const m = n[p], x = Number(m >> BigInt(f) & c);
            l[x] = l[x].add(t[p]);
        }
        let g = o;
        for(let p = l.length - 1, m = o; p > 0; p--)m = m.add(l[p]), g = g.add(m);
        if (h = h.add(g), f !== 0) for(let p = 0; p < u; p++)h = h.double();
    }
    return h;
}
function Jp(r, e, t) {
    if (e) {
        if (e.ORDER !== r) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return ej(e), e;
    } else return Zn(r, {
        isLE: t
    });
}
function cj(r, e, t = {}, n) {
    if (n === void 0 && (n = r === "edwards"), !e || typeof e != "object") throw new Error(`expected valid ${r} CURVE object`);
    for (const a of [
        "p",
        "n",
        "h"
    ]){
        const u = e[a];
        if (!(typeof u == "bigint" && u > us)) throw new Error(`CURVE.${a} must be positive bigint`);
    }
    const s = Jp(e.p, t.Fp, n), i = Jp(e.n, t.Fn, n), o = [
        "Gx",
        "Gy",
        "a",
        "b"
    ];
    for (const a of o)if (!s.isValid(e[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return e = Object.freeze(Object.assign({}, e)), {
        CURVE: e,
        Fp: s,
        Fn: i
    };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8), Cm("HashToScalar-");
const Rs = BigInt(0), qi = BigInt(1), ta = BigInt(2);
function uj(r) {
    return Yc(r, {
        adjustScalarBytes: "function",
        powPminus2: "function"
    }), Object.freeze({
        ...r
    });
}
function lj(r) {
    const e = uj(r), { P: t, type: n, adjustScalarBytes: s, powPminus2: i, randomBytes: o } = e, a = n === "x25519";
    if (!a && n !== "x448") throw new Error("invalid type");
    const u = o || Li, c = a ? 255 : 448, l = a ? 32 : 56, d = BigInt(a ? 9 : 5), h = BigInt(a ? 121665 : 39081), f = a ? ta ** BigInt(254) : ta ** BigInt(447), g = a ? BigInt(8) * ta ** BigInt(251) - qi : BigInt(4) * ta ** BigInt(445) - qi, p = f + g + qi, m = (H)=>ar(H, t), x = _(d);
    function _(H) {
        return oh(m(H), l);
    }
    function v(H) {
        const B = Rt("u coordinate", H, l);
        return a && (B[31] &= 127), m(qa(B));
    }
    function N(H) {
        return qa(s(Rt("scalar", H, l)));
    }
    function O(H, B) {
        const C = U(v(B), N(H));
        if (C === Rs) throw new Error("invalid private or public key received");
        return _(C);
    }
    function z(H) {
        return O(H, x);
    }
    function P(H, B, C) {
        const T = m(H * (B - C));
        return B = m(B - T), C = m(C + T), {
            x_2: B,
            x_3: C
        };
    }
    function U(H, B) {
        Yl("u", H, Rs, t), Yl("scalar", B, f, p);
        const C = B, T = H;
        let I = qi, y = Rs, w = H, M = qi, D = Rs;
        for(let L = BigInt(c - 1); L >= Rs; L--){
            const V = C >> L & qi;
            D ^= V, ({ x_2: I, x_3: w } = P(D, I, w)), ({ x_2: y, x_3: M } = P(D, y, M)), D = V;
            const Y = I + y, K = m(Y * Y), J = I - y, ne = m(J * J), ie = K - ne, oe = w + M, le = w - M, fe = m(le * Y), Q = m(oe * J), Z = fe + Q, W = fe - Q;
            w = m(Z * Z), M = m(T * m(W * W)), I = m(K * ne), y = m(ie * (K + m(h * ie)));
        }
        ({ x_2: I, x_3: w } = P(D, I, w)), { x_2: y, x_3: M } = P(D, y, M);
        const A = i(y);
        return m(I * A);
    }
    const R = {
        secretKey: l,
        publicKey: l,
        seed: l
    }, G = (H = u(l))=>(Sr(H, R.seed), H);
    function F(H) {
        const B = G(H);
        return {
            secretKey: B,
            publicKey: z(B)
        };
    }
    return {
        keygen: F,
        getSharedSecret: (H, B)=>O(H, B),
        getPublicKey: (H)=>z(H),
        scalarMult: O,
        scalarMultBase: z,
        utils: {
            randomSecretKey: G,
            randomPrivateKey: G
        },
        GuBytes: x.slice(),
        lengths: R
    };
}
const dj = BigInt(1), eg = BigInt(2), hj = BigInt(3), fj = BigInt(5);
BigInt(8);
const l1 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), pj = {
    p: l1,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function gj(r) {
    const e = BigInt(10), t = BigInt(20), n = BigInt(40), s = BigInt(80), i = l1, o = r * r % i * r % i, a = Tr(o, eg, i) * o % i, u = Tr(a, dj, i) * r % i, c = Tr(u, fj, i) * u % i, l = Tr(c, e, i) * c % i, d = Tr(l, t, i) * l % i, h = Tr(d, n, i) * d % i, f = Tr(h, s, i) * h % i, g = Tr(f, s, i) * h % i, p = Tr(g, e, i) * c % i;
    return {
        pow_p_5_8: Tr(p, eg, i) * r % i,
        b2: o
    };
}
function yj(r) {
    return r[0] &= 248, r[31] &= 127, r[31] |= 64, r;
}
const wj = Zn(pj.p, {
    isLE: !0
}), Gl = (()=>{
    const r = wj.ORDER;
    return lj({
        P: r,
        type: "x25519",
        powPminus2: (e)=>{
            const { pow_p_5_8: t, b2: n } = gj(e);
            return ar(Tr(t, hj, r) * n, r);
        },
        adjustScalarBytes: yj
    });
})(), tg = (r, e)=>(r + (r >= 0 ? e : -e) / d1) / e;
function mj(r, e, t) {
    const [[n, s], [i, o]] = e, a = tg(o * r, t), u = tg(-s * r, t);
    let c = r - a * n - u * i, l = -a * s - u * o;
    const d = c < hn, h = l < hn;
    d && (c = -c), h && (l = -l);
    const f = xo(Math.ceil(Km(t) / 2)) + rs;
    if (c < hn || c >= f || l < hn || l >= f) throw new Error("splitScalar (endomorphism): failed, k=" + r);
    return {
        k1neg: d,
        k1: c,
        k2neg: h,
        k2: l
    };
}
function Hl(r) {
    if (![
        "compact",
        "recovered",
        "der"
    ].includes(r)) throw new Error('Signature format must be "compact", "recovered", or "der"');
    return r;
}
function Wu(r, e) {
    const t = {};
    for (let n of Object.keys(e))t[n] = r[n] === void 0 ? e[n] : r[n];
    return Fa(t.lowS, "lowS"), Fa(t.prehash, "prehash"), t.format !== void 0 && Hl(t.format), t;
}
class bj extends Error {
    constructor(e = ""){
        super(e);
    }
}
const un = {
    Err: bj,
    _tlv: {
        encode: (r, e)=>{
            const { Err: t } = un;
            if (r < 0 || r > 256) throw new t("tlv.encode: wrong tag");
            if (e.length & 1) throw new t("tlv.encode: unpadded data");
            const n = e.length / 2, s = ea(n);
            if (s.length / 2 & 128) throw new t("tlv.encode: long form length too big");
            const i = n > 127 ? ea(s.length / 2 | 128) : "";
            return ea(r) + i + s + e;
        },
        decode (r, e) {
            const { Err: t } = un;
            let n = 0;
            if (r < 0 || r > 256) throw new t("tlv.encode: wrong tag");
            if (e.length < 2 || e[n++] !== r) throw new t("tlv.decode: wrong tlv");
            const s = e[n++], i = !!(s & 128);
            let o = 0;
            if (!i) o = s;
            else {
                const u = s & 127;
                if (!u) throw new t("tlv.decode(long): indefinite length not supported");
                if (u > 4) throw new t("tlv.decode(long): byte length is too big");
                const c = e.subarray(n, n + u);
                if (c.length !== u) throw new t("tlv.decode: length bytes not complete");
                if (c[0] === 0) throw new t("tlv.decode(long): zero leftmost byte");
                for (const l of c)o = o << 8 | l;
                if (n += u, o < 128) throw new t("tlv.decode(long): not minimal encoding");
            }
            const a = e.subarray(n, n + o);
            if (a.length !== o) throw new t("tlv.decode: wrong value length");
            return {
                v: a,
                l: e.subarray(n + o)
            };
        }
    },
    _int: {
        encode (r) {
            const { Err: e } = un;
            if (r < hn) throw new e("integer: negative integers are not allowed");
            let t = ea(r);
            if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
            return t;
        },
        decode (r) {
            const { Err: e } = un;
            if (r[0] & 128) throw new e("invalid signature integer: negative");
            if (r[0] === 0 && !(r[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
            return Vc(r);
        }
    },
    toSig (r) {
        const { Err: e, _int: t, _tlv: n } = un, s = Rt("signature", r), { v: i, l: o } = n.decode(48, s);
        if (o.length) throw new e("invalid signature: left bytes after parsing");
        const { v: a, l: u } = n.decode(2, i), { v: c, l } = n.decode(2, u);
        if (l.length) throw new e("invalid signature: left bytes after parsing");
        return {
            r: t.decode(a),
            s: t.decode(c)
        };
    },
    hexFromSig (r) {
        const { _tlv: e, _int: t } = un, n = e.encode(2, t.encode(r.r)), s = e.encode(2, t.encode(r.s)), i = n + s;
        return e.encode(48, i);
    }
}, hn = BigInt(0), rs = BigInt(1), d1 = BigInt(2), ra = BigInt(3), vj = BigInt(4);
function Ki(r, e) {
    const { BYTES: t } = r;
    let n;
    if (typeof e == "bigint") n = e;
    else {
        let s = Rt("private key", e);
        try {
            n = r.fromBytes(s);
        } catch  {
            throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`);
        }
    }
    if (!r.isValidNot0(n)) throw new Error("invalid private key: out of range [1..N-1]");
    return n;
}
function Ej(r, e = {}) {
    const t = cj("weierstrass", r, e), { Fp: n, Fn: s } = t;
    let i = t.CURVE;
    const { h: o, n: a } = i;
    Yc(e, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const { endo: u } = e;
    if (u && (!n.is0(i.a) || typeof u.beta != "bigint" || !Array.isArray(u.basises))) throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    const c = f1(n, s);
    function l() {
        if (!n.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function d(H, B, C) {
        const { x: T, y: I } = B.toAffine(), y = n.toBytes(T);
        if (Fa(C, "isCompressed"), C) {
            l();
            const w = !n.isOdd(I);
            return Fn(h1(w), y);
        } else return Fn(Uint8Array.of(4), y, n.toBytes(I));
    }
    function h(H) {
        wi(H, void 0, "Point");
        const { publicKey: B, publicKeyUncompressed: C } = c, T = H.length, I = H[0], y = H.subarray(1);
        if (T === B && (I === 2 || I === 3)) {
            const w = n.fromBytes(y);
            if (!n.isValid(w)) throw new Error("bad point: is not on curve, wrong x");
            const M = p(w);
            let D;
            try {
                D = n.sqrt(M);
            } catch (L) {
                const V = L instanceof Error ? ": " + L.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + V);
            }
            l();
            const A = n.isOdd(D);
            return (I & 1) === 1 !== A && (D = n.neg(D)), {
                x: w,
                y: D
            };
        } else if (T === C && I === 4) {
            const w = n.BYTES, M = n.fromBytes(y.subarray(0, w)), D = n.fromBytes(y.subarray(w, w * 2));
            if (!m(M, D)) throw new Error("bad point: is not on curve");
            return {
                x: M,
                y: D
            };
        } else throw new Error(`bad point: got length ${T}, expected compressed=${B} or uncompressed=${C}`);
    }
    const f = e.toBytes || d, g = e.fromBytes || h;
    function p(H) {
        const B = n.sqr(H), C = n.mul(B, H);
        return n.add(n.add(C, n.mul(H, i.a)), i.b);
    }
    function m(H, B) {
        const C = n.sqr(B), T = p(H);
        return n.eql(C, T);
    }
    if (!m(i.Gx, i.Gy)) throw new Error("bad curve params: generator point");
    const x = n.mul(n.pow(i.a, ra), vj), _ = n.mul(n.sqr(i.b), BigInt(27));
    if (n.is0(n.add(x, _))) throw new Error("bad curve params: a or b");
    function v(H, B, C = !1) {
        if (!n.isValid(B) || C && n.is0(B)) throw new Error(`bad point coordinate ${H}`);
        return B;
    }
    function N(H) {
        if (!(H instanceof R)) throw new Error("ProjectivePoint expected");
    }
    function O(H) {
        if (!u || !u.basises) throw new Error("no endo");
        return mj(H, u.basises, s.ORDER);
    }
    const z = Hp((H, B)=>{
        const { X: C, Y: T, Z: I } = H;
        if (n.eql(I, n.ONE)) return {
            x: C,
            y: T
        };
        const y = H.is0();
        B == null && (B = y ? n.ONE : n.inv(I));
        const w = n.mul(C, B), M = n.mul(T, B), D = n.mul(I, B);
        if (y) return {
            x: n.ZERO,
            y: n.ZERO
        };
        if (!n.eql(D, n.ONE)) throw new Error("invZ was invalid");
        return {
            x: w,
            y: M
        };
    }), P = Hp((H)=>{
        if (H.is0()) {
            if (e.allowInfinityPoint && !n.is0(H.Y)) return;
            throw new Error("bad point: ZERO");
        }
        const { x: B, y: C } = H.toAffine();
        if (!n.isValid(B) || !n.isValid(C)) throw new Error("bad point: x or y not field elements");
        if (!m(B, C)) throw new Error("bad point: equation left != right");
        if (!H.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return !0;
    });
    function U(H, B, C, T, I) {
        return C = new R(n.mul(C.X, H), C.Y, C.Z), B = Qa(T, B), C = Qa(I, C), B.add(C);
    }
    class R {
        constructor(B, C, T){
            this.X = v("x", B), this.Y = v("y", C, !0), this.Z = v("z", T), Object.freeze(this);
        }
        static CURVE() {
            return i;
        }
        static fromAffine(B) {
            const { x: C, y: T } = B || {};
            if (!B || !n.isValid(C) || !n.isValid(T)) throw new Error("invalid affine point");
            if (B instanceof R) throw new Error("projective point not allowed");
            return n.is0(C) && n.is0(T) ? R.ZERO : new R(C, T, n.ONE);
        }
        static fromBytes(B) {
            const C = R.fromAffine(g(wi(B, void 0, "point")));
            return C.assertValidity(), C;
        }
        static fromHex(B) {
            return R.fromBytes(Rt("pointHex", B));
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        precompute(B = 8, C = !0) {
            return F.createCache(this, B), C || this.multiply(ra), this;
        }
        assertValidity() {
            P(this);
        }
        hasEvenY() {
            const { y: B } = this.toAffine();
            if (!n.isOdd) throw new Error("Field doesn't support isOdd");
            return !n.isOdd(B);
        }
        equals(B) {
            N(B);
            const { X: C, Y: T, Z: I } = this, { X: y, Y: w, Z: M } = B, D = n.eql(n.mul(C, M), n.mul(y, I)), A = n.eql(n.mul(T, M), n.mul(w, I));
            return D && A;
        }
        negate() {
            return new R(this.X, n.neg(this.Y), this.Z);
        }
        double() {
            const { a: B, b: C } = i, T = n.mul(C, ra), { X: I, Y: y, Z: w } = this;
            let M = n.ZERO, D = n.ZERO, A = n.ZERO, L = n.mul(I, I), V = n.mul(y, y), Y = n.mul(w, w), K = n.mul(I, y);
            return K = n.add(K, K), A = n.mul(I, w), A = n.add(A, A), M = n.mul(B, A), D = n.mul(T, Y), D = n.add(M, D), M = n.sub(V, D), D = n.add(V, D), D = n.mul(M, D), M = n.mul(K, M), A = n.mul(T, A), Y = n.mul(B, Y), K = n.sub(L, Y), K = n.mul(B, K), K = n.add(K, A), A = n.add(L, L), L = n.add(A, L), L = n.add(L, Y), L = n.mul(L, K), D = n.add(D, L), Y = n.mul(y, w), Y = n.add(Y, Y), L = n.mul(Y, K), M = n.sub(M, L), A = n.mul(Y, V), A = n.add(A, A), A = n.add(A, A), new R(M, D, A);
        }
        add(B) {
            N(B);
            const { X: C, Y: T, Z: I } = this, { X: y, Y: w, Z: M } = B;
            let D = n.ZERO, A = n.ZERO, L = n.ZERO;
            const V = i.a, Y = n.mul(i.b, ra);
            let K = n.mul(C, y), J = n.mul(T, w), ne = n.mul(I, M), ie = n.add(C, T), oe = n.add(y, w);
            ie = n.mul(ie, oe), oe = n.add(K, J), ie = n.sub(ie, oe), oe = n.add(C, I);
            let le = n.add(y, M);
            return oe = n.mul(oe, le), le = n.add(K, ne), oe = n.sub(oe, le), le = n.add(T, I), D = n.add(w, M), le = n.mul(le, D), D = n.add(J, ne), le = n.sub(le, D), L = n.mul(V, oe), D = n.mul(Y, ne), L = n.add(D, L), D = n.sub(J, L), L = n.add(J, L), A = n.mul(D, L), J = n.add(K, K), J = n.add(J, K), ne = n.mul(V, ne), oe = n.mul(Y, oe), J = n.add(J, ne), ne = n.sub(K, ne), ne = n.mul(V, ne), oe = n.add(oe, ne), K = n.mul(J, oe), A = n.add(A, K), K = n.mul(le, oe), D = n.mul(ie, D), D = n.sub(D, K), K = n.mul(ie, J), L = n.mul(le, L), L = n.add(L, K), new R(D, A, L);
        }
        subtract(B) {
            return this.add(B.negate());
        }
        is0() {
            return this.equals(R.ZERO);
        }
        multiply(B) {
            const { endo: C } = e;
            if (!s.isValidNot0(B)) throw new Error("invalid scalar: out of range");
            let T, I;
            const y = (w)=>F.cached(this, w, (M)=>Vu(R, M));
            if (C) {
                const { k1neg: w, k1: M, k2neg: D, k2: A } = O(B), { p: L, f: V } = y(M), { p: Y, f: K } = y(A);
                I = V.add(K), T = U(C.beta, L, Y, w, D);
            } else {
                const { p: w, f: M } = y(B);
                T = w, I = M;
            }
            return Vu(R, [
                T,
                I
            ])[0];
        }
        multiplyUnsafe(B) {
            const { endo: C } = e, T = this;
            if (!s.isValid(B)) throw new Error("invalid scalar: out of range");
            if (B === hn || T.is0()) return R.ZERO;
            if (B === rs) return T;
            if (F.hasCache(this)) return this.multiply(B);
            if (C) {
                const { k1neg: I, k1: y, k2neg: w, k2: M } = O(B), { p1: D, p2: A } = oj(R, T, y, M);
                return U(C.beta, D, A, I, w);
            } else return F.unsafe(T, B);
        }
        multiplyAndAddUnsafe(B, C, T) {
            const I = this.multiplyUnsafe(C).add(B.multiplyUnsafe(T));
            return I.is0() ? void 0 : I;
        }
        toAffine(B) {
            return z(this, B);
        }
        isTorsionFree() {
            const { isTorsionFree: B } = e;
            return o === rs ? !0 : B ? B(R, this) : F.unsafe(this, a).is0();
        }
        clearCofactor() {
            const { clearCofactor: B } = e;
            return o === rs ? this : B ? B(R, this) : this.multiplyUnsafe(o);
        }
        isSmallOrder() {
            return this.multiplyUnsafe(o).is0();
        }
        toBytes(B = !0) {
            return Fa(B, "isCompressed"), this.assertValidity(), f(R, this, B);
        }
        toHex(B = !0) {
            return ts(this.toBytes(B));
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        get px() {
            return this.X;
        }
        get py() {
            return this.X;
        }
        get pz() {
            return this.Z;
        }
        toRawBytes(B = !0) {
            return this.toBytes(B);
        }
        _setWindowSize(B) {
            this.precompute(B);
        }
        static normalizeZ(B) {
            return Vu(R, B);
        }
        static msm(B, C) {
            return aj(R, s, B, C);
        }
        static fromPrivateKey(B) {
            return R.BASE.multiply(Ki(s, B));
        }
    }
    R.BASE = new R(i.Gx, i.Gy, n.ONE), R.ZERO = new R(n.ZERO, n.ONE, n.ZERO), R.Fp = n, R.Fn = s;
    const G = s.BITS, F = new sj(R, e.endo ? Math.ceil(G / 2) : G);
    return R.BASE.precompute(8), R;
}
function h1(r) {
    return Uint8Array.of(r ? 2 : 3);
}
function f1(r, e) {
    return {
        secretKey: e.BYTES,
        publicKey: 1 + r.BYTES,
        publicKeyUncompressed: 1 + 2 * r.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * e.BYTES
    };
}
function Mj(r, e = {}) {
    const { Fn: t } = r, n = e.randomBytes || Li, s = Object.assign(f1(r.Fp, t), {
        seed: a1(t.ORDER)
    });
    function i(h) {
        try {
            return !!Ki(t, h);
        } catch  {
            return !1;
        }
    }
    function o(h, f) {
        const { publicKey: g, publicKeyUncompressed: p } = s;
        try {
            const m = h.length;
            return f === !0 && m !== g || f === !1 && m !== p ? !1 : !!r.fromBytes(h);
        } catch  {
            return !1;
        }
    }
    function a(h = n(s.seed)) {
        return rj(wi(h, s.seed, "seed"), t.ORDER);
    }
    function u(h, f = !0) {
        return r.BASE.multiply(Ki(t, h)).toBytes(f);
    }
    function c(h) {
        const f = a(h);
        return {
            secretKey: f,
            publicKey: u(f)
        };
    }
    function l(h) {
        if (typeof h == "bigint") return !1;
        if (h instanceof r) return !0;
        const { secretKey: f, publicKey: g, publicKeyUncompressed: p } = s;
        if (t.allowedLengths || f === g) return;
        const m = Rt("key", h).length;
        return m === g || m === p;
    }
    function d(h, f, g = !0) {
        if (l(h) === !0) throw new Error("first arg must be private key");
        if (l(f) === !1) throw new Error("second arg must be public key");
        const p = Ki(t, h);
        return r.fromHex(f).multiply(p).toBytes(g);
    }
    return Object.freeze({
        getPublicKey: u,
        getSharedSecret: d,
        keygen: c,
        Point: r,
        utils: {
            isValidSecretKey: i,
            isValidPublicKey: o,
            randomSecretKey: a,
            isValidPrivateKey: i,
            randomPrivateKey: a,
            normPrivateKeyToScalar: (h)=>Ki(t, h),
            precompute (h = 8, f = r.BASE) {
                return f.precompute(h, !1);
            }
        },
        lengths: s
    });
}
function Nj(r, e, t = {}) {
    $c(e), Yc(t, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const n = t.randomBytes || Li, s = t.hmac || ((C, ...T)=>qc(e, C, Fn(...T))), { Fp: i, Fn: o } = r, { ORDER: a, BITS: u } = o, { keygen: c, getPublicKey: l, getSharedSecret: d, utils: h, lengths: f } = Mj(r, t), g = {
        prehash: !1,
        lowS: typeof t.lowS == "boolean" ? t.lowS : !1,
        format: void 0,
        extraEntropy: !1
    }, p = "compact";
    function m(C) {
        const T = a >> rs;
        return C > T;
    }
    function x(C, T) {
        if (!o.isValidNot0(T)) throw new Error(`invalid signature ${C}: out of range 1..Point.Fn.ORDER`);
        return T;
    }
    function _(C, T) {
        Hl(T);
        const I = f.signature, y = T === "compact" ? I : T === "recovered" ? I + 1 : void 0;
        return wi(C, y, `${T} signature`);
    }
    class v {
        constructor(T, I, y){
            this.r = x("r", T), this.s = x("s", I), y != null && (this.recovery = y), Object.freeze(this);
        }
        static fromBytes(T, I = p) {
            _(T, I);
            let y;
            if (I === "der") {
                const { r: A, s: L } = un.toSig(wi(T));
                return new v(A, L);
            }
            I === "recovered" && (y = T[0], I = "compact", T = T.subarray(1));
            const w = o.BYTES, M = T.subarray(0, w), D = T.subarray(w, w * 2);
            return new v(o.fromBytes(M), o.fromBytes(D), y);
        }
        static fromHex(T, I) {
            return this.fromBytes($a(T), I);
        }
        addRecoveryBit(T) {
            return new v(this.r, this.s, T);
        }
        recoverPublicKey(T) {
            const I = i.ORDER, { r: y, s: w, recovery: M } = this;
            if (M == null || ![
                0,
                1,
                2,
                3
            ].includes(M)) throw new Error("recovery id invalid");
            if (a * d1 < I && M > 1) throw new Error("recovery id is ambiguous for h>1 curve");
            const D = M === 2 || M === 3 ? y + a : y;
            if (!i.isValid(D)) throw new Error("recovery id 2 or 3 invalid");
            const A = i.toBytes(D), L = r.fromBytes(Fn(h1((M & 1) === 0), A)), V = o.inv(D), Y = O(Rt("msgHash", T)), K = o.create(-Y * V), J = o.create(w * V), ne = r.BASE.multiplyUnsafe(K).add(L.multiplyUnsafe(J));
            if (ne.is0()) throw new Error("point at infinify");
            return ne.assertValidity(), ne;
        }
        hasHighS() {
            return m(this.s);
        }
        toBytes(T = p) {
            if (Hl(T), T === "der") return $a(un.hexFromSig(this));
            const I = o.toBytes(this.r), y = o.toBytes(this.s);
            if (T === "recovered") {
                if (this.recovery == null) throw new Error("recovery bit must be present");
                return Fn(Uint8Array.of(this.recovery), I, y);
            }
            return Fn(I, y);
        }
        toHex(T) {
            return ts(this.toBytes(T));
        }
        assertValidity() {}
        static fromCompact(T) {
            return v.fromBytes(Rt("sig", T), "compact");
        }
        static fromDER(T) {
            return v.fromBytes(Rt("sig", T), "der");
        }
        normalizeS() {
            return this.hasHighS() ? new v(this.r, o.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return this.toBytes("der");
        }
        toDERHex() {
            return ts(this.toBytes("der"));
        }
        toCompactRawBytes() {
            return this.toBytes("compact");
        }
        toCompactHex() {
            return ts(this.toBytes("compact"));
        }
    }
    const N = t.bits2int || function(C) {
        if (C.length > 8192) throw new Error("input is too large");
        const T = Vc(C), I = C.length * 8 - u;
        return I > 0 ? T >> BigInt(I) : T;
    }, O = t.bits2int_modN || function(C) {
        return o.create(N(C));
    }, z = xo(u);
    function P(C) {
        return Yl("num < 2^" + u, C, hn, z), o.toBytes(C);
    }
    function U(C, T) {
        return wi(C, void 0, "message"), T ? wi(e(C), void 0, "prehashed message") : C;
    }
    function R(C, T, I) {
        if ([
            "recovered",
            "canonical"
        ].some((J)=>J in I)) throw new Error("sign() legacy options not supported");
        const { lowS: y, prehash: w, extraEntropy: M } = Wu(I, g);
        C = U(C, w);
        const D = O(C), A = Ki(o, T), L = [
            P(A),
            P(D)
        ];
        if (M != null && M !== !1) {
            const J = M === !0 ? n(f.secretKey) : M;
            L.push(Rt("extraEntropy", J));
        }
        const V = Fn(...L), Y = D;
        function K(J) {
            const ne = N(J);
            if (!o.isValidNot0(ne)) return;
            const ie = o.inv(ne), oe = r.BASE.multiply(ne).toAffine(), le = o.create(oe.x);
            if (le === hn) return;
            const fe = o.create(ie * o.create(Y + le * A));
            if (fe === hn) return;
            let Q = (oe.x === le ? 0 : 2) | Number(oe.y & rs), Z = fe;
            return y && m(fe) && (Z = o.neg(fe), Q ^= 1), new v(le, Z, Q);
        }
        return {
            seed: V,
            k2sig: K
        };
    }
    function G(C, T, I = {}) {
        C = Rt("message", C);
        const { seed: y, k2sig: w } = R(C, T, I);
        return G3(e.outputLen, o.BYTES, s)(y, w);
    }
    function F(C) {
        let T;
        const I = typeof C == "string" || Rc(C), y = !I && C !== null && typeof C == "object" && typeof C.r == "bigint" && typeof C.s == "bigint";
        if (!I && !y) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (y) T = new v(C.r, C.s);
        else if (I) {
            try {
                T = v.fromBytes(Rt("sig", C), "der");
            } catch (w) {
                if (!(w instanceof un.Err)) throw w;
            }
            if (!T) try {
                T = v.fromBytes(Rt("sig", C), "compact");
            } catch  {
                return !1;
            }
        }
        return T || !1;
    }
    function H(C, T, I, y = {}) {
        const { lowS: w, prehash: M, format: D } = Wu(y, g);
        if (I = Rt("publicKey", I), T = U(Rt("message", T), M), "strict" in y) throw new Error("options.strict was renamed to lowS");
        const A = D === void 0 ? F(C) : v.fromBytes(Rt("sig", C), D);
        if (A === !1) return !1;
        try {
            const L = r.fromBytes(I);
            if (w && A.hasHighS()) return !1;
            const { r: V, s: Y } = A, K = O(T), J = o.inv(Y), ne = o.create(K * J), ie = o.create(V * J), oe = r.BASE.multiplyUnsafe(ne).add(L.multiplyUnsafe(ie));
            return oe.is0() ? !1 : o.create(oe.x) === V;
        } catch  {
            return !1;
        }
    }
    function B(C, T, I = {}) {
        const { prehash: y } = Wu(I, g);
        return T = U(T, y), v.fromBytes(C, "recovered").recoverPublicKey(T).toBytes();
    }
    return Object.freeze({
        keygen: c,
        getPublicKey: l,
        getSharedSecret: d,
        utils: h,
        lengths: f,
        Point: r,
        sign: G,
        verify: H,
        recoverPublicKey: B,
        Signature: v,
        hash: e
    });
}
function xj(r) {
    const e = {
        a: r.a,
        b: r.b,
        p: r.Fp.ORDER,
        n: r.n,
        h: r.h,
        Gx: r.Gx,
        Gy: r.Gy
    }, t = r.Fp;
    let n = r.allowedPrivateKeyLengths ? Array.from(new Set(r.allowedPrivateKeyLengths.map((o)=>Math.ceil(o / 2)))) : void 0;
    const s = Zn(e.n, {
        BITS: r.nBitLength,
        allowedLengths: n,
        modFromBytes: r.wrapPrivateKey
    }), i = {
        Fp: t,
        Fn: s,
        allowInfinityPoint: r.allowInfinityPoint,
        endo: r.endo,
        isTorsionFree: r.isTorsionFree,
        clearCofactor: r.clearCofactor,
        fromBytes: r.fromBytes,
        toBytes: r.toBytes
    };
    return {
        CURVE: e,
        curveOpts: i
    };
}
function Ij(r) {
    const { CURVE: e, curveOpts: t } = xj(r), n = {
        hmac: r.hmac,
        randomBytes: r.randomBytes,
        lowS: r.lowS,
        bits2int: r.bits2int,
        bits2int_modN: r.bits2int_modN
    };
    return {
        CURVE: e,
        curveOpts: t,
        hash: r.hash,
        ecdsaOpts: n
    };
}
function Tj(r, e) {
    const t = e.Point;
    return Object.assign({}, e, {
        ProjectivePoint: t,
        CURVE: Object.assign({}, r, s1(t.Fn.ORDER, t.Fn.BITS))
    });
}
function Dj(r) {
    const { CURVE: e, curveOpts: t, hash: n, ecdsaOpts: s } = Ij(r), i = Ej(e, t), o = Nj(i, n, s);
    return Tj(r, o);
}
function Wl(r, e) {
    const t = (n)=>Dj({
            ...r,
            hash: n
        });
    return {
        ...t(e),
        create: t
    };
}
const p1 = {
    p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
    n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
    h: BigInt(1),
    a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
    b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
    Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
    Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
}, g1 = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
    n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
    h: BigInt(1),
    a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
    b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
    Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
    Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
}, y1 = {
    p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
    h: BigInt(1),
    a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
    b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
    Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
    Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
}, _j = Zn(p1.p), Aj = Zn(g1.p), Sj = Zn(y1.p), Oj = Wl({
    ...p1,
    Fp: _j,
    lowS: !1
}, Fc);
Wl({
    ...g1,
    Fp: Aj,
    lowS: !1
}, U4), Wl({
    ...y1,
    Fp: Sj,
    lowS: !1,
    allowedPrivateKeyLengths: [
        130,
        131,
        132
    ]
}, P4);
const jj = Oj, w1 = "base10", qt = "base16", Zt = "base64pad", qn = "base64url", Io = "utf8", m1 = 0, pn = 1, To = 2, Cj = 0, rg = 1, eo = 12, ch = 32;
function Lj() {
    const r = Gl.utils.randomPrivateKey(), e = Gl.getPublicKey(r);
    return {
        privateKey: tr(r, qt),
        publicKey: tr(e, qt)
    };
}
function Kl() {
    const r = Li(ch);
    return tr(r, qt);
}
function kj(r, e) {
    const t = Gl.getSharedSecret(mr(r, qt), mr(e, qt)), n = V3(Qc, t, void 0, void 0, ch);
    return tr(n, qt);
}
function Ma(r) {
    const e = Qc(mr(r, qt));
    return tr(e, qt);
}
function yr(r) {
    const e = Qc(mr(r, Io));
    return tr(e, qt);
}
function b1(r) {
    return mr(`${r}`, w1);
}
function Ti(r) {
    return Number(tr(r, w1));
}
function v1(r) {
    return r.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function E1(r) {
    const e = r.replace(/-/g, "+").replace(/_/g, "/"), t = (4 - e.length % 4) % 4;
    return e + "=".repeat(t);
}
function zj(r) {
    const e = b1(typeof r.type < "u" ? r.type : m1);
    if (Ti(e) === pn && typeof r.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    const t = typeof r.senderPublicKey < "u" ? mr(r.senderPublicKey, qt) : void 0, n = typeof r.iv < "u" ? mr(r.iv, qt) : Li(eo), s = mr(r.symKey, qt), i = Gm(s, n).encrypt(mr(r.message, Io)), o = M1({
        type: e,
        sealed: i,
        iv: n,
        senderPublicKey: t
    });
    return r.encoding === qn ? v1(o) : o;
}
function Pj(r) {
    const e = mr(r.symKey, qt), { sealed: t, iv: n } = fo({
        encoded: r.encoded,
        encoding: r.encoding
    }), s = Gm(e, n).decrypt(t);
    if (s === null) throw new Error("Failed to decrypt");
    return tr(s, Io);
}
function Uj(r, e) {
    const t = b1(To), n = Li(eo), s = mr(r, Io), i = M1({
        type: t,
        sealed: s,
        iv: n
    });
    return e === qn ? v1(i) : i;
}
function Rj(r, e) {
    const { sealed: t } = fo({
        encoded: r,
        encoding: e
    });
    return tr(t, Io);
}
function M1(r) {
    if (Ti(r.type) === To) return tr(Js([
        r.type,
        r.sealed
    ]), Zt);
    if (Ti(r.type) === pn) {
        if (typeof r.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
        return tr(Js([
            r.type,
            r.senderPublicKey,
            r.iv,
            r.sealed
        ]), Zt);
    }
    return tr(Js([
        r.type,
        r.iv,
        r.sealed
    ]), Zt);
}
function fo(r) {
    const e = (r.encoding || Zt) === qn ? E1(r.encoded) : r.encoded, t = mr(e, Zt), n = t.slice(Cj, rg), s = rg;
    if (Ti(n) === pn) {
        const u = s + ch, c = u + eo, l = t.slice(s, u), d = t.slice(u, c), h = t.slice(c);
        return {
            type: n,
            sealed: h,
            iv: d,
            senderPublicKey: l
        };
    }
    if (Ti(n) === To) {
        const u = t.slice(s), c = Li(eo);
        return {
            type: n,
            sealed: u,
            iv: c
        };
    }
    const i = s + eo, o = t.slice(s, i), a = t.slice(i);
    return {
        type: n,
        sealed: a,
        iv: o
    };
}
function $j(r, e) {
    const t = fo({
        encoded: r,
        encoding: e == null ? void 0 : e.encoding
    });
    return N1({
        type: Ti(t.type),
        senderPublicKey: typeof t.senderPublicKey < "u" ? tr(t.senderPublicKey, qt) : void 0,
        receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
    });
}
function N1(r) {
    const e = (r == null ? void 0 : r.type) || m1;
    if (e === pn) {
        if (typeof (r == null ? void 0 : r.senderPublicKey) > "u") throw new Error("missing sender public key");
        if (typeof (r == null ? void 0 : r.receiverPublicKey) > "u") throw new Error("missing receiver public key");
    }
    return {
        type: e,
        senderPublicKey: r == null ? void 0 : r.senderPublicKey,
        receiverPublicKey: r == null ? void 0 : r.receiverPublicKey
    };
}
function ng(r) {
    return r.type === pn && typeof r.senderPublicKey == "string" && typeof r.receiverPublicKey == "string";
}
function ig(r) {
    return r.type === To;
}
function Bj(r) {
    const e = ye.Buffer.from(r.x, "base64"), t = ye.Buffer.from(r.y, "base64");
    return Js([
        new Uint8Array([
            4
        ]),
        e,
        t
    ]);
}
function Fj(r, e) {
    const [t, n, s] = r.split("."), i = ye.Buffer.from(E1(s), "base64");
    if (i.length !== 64) throw new Error("Invalid signature length");
    const o = i.slice(0, 32), a = i.slice(32, 64), u = `${t}.${n}`, c = Qc(u), l = Bj(e);
    if (!jj.verify(Js([
        o,
        a
    ]), c, l)) throw new Error("Invalid signature");
    return _l(r).payload;
}
const qj = "irn";
function Va(r) {
    return (r == null ? void 0 : r.relay) || {
        protocol: qj
    };
}
function Xi(r) {
    const e = mO[r];
    if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${r}`);
    return e;
}
var Qj = Object.defineProperty, Vj = Object.defineProperties, Yj = Object.getOwnPropertyDescriptors, sg = Object.getOwnPropertySymbols, Gj = Object.prototype.hasOwnProperty, Hj = Object.prototype.propertyIsEnumerable, og = (r, e, t)=>e in r ? Qj(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Ku = (r, e)=>{
    for(var t in e || (e = {}))Gj.call(e, t) && og(r, t, e[t]);
    if (sg) for (var t of sg(e))Hj.call(e, t) && og(r, t, e[t]);
    return r;
}, Wj = (r, e)=>Vj(r, Yj(e));
function Kj(r, e = "-") {
    const t = {}, n = "relay" + e;
    return Object.keys(r).forEach((s)=>{
        if (s.startsWith(n)) {
            const i = s.replace(n, ""), o = r[s];
            t[i] = o;
        }
    }), t;
}
function ag(r) {
    if (!r.includes("wc:")) {
        const c = Dm(r);
        c != null && c.includes("wc:") && (r = c);
    }
    r = r.includes("wc://") ? r.replace("wc://", "") : r, r = r.includes("wc:") ? r.replace("wc:", "") : r;
    const e = r.indexOf(":"), t = r.indexOf("?") !== -1 ? r.indexOf("?") : void 0, n = r.substring(0, e), s = r.substring(e + 1, t).split("@"), i = typeof t < "u" ? r.substring(t) : "", o = new URLSearchParams(i), a = Object.fromEntries(o.entries()), u = typeof a.methods == "string" ? a.methods.split(",") : void 0;
    return {
        protocol: n,
        topic: Xj(s[0]),
        version: parseInt(s[1], 10),
        symKey: a.symKey,
        relay: Kj(a),
        methods: u,
        expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0
    };
}
function Xj(r) {
    return r.startsWith("//") ? r.substring(2) : r;
}
function Zj(r, e = "-") {
    const t = "relay", n = {};
    return Object.keys(r).forEach((s)=>{
        const i = s, o = t + e + i;
        r[i] && (n[o] = r[i]);
    }), n;
}
function cg(r) {
    const e = new URLSearchParams(), t = Ku(Ku(Wj(Ku({}, Zj(r.relay)), {
        symKey: r.symKey
    }), r.expiryTimestamp && {
        expiryTimestamp: r.expiryTimestamp.toString()
    }), r.methods && {
        methods: r.methods.join(",")
    });
    return Object.entries(t).sort(([n], [s])=>n.localeCompare(s)).forEach(([n, s])=>{
        s !== void 0 && e.append(n, String(s));
    }), `${r.protocol}:${r.topic}@${r.version}?${e}`;
}
function na(r, e, t) {
    return `${r}?wc_ev=${t}&topic=${e}`;
}
var Jj = Object.defineProperty, eC = Object.defineProperties, tC = Object.getOwnPropertyDescriptors, ug = Object.getOwnPropertySymbols, rC = Object.prototype.hasOwnProperty, nC = Object.prototype.propertyIsEnumerable, lg = (r, e, t)=>e in r ? Jj(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, iC = (r, e)=>{
    for(var t in e || (e = {}))rC.call(e, t) && lg(r, t, e[t]);
    if (ug) for (var t of ug(e))nC.call(e, t) && lg(r, t, e[t]);
    return r;
}, sC = (r, e)=>eC(r, tC(e));
function ws(r) {
    const e = [];
    return r.forEach((t)=>{
        const [n, s] = t.split(":");
        e.push(`${n}:${s}`);
    }), e;
}
function oC(r) {
    const e = [];
    return Object.values(r).forEach((t)=>{
        e.push(...ws(t.accounts));
    }), e;
}
function aC(r, e) {
    const t = [];
    return Object.values(r).forEach((n)=>{
        ws(n.accounts).includes(e) && t.push(...n.methods);
    }), t;
}
function cC(r, e) {
    const t = [];
    return Object.values(r).forEach((n)=>{
        ws(n.accounts).includes(e) && t.push(...n.events);
    }), t;
}
function x1(r) {
    return r.includes(":");
}
function uC(r) {
    return x1(r) ? r.split(":")[0] : r;
}
function dg(r) {
    var e, t, n;
    const s = {};
    if (!po(r)) return s;
    for (const [i, o] of Object.entries(r)){
        const a = x1(i) ? [
            i
        ] : o.chains, u = o.methods || [], c = o.events || [], l = uC(i);
        s[l] = sC(iC({}, s[l]), {
            chains: Ei(a, (e = s[l]) == null ? void 0 : e.chains),
            methods: Ei(u, (t = s[l]) == null ? void 0 : t.methods),
            events: Ei(c, (n = s[l]) == null ? void 0 : n.events)
        });
    }
    return s;
}
function lC(r) {
    const e = {};
    return r == null || r.forEach((t)=>{
        var n;
        const [s, i] = t.split(":");
        e[s] || (e[s] = {
            accounts: [],
            chains: [],
            events: [],
            methods: []
        }), e[s].accounts.push(t), (n = e[s].chains) == null || n.push(`${s}:${i}`);
    }), e;
}
function hg(r, e) {
    e = e.map((n)=>n.replace("did:pkh:", ""));
    const t = lC(e);
    for (const [n, s] of Object.entries(t))s.methods ? s.methods = Ei(s.methods, r) : s.methods = r, s.events = [
        "chainChanged",
        "accountsChanged"
    ];
    return t;
}
function dC(r, e) {
    var t, n, s, i, o, a;
    const u = dg(r), c = dg(e), l = {}, d = Object.keys(u).concat(Object.keys(c));
    for (const h of d)l[h] = {
        chains: Ei((t = u[h]) == null ? void 0 : t.chains, (n = c[h]) == null ? void 0 : n.chains),
        methods: Ei((s = u[h]) == null ? void 0 : s.methods, (i = c[h]) == null ? void 0 : i.methods),
        events: Ei((o = u[h]) == null ? void 0 : o.events, (a = c[h]) == null ? void 0 : a.events)
    };
    return l;
}
const hC = {
    INVALID_METHOD: {
        message: "Invalid method.",
        code: 1001
    },
    INVALID_EVENT: {
        message: "Invalid event.",
        code: 1002
    },
    INVALID_UPDATE_REQUEST: {
        message: "Invalid update request.",
        code: 1003
    },
    INVALID_EXTEND_REQUEST: {
        message: "Invalid extend request.",
        code: 1004
    },
    INVALID_SESSION_SETTLE_REQUEST: {
        message: "Invalid session settle request.",
        code: 1005
    },
    UNAUTHORIZED_METHOD: {
        message: "Unauthorized method.",
        code: 3001
    },
    UNAUTHORIZED_EVENT: {
        message: "Unauthorized event.",
        code: 3002
    },
    UNAUTHORIZED_UPDATE_REQUEST: {
        message: "Unauthorized update request.",
        code: 3003
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
        message: "Unauthorized extend request.",
        code: 3004
    },
    USER_REJECTED: {
        message: "User rejected.",
        code: 5e3
    },
    USER_REJECTED_CHAINS: {
        message: "User rejected chains.",
        code: 5001
    },
    USER_REJECTED_METHODS: {
        message: "User rejected methods.",
        code: 5002
    },
    USER_REJECTED_EVENTS: {
        message: "User rejected events.",
        code: 5003
    },
    UNSUPPORTED_CHAINS: {
        message: "Unsupported chains.",
        code: 5100
    },
    UNSUPPORTED_METHODS: {
        message: "Unsupported methods.",
        code: 5101
    },
    UNSUPPORTED_EVENTS: {
        message: "Unsupported events.",
        code: 5102
    },
    UNSUPPORTED_ACCOUNTS: {
        message: "Unsupported accounts.",
        code: 5103
    },
    UNSUPPORTED_NAMESPACE_KEY: {
        message: "Unsupported namespace key.",
        code: 5104
    },
    USER_DISCONNECTED: {
        message: "User disconnected.",
        code: 6e3
    },
    SESSION_SETTLEMENT_FAILED: {
        message: "Session settlement failed.",
        code: 7e3
    },
    WC_METHOD_UNSUPPORTED: {
        message: "Unsupported wc_ method.",
        code: 10001
    }
}, fC = {
    NOT_INITIALIZED: {
        message: "Not initialized.",
        code: 1
    },
    NO_MATCHING_KEY: {
        message: "No matching key.",
        code: 2
    },
    RESTORE_WILL_OVERRIDE: {
        message: "Restore will override.",
        code: 3
    },
    RESUBSCRIBED: {
        message: "Resubscribed.",
        code: 4
    },
    MISSING_OR_INVALID: {
        message: "Missing or invalid.",
        code: 5
    },
    EXPIRED: {
        message: "Expired.",
        code: 6
    },
    UNKNOWN_TYPE: {
        message: "Unknown type.",
        code: 7
    },
    MISMATCHED_TOPIC: {
        message: "Mismatched topic.",
        code: 8
    },
    NON_CONFORMING_NAMESPACES: {
        message: "Non conforming namespaces.",
        code: 9
    }
};
function ce(r, e) {
    const { message: t, code: n } = fC[r];
    return {
        message: e ? `${t} ${e}` : t,
        code: n
    };
}
function rt(r, e) {
    const { message: t, code: n } = hC[r];
    return {
        message: e ? `${t} ${e}` : t,
        code: n
    };
}
function ls(r, e) {
    return Array.isArray(r) ? typeof e < "u" && r.length ? r.every(e) : !0 : !1;
}
function po(r) {
    return Object.getPrototypeOf(r) === Object.prototype && Object.keys(r).length;
}
function pt(r) {
    return typeof r > "u";
}
function ct(r, e) {
    return e && pt(r) ? !0 : typeof r == "string" && !!r.trim().length;
}
function uh(r, e) {
    return e && pt(r) ? !0 : typeof r == "number" && !isNaN(r);
}
function pC(r, e) {
    const { requiredNamespaces: t } = e, n = Object.keys(r.namespaces), s = Object.keys(t);
    let i = !0;
    return yi(s, n) ? (n.forEach((o)=>{
        const { accounts: a, methods: u, events: c } = r.namespaces[o], l = ws(a), d = t[o];
        (!yi(Mm(o, d), l) || !yi(d.methods, u) || !yi(d.events, c)) && (i = !1);
    }), i) : !1;
}
function Ya(r) {
    return ct(r, !1) && r.includes(":") ? r.split(":").length === 2 : !1;
}
function gC(r) {
    if (ct(r, !1) && r.includes(":")) {
        const e = r.split(":");
        if (e.length === 3) {
            const t = e[0] + ":" + e[1];
            return !!e[2] && Ya(t);
        }
    }
    return !1;
}
function yC(r) {
    function e(t) {
        try {
            return typeof new URL(t) < "u";
        } catch  {
            return !1;
        }
    }
    try {
        if (ct(r, !1)) {
            if (e(r)) return !0;
            const t = Dm(r);
            return e(t);
        }
    } catch  {}
    return !1;
}
function wC(r) {
    var e;
    return (e = r == null ? void 0 : r.proposer) == null ? void 0 : e.publicKey;
}
function mC(r) {
    return r == null ? void 0 : r.topic;
}
function bC(r, e) {
    let t = null;
    return ct(r == null ? void 0 : r.publicKey, !1) || (t = ce("MISSING_OR_INVALID", `${e} controller public key should be a string`)), t;
}
function fg(r) {
    let e = !0;
    return ls(r) ? r.length && (e = r.every((t)=>ct(t, !1))) : e = !1, e;
}
function vC(r, e, t) {
    let n = null;
    return ls(e) && e.length ? e.forEach((s)=>{
        n || Ya(s) || (n = rt("UNSUPPORTED_CHAINS", `${t}, chain ${s} should be a string and conform to "namespace:chainId" format`));
    }) : Ya(r) || (n = rt("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function EC(r, e, t) {
    let n = null;
    return Object.entries(r).forEach(([s, i])=>{
        if (n) return;
        const o = vC(s, Mm(s, i), `${e} ${t}`);
        o && (n = o);
    }), n;
}
function MC(r, e) {
    let t = null;
    return ls(r) ? r.forEach((n)=>{
        t || gC(n) || (t = rt("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
    }) : t = rt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function NC(r, e) {
    let t = null;
    return Object.values(r).forEach((n)=>{
        if (t) return;
        const s = MC(n == null ? void 0 : n.accounts, `${e} namespace`);
        s && (t = s);
    }), t;
}
function xC(r, e) {
    let t = null;
    return fg(r == null ? void 0 : r.methods) ? fg(r == null ? void 0 : r.events) || (t = rt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : t = rt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), t;
}
function I1(r, e) {
    let t = null;
    return Object.values(r).forEach((n)=>{
        if (t) return;
        const s = xC(n, `${e}, namespace`);
        s && (t = s);
    }), t;
}
function IC(r, e, t) {
    let n = null;
    if (r && po(r)) {
        const s = I1(r, e);
        s && (n = s);
        const i = EC(r, e, t);
        i && (n = i);
    } else n = ce("MISSING_OR_INVALID", `${e}, ${t} should be an object with data`);
    return n;
}
function Xu(r, e) {
    let t = null;
    if (r && po(r)) {
        const n = I1(r, e);
        n && (t = n);
        const s = NC(r, e);
        s && (t = s);
    } else t = ce("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
    return t;
}
function T1(r) {
    return ct(r.protocol, !0);
}
function TC(r, e) {
    let t = !1;
    return r ? r && ls(r) && r.length && r.forEach((n)=>{
        t = T1(n);
    }) : t = !0, t;
}
function DC(r) {
    return typeof r == "number";
}
function Wt(r) {
    return typeof r < "u" && typeof r !== null;
}
function _C(r) {
    return !(!r || typeof r != "object" || !r.code || !uh(r.code, !1) || !r.message || !ct(r.message, !1));
}
function AC(r) {
    return !(pt(r) || !ct(r.method, !1));
}
function SC(r) {
    return !(pt(r) || pt(r.result) && pt(r.error) || !uh(r.id, !1) || !ct(r.jsonrpc, !1));
}
function OC(r) {
    return !(pt(r) || !ct(r.name, !1));
}
function pg(r, e) {
    return !(!Ya(e) || !oC(r).includes(e));
}
function jC(r, e, t) {
    return ct(t, !1) ? aC(r, e).includes(t) : !1;
}
function CC(r, e, t) {
    return ct(t, !1) ? cC(r, e).includes(t) : !1;
}
function gg(r, e, t) {
    let n = null;
    const s = LC(r), i = kC(e), o = Object.keys(s), a = Object.keys(i), u = yg(Object.keys(r)), c = yg(Object.keys(e)), l = u.filter((d)=>!c.includes(d));
    return l.length && (n = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(e).toString()}`)), yi(o, a) || (n = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((d)=>{
        if (!d.includes(":") || n) return;
        const h = ws(e[d].accounts);
        h.includes(d) || (n = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${d}
        Required: ${d}
        Approved: ${h.toString()}`));
    }), o.forEach((d)=>{
        n || (yi(s[d].methods, i[d].methods) ? yi(s[d].events, i[d].events) || (n = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${d}`)) : n = ce("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${d}`));
    }), n;
}
function LC(r) {
    const e = {};
    return Object.keys(r).forEach((t)=>{
        var n;
        t.includes(":") ? e[t] = r[t] : (n = r[t].chains) == null || n.forEach((s)=>{
            e[s] = {
                methods: r[t].methods,
                events: r[t].events
            };
        });
    }), e;
}
function yg(r) {
    return [
        ...new Set(r.map((e)=>e.includes(":") ? e.split(":")[0] : e))
    ];
}
function kC(r) {
    const e = {};
    return Object.keys(r).forEach((t)=>{
        if (t.includes(":")) e[t] = r[t];
        else {
            const n = ws(r[t].accounts);
            n == null || n.forEach((s)=>{
                e[s] = {
                    accounts: r[t].accounts.filter((i)=>i.includes(`${s}:`)),
                    methods: r[t].methods,
                    events: r[t].events
                };
            });
        }
    }), e;
}
function zC(r, e) {
    return uh(r, !1) && r <= e.max && r >= e.min;
}
function wg() {
    const r = Mo();
    return new Promise((e)=>{
        switch(r){
            case cr.browser:
                e(PC());
                break;
            case cr.reactNative:
                e(UC());
                break;
            case cr.node:
                e(RC());
                break;
            default:
                e(!0);
        }
    });
}
function PC() {
    return ys() && (navigator == null ? void 0 : navigator.onLine);
}
async function UC() {
    if (Xn() && ("TURBOPACK compile-time value", "object") < "u" && /*TURBOPACK member replacement*/ __turbopack_context__.g != null && /*TURBOPACK member replacement*/ __turbopack_context__.g.NetInfo) {
        const r = await (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.NetInfo.fetch());
        return r == null ? void 0 : r.isConnected;
    }
    return !0;
}
function RC() {
    return !0;
}
function $C(r) {
    switch(Mo()){
        case cr.browser:
            BC(r);
            break;
        case cr.reactNative:
            FC(r);
            break;
    }
}
function BC(r) {
    !Xn() && ys() && (window.addEventListener("online", ()=>r(!0)), window.addEventListener("offline", ()=>r(!1)));
}
function FC(r) {
    Xn() && ("TURBOPACK compile-time value", "object") < "u" && /*TURBOPACK member replacement*/ __turbopack_context__.g != null && /*TURBOPACK member replacement*/ __turbopack_context__.g.NetInfo && (/*TURBOPACK member replacement*/ __turbopack_context__.g == null || /*TURBOPACK member replacement*/ __turbopack_context__.g.NetInfo.addEventListener((e)=>r(e == null ? void 0 : e.isConnected)));
}
function qC() {
    var r;
    return ys() && Ni() ? ((r = Ni()) == null ? void 0 : r.visibilityState) === "visible" : !0;
}
const Zu = {};
class $s {
    static get(e) {
        return Zu[e];
    }
    static set(e, t) {
        Zu[e] = t;
    }
    static delete(e) {
        delete Zu[e];
    }
}
function QC(r) {
    const e = vo.decode(r);
    if (e.length < 33) throw new Error("Too short to contain a public key");
    return e.slice(1, 33);
}
function VC({ publicKey: r, signature: e, payload: t }) {
    var n;
    const s = Xl(t.method), i = 128 | parseInt(((n = t.version) == null ? void 0 : n.toString()) || "4"), o = HC(t.address), a = t.era === "00" ? new Uint8Array([
        0
    ]) : Xl(t.era);
    if (a.length !== 1 && a.length !== 2) throw new Error("Invalid era length");
    const u = parseInt(t.nonce, 16), c = new Uint8Array([
        u & 255,
        u >> 8 & 255
    ]), l = BigInt(`0x${GC(t.tip)}`), d = KC(l), h = new Uint8Array([
        0,
        ...r,
        o,
        ...e,
        ...a,
        ...c,
        ...d,
        ...s
    ]), f = WC(h.length + 1);
    return new Uint8Array([
        ...f,
        i,
        ...h
    ]);
}
function YC(r) {
    const e = Xl(r), t = SO.blake2b(e, void 0, 32);
    return "0x" + ye.Buffer.from(t).toString("hex");
}
function Xl(r) {
    return new Uint8Array(r.replace(/^0x/, "").match(/.{1,2}/g).map((e)=>parseInt(e, 16)));
}
function GC(r) {
    return r.startsWith("0x") ? r.slice(2) : r;
}
function HC(r) {
    const e = vo.decode(r)[0];
    return e === 42 ? 0 : e === 60 ? 2 : 1;
}
function WC(r) {
    if (r < 64) return new Uint8Array([
        r << 2
    ]);
    if (r < 16384) {
        const e = r << 2 | 1;
        return new Uint8Array([
            e & 255,
            e >> 8 & 255
        ]);
    } else if (r < 1 << 30) {
        const e = r << 2 | 2;
        return new Uint8Array([
            e & 255,
            e >> 8 & 255,
            e >> 16 & 255,
            e >> 24 & 255
        ]);
    } else throw new Error("Compact encoding > 2^30 not supported");
}
function KC(r) {
    if (r < BigInt(1) << BigInt(6)) return new Uint8Array([
        Number(r << BigInt(2))
    ]);
    if (r < BigInt(1) << BigInt(14)) {
        const e = r << BigInt(2) | BigInt(1);
        return new Uint8Array([
            Number(e & BigInt(255)),
            Number(e >> BigInt(8) & BigInt(255))
        ]);
    } else if (r < BigInt(1) << BigInt(30)) {
        const e = r << BigInt(2) | BigInt(2);
        return new Uint8Array([
            Number(e & BigInt(255)),
            Number(e >> BigInt(8) & BigInt(255)),
            Number(e >> BigInt(16) & BigInt(255)),
            Number(e >> BigInt(24) & BigInt(255))
        ]);
    } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function XC(r) {
    const e = Uint8Array.from(ye.Buffer.from(r.signature, "hex")), t = QC(r.transaction.address), n = VC({
        publicKey: t,
        signature: e,
        payload: r.transaction
    }), s = ye.Buffer.from(n).toString("hex");
    return YC(s);
}
function D1({ logger: r, name: e }) {
    const t = typeof r == "string" ? Uy({
        opts: {
            level: r,
            name: e
        }
    }).logger : r;
    return t.level = typeof r == "string" ? r : r.level, t;
}
const ZC = "PARSE_ERROR", JC = "INVALID_REQUEST", eL = "METHOD_NOT_FOUND", tL = "INVALID_PARAMS", _1 = "INTERNAL_ERROR", lh = "SERVER_ERROR", rL = [
    -32700,
    -32600,
    -32601,
    -32602,
    -32603
], to = {
    [ZC]: {
        code: -32700,
        message: "Parse error"
    },
    [JC]: {
        code: -32600,
        message: "Invalid Request"
    },
    [eL]: {
        code: -32601,
        message: "Method not found"
    },
    [tL]: {
        code: -32602,
        message: "Invalid params"
    },
    [_1]: {
        code: -32603,
        message: "Internal error"
    },
    [lh]: {
        code: -32e3,
        message: "Server error"
    }
}, A1 = lh;
function nL(r) {
    return rL.includes(r);
}
function mg(r) {
    return Object.keys(to).includes(r) ? to[r] : to[A1];
}
function iL(r) {
    const e = Object.values(to).find((t)=>t.code === r);
    return e || to[A1];
}
function sL(r, e, t) {
    return r.message.includes("getaddrinfo ENOTFOUND") || r.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${t} RPC url at ${e}`) : r;
}
var S1 = {}, tn = {}, bg;
function oL() {
    if (bg) return tn;
    bg = 1, Object.defineProperty(tn, "__esModule", {
        value: !0
    }), tn.isBrowserCryptoAvailable = tn.getSubtleCrypto = tn.getBrowerCrypto = void 0;
    function r() {
        return ($ == null ? void 0 : $.crypto) || ($ == null ? void 0 : $.msCrypto) || {};
    }
    tn.getBrowerCrypto = r;
    function e() {
        const n = r();
        return n.subtle || n.webkitSubtle;
    }
    tn.getSubtleCrypto = e;
    function t() {
        return !!r() && !!e();
    }
    return tn.isBrowserCryptoAvailable = t, tn;
}
var rn = {}, vg;
function aL() {
    if (vg) return rn;
    vg = 1, Object.defineProperty(rn, "__esModule", {
        value: !0
    }), rn.isBrowser = rn.isNode = rn.isReactNative = void 0;
    function r() {
        return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
    }
    rn.isReactNative = r;
    function e() {
        return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
    }
    rn.isNode = e;
    function t() {
        return !r() && !e();
    }
    return rn.isBrowser = t, rn;
}
(function(r) {
    Object.defineProperty(r, "__esModule", {
        value: !0
    });
    const e = go;
    e.__exportStar(oL(), r), e.__exportStar(aL(), r);
})(S1);
function qr(r = 3) {
    const e = Date.now() * Math.pow(10, r), t = Math.floor(Math.random() * Math.pow(10, r));
    return e + t;
}
function Yn(r = 6) {
    return BigInt(qr(r));
}
function ln(r, e, t) {
    return {
        id: t || qr(),
        jsonrpc: "2.0",
        method: r,
        params: e
    };
}
function Ga(r, e) {
    return {
        id: r,
        jsonrpc: "2.0",
        result: e
    };
}
function dh(r, e, t) {
    return {
        id: r,
        jsonrpc: "2.0",
        error: cL(e)
    };
}
function cL(r, e) {
    return typeof r > "u" ? mg(_1) : (typeof r == "string" && (r = Object.assign(Object.assign({}, mg(lh)), {
        message: r
    })), nL(r.code) && (r = iL(r.code)), r);
}
class uL {
}
class lL extends uL {
    constructor(){
        super();
    }
}
class dL extends lL {
    constructor(e){
        super();
    }
}
const hL = "^wss?:";
function fL(r) {
    const e = r.match(new RegExp(/^\w+:/, "gi"));
    if (!(!e || !e.length)) return e[0];
}
function pL(r, e) {
    const t = fL(r);
    return typeof t > "u" ? !1 : new RegExp(e).test(t);
}
function Eg(r) {
    return pL(r, hL);
}
function gL(r) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(r);
}
function O1(r) {
    return typeof r == "object" && "id" in r && "jsonrpc" in r && r.jsonrpc === "2.0";
}
function hh(r) {
    return O1(r) && "method" in r;
}
function Gc(r) {
    return O1(r) && (Qr(r) || wr(r));
}
function Qr(r) {
    return "result" in r;
}
function wr(r) {
    return "error" in r;
}
class yL extends dL {
    constructor(e){
        super(e), this.events = new rr.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
    }
    async connect(e = this.connection) {
        await this.open(e);
    }
    async disconnect() {
        await this.close();
    }
    on(e, t) {
        this.events.on(e, t);
    }
    once(e, t) {
        this.events.once(e, t);
    }
    off(e, t) {
        this.events.off(e, t);
    }
    removeListener(e, t) {
        this.events.removeListener(e, t);
    }
    async request(e, t) {
        return this.requestStrict(ln(e.method, e.params || [], e.id || Yn().toString()), t);
    }
    async requestStrict(e, t) {
        return new Promise(async (n, s)=>{
            if (!this.connection.connected) try {
                await this.open();
            } catch (i) {
                s(i);
            }
            this.events.on(`${e.id}`, (i)=>{
                wr(i) ? s(i.error) : n(i.result);
            });
            try {
                await this.connection.send(e, t);
            } catch (i) {
                s(i);
            }
        });
    }
    setConnection(e = this.connection) {
        return e;
    }
    onPayload(e) {
        this.events.emit("payload", e), Gc(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
            type: e.method,
            data: e.params
        });
    }
    onClose(e) {
        e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
    }
    async open(e = this.connection) {
        this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
    }
    async close() {
        await this.connection.close();
    }
    registerEventListeners() {
        this.hasRegisteredEventListeners || (this.connection.on("payload", (e)=>this.onPayload(e)), this.connection.on("close", (e)=>this.onClose(e)), this.connection.on("error", (e)=>this.events.emit("error", e)), this.connection.on("register_error", (e)=>this.onClose()), this.hasRegisteredEventListeners = !0);
    }
}
const wL = ()=>typeof WebSocket < "u" ? WebSocket : ("TURBOPACK compile-time value", "object") < "u" && typeof /*TURBOPACK member replacement*/ __turbopack_context__.g.WebSocket < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.g.WebSocket : ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : __turbopack_context__.r("[project]/node_modules/.pnpm/ws@8.18.3/node_modules/ws/index.js [app-ssr] (ecmascript)"), mL = ()=>typeof WebSocket < "u" || ("TURBOPACK compile-time value", "object") < "u" && typeof /*TURBOPACK member replacement*/ __turbopack_context__.g.WebSocket < "u" || ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", Mg = (r)=>r.split("?")[0], Ng = 10, bL = wL();
let vL = class {
    constructor(e){
        if (this.url = e, this.events = new rr.EventEmitter(), this.registering = !1, !Eg(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        this.url = e;
    }
    get connected() {
        return typeof this.socket < "u";
    }
    get connecting() {
        return this.registering;
    }
    on(e, t) {
        this.events.on(e, t);
    }
    once(e, t) {
        this.events.once(e, t);
    }
    off(e, t) {
        this.events.off(e, t);
    }
    removeListener(e, t) {
        this.events.removeListener(e, t);
    }
    async open(e = this.url) {
        await this.register(e);
    }
    async close() {
        return new Promise((e, t)=>{
            if (typeof this.socket > "u") {
                t(new Error("Connection already closed"));
                return;
            }
            this.socket.onclose = (n)=>{
                this.onClose(n), e();
            }, this.socket.close();
        });
    }
    async send(e) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
            this.socket.send(Mi(e));
        } catch (t) {
            this.onError(e.id, t);
        }
    }
    register(e = this.url) {
        if (!Eg(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        if (this.registering) {
            const t = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n, s)=>{
                this.events.once("register_error", (i)=>{
                    this.resetMaxListeners(), s(i);
                }), this.events.once("open", ()=>{
                    if (this.resetMaxListeners(), typeof this.socket > "u") return s(new Error("WebSocket connection is missing or invalid"));
                    n(this.socket);
                });
            });
        }
        return this.url = e, this.registering = !0, new Promise((t, n)=>{
            const s = S1.isReactNative() ? void 0 : {
                rejectUnauthorized: !gL(e)
            }, i = new bL(e, [], s);
            mL() ? i.onerror = (o)=>{
                const a = o;
                n(this.emitError(a.error));
            } : i.on("error", (o)=>{
                n(this.emitError(o));
            }), i.onopen = ()=>{
                this.onOpen(i), t(i);
            };
        });
    }
    onOpen(e) {
        e.onmessage = (t)=>this.onPayload(t), e.onclose = (t)=>this.onClose(t), this.socket = e, this.registering = !1, this.events.emit("open");
    }
    onClose(e) {
        this.socket = void 0, this.registering = !1, this.events.emit("close", e);
    }
    onPayload(e) {
        if (typeof e.data > "u") return;
        const t = typeof e.data == "string" ? ss(e.data) : e.data;
        this.events.emit("payload", t);
    }
    onError(e, t) {
        const n = this.parseError(t), s = n.message || n.toString(), i = dh(e, s);
        this.events.emit("payload", i);
    }
    parseError(e, t = this.url) {
        return sL(e, Mg(t), "WS");
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > Ng && this.events.setMaxListeners(Ng);
    }
    emitError(e) {
        const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${Mg(this.url)}`));
        return this.events.emit("register_error", t), t;
    }
};
const j1 = "wc", C1 = 2, Zl = "core", Wr = `${j1}@2:${Zl}:`, EL = {
    logger: "error"
}, ML = {
    database: ":memory:"
}, NL = "crypto", xg = "client_ed25519_seed", xL = ue.ONE_DAY, IL = "keychain", TL = "0.3", DL = "messages", _L = "0.3", AL = ue.SIX_HOURS, SL = "publisher", L1 = "irn", OL = "error", k1 = "wss://relay.walletconnect.org", jL = "relayer", st = {
    message: "relayer_message",
    message_ack: "relayer_message_ack",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error",
    connection_stalled: "relayer_connection_stalled",
    transport_closed: "relayer_transport_closed",
    publish: "relayer_publish"
}, CL = "_subscription", dr = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error"
}, LL = 0.1, Jl = "2.22.3", Ge = {
    link_mode: "link_mode",
    relay: "relay"
}, Na = {
    inbound: "inbound",
    outbound: "outbound"
}, kL = "0.3", zL = "WALLETCONNECT_CLIENT_ID", Ig = "WALLETCONNECT_LINK_MODE_APPS", sr = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    expired: "subscription_expired",
    disabled: "subscription_disabled",
    sync: "subscription_sync",
    resubscribed: "subscription_resubscribed"
}, PL = "subscription", UL = "0.3", RL = "pairing", $L = "0.3", Bs = {
    wc_pairingDelete: {
        req: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1e3
        },
        res: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1001
        }
    },
    wc_pairingPing: {
        req: {
            ttl: ue.THIRTY_SECONDS,
            prompt: !1,
            tag: 1002
        },
        res: {
            ttl: ue.THIRTY_SECONDS,
            prompt: !1,
            tag: 1003
        }
    },
    unregistered_method: {
        req: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 0
        },
        res: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 0
        }
    }
}, fi = {
    create: "pairing_create",
    expire: "pairing_expire",
    delete: "pairing_delete",
    ping: "pairing_ping"
}, xr = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync"
}, BL = "history", FL = "0.3", qL = "expirer", fr = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync"
}, QL = "0.3", VL = "verify-api", YL = "https://verify.walletconnect.com", z1 = "https://verify.walletconnect.org", ro = z1, GL = `${ro}/v3`, HL = [
    YL,
    z1
], WL = "echo", KL = "https://echo.walletconnect.com", Br = {
    pairing_started: "pairing_started",
    pairing_uri_validation_success: "pairing_uri_validation_success",
    pairing_uri_not_expired: "pairing_uri_not_expired",
    store_new_pairing: "store_new_pairing",
    subscribing_pairing_topic: "subscribing_pairing_topic",
    subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
    existing_pairing: "existing_pairing",
    pairing_not_expired: "pairing_not_expired",
    emit_inactive_pairing: "emit_inactive_pairing",
    emit_session_proposal: "emit_session_proposal",
    subscribing_to_pairing_topic: "subscribing_to_pairing_topic"
}, on = {
    no_wss_connection: "no_wss_connection",
    no_internet_connection: "no_internet_connection",
    malformed_pairing_uri: "malformed_pairing_uri",
    active_pairing_already_exists: "active_pairing_already_exists",
    subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
    pairing_expired: "pairing_expired",
    proposal_expired: "proposal_expired",
    proposal_listener_not_found: "proposal_listener_not_found"
}, Ir = {
    session_approve_started: "session_approve_started",
    proposal_not_expired: "proposal_not_expired",
    session_namespaces_validation_success: "session_namespaces_validation_success",
    create_session_topic: "create_session_topic",
    subscribing_session_topic: "subscribing_session_topic",
    subscribe_session_topic_success: "subscribe_session_topic_success",
    publishing_session_approve: "publishing_session_approve",
    session_approve_publish_success: "session_approve_publish_success",
    store_session: "store_session",
    publishing_session_settle: "publishing_session_settle",
    session_settle_publish_success: "session_settle_publish_success",
    session_request_response_started: "session_request_response_started",
    session_request_response_validation_success: "session_request_response_validation_success",
    session_request_response_publish_started: "session_request_response_publish_started"
}, oi = {
    no_internet_connection: "no_internet_connection",
    no_wss_connection: "no_wss_connection",
    proposal_expired: "proposal_expired",
    subscribe_session_topic_failure: "subscribe_session_topic_failure",
    session_approve_publish_failure: "session_approve_publish_failure",
    session_settle_publish_failure: "session_settle_publish_failure",
    session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
    proposal_not_found: "proposal_not_found",
    session_request_response_validation_failure: "session_request_response_validation_failure",
    session_request_response_publish_failure: "session_request_response_publish_failure"
}, ai = {
    authenticated_session_approve_started: "authenticated_session_approve_started",
    create_authenticated_session_topic: "create_authenticated_session_topic",
    cacaos_verified: "cacaos_verified",
    store_authenticated_session: "store_authenticated_session",
    subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
    subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
    publishing_authenticated_session_approve: "publishing_authenticated_session_approve"
}, Fs = {
    no_internet_connection: "no_internet_connection",
    invalid_cacao: "invalid_cacao",
    subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
    authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
    authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found"
}, XL = 0.1, ZL = "event-client", JL = 86400, e5 = "https://pulse.walletconnect.org/batch";
function t5(r, e) {
    if (r.length >= 255) throw new TypeError("Alphabet too long");
    for(var t = new Uint8Array(256), n = 0; n < t.length; n++)t[n] = 255;
    for(var s = 0; s < r.length; s++){
        var i = r.charAt(s), o = i.charCodeAt(0);
        if (t[o] !== 255) throw new TypeError(i + " is ambiguous");
        t[o] = s;
    }
    var a = r.length, u = r.charAt(0), c = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
    function d(g) {
        if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (g.length === 0) return "";
        for(var p = 0, m = 0, x = 0, _ = g.length; x !== _ && g[x] === 0;)x++, p++;
        for(var v = (_ - x) * l + 1 >>> 0, N = new Uint8Array(v); x !== _;){
            for(var O = g[x], z = 0, P = v - 1; (O !== 0 || z < m) && P !== -1; P--, z++)O += 256 * N[P] >>> 0, N[P] = O % a >>> 0, O = O / a >>> 0;
            if (O !== 0) throw new Error("Non-zero carry");
            m = z, x++;
        }
        for(var U = v - m; U !== v && N[U] === 0;)U++;
        for(var R = u.repeat(p); U < v; ++U)R += r.charAt(N[U]);
        return R;
    }
    function h(g) {
        if (typeof g != "string") throw new TypeError("Expected String");
        if (g.length === 0) return new Uint8Array();
        var p = 0;
        if (g[p] !== " ") {
            for(var m = 0, x = 0; g[p] === u;)m++, p++;
            for(var _ = (g.length - p) * c + 1 >>> 0, v = new Uint8Array(_); g[p];){
                var N = t[g.charCodeAt(p)];
                if (N === 255) return;
                for(var O = 0, z = _ - 1; (N !== 0 || O < x) && z !== -1; z--, O++)N += a * v[z] >>> 0, v[z] = N % 256 >>> 0, N = N / 256 >>> 0;
                if (N !== 0) throw new Error("Non-zero carry");
                x = O, p++;
            }
            if (g[p] !== " ") {
                for(var P = _ - x; P !== _ && v[P] === 0;)P++;
                for(var U = new Uint8Array(m + (_ - P)), R = m; P !== _;)U[R++] = v[P++];
                return U;
            }
        }
    }
    function f(g) {
        var p = h(g);
        if (p) return p;
        throw new Error(`Non-${e} character`);
    }
    return {
        encode: d,
        decodeUnsafe: h,
        decode: f
    };
}
var r5 = t5, n5 = r5;
const P1 = (r)=>{
    if (r instanceof Uint8Array && r.constructor.name === "Uint8Array") return r;
    if (r instanceof ArrayBuffer) return new Uint8Array(r);
    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
    throw new Error("Unknown type, must be binary type");
}, i5 = (r)=>new TextEncoder().encode(r), s5 = (r)=>new TextDecoder().decode(r);
class o5 {
    constructor(e, t, n){
        this.name = e, this.prefix = t, this.baseEncode = n;
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type");
    }
}
class a5 {
    constructor(e, t, n){
        if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
    }
    or(e) {
        return U1(this, e);
    }
}
class c5 {
    constructor(e){
        this.decoders = e;
    }
    or(e) {
        return U1(this, e);
    }
    decode(e) {
        const t = e[0], n = this.decoders[t];
        if (n) return n.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
}
const U1 = (r, e)=>new c5({
        ...r.decoders || {
            [r.prefix]: r
        },
        ...e.decoders || {
            [e.prefix]: e
        }
    });
class u5 {
    constructor(e, t, n, s){
        this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new o5(e, t, n), this.decoder = new a5(e, t, s);
    }
    encode(e) {
        return this.encoder.encode(e);
    }
    decode(e) {
        return this.decoder.decode(e);
    }
}
const Hc = ({ name: r, prefix: e, encode: t, decode: n })=>new u5(r, e, t, n), Do = ({ prefix: r, name: e, alphabet: t })=>{
    const { encode: n, decode: s } = n5(t, e);
    return Hc({
        prefix: r,
        name: e,
        encode: n,
        decode: (i)=>P1(s(i))
    });
}, l5 = (r, e, t, n)=>{
    const s = {};
    for(let l = 0; l < e.length; ++l)s[e[l]] = l;
    let i = r.length;
    for(; r[i - 1] === "=";)--i;
    const o = new Uint8Array(i * t / 8 | 0);
    let a = 0, u = 0, c = 0;
    for(let l = 0; l < i; ++l){
        const d = s[r[l]];
        if (d === void 0) throw new SyntaxError(`Non-${n} character`);
        u = u << t | d, a += t, a >= 8 && (a -= 8, o[c++] = 255 & u >> a);
    }
    if (a >= t || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
    return o;
}, d5 = (r, e, t)=>{
    const n = e[e.length - 1] === "=", s = (1 << t) - 1;
    let i = "", o = 0, a = 0;
    for(let u = 0; u < r.length; ++u)for(a = a << 8 | r[u], o += 8; o > t;)o -= t, i += e[s & a >> o];
    if (o && (i += e[s & a << t - o]), n) for(; i.length * t & 7;)i += "=";
    return i;
}, At = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n })=>Hc({
        prefix: e,
        name: r,
        encode (s) {
            return d5(s, n, t);
        },
        decode (s) {
            return l5(s, n, t, r);
        }
    }), h5 = Hc({
    prefix: "\0",
    name: "identity",
    encode: (r)=>s5(r),
    decode: (r)=>i5(r)
});
var f5 = Object.freeze({
    __proto__: null,
    identity: h5
});
const p5 = At({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var g5 = Object.freeze({
    __proto__: null,
    base2: p5
});
const y5 = At({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var w5 = Object.freeze({
    __proto__: null,
    base8: y5
});
const m5 = Do({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var b5 = Object.freeze({
    __proto__: null,
    base10: m5
});
const v5 = At({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
}), E5 = At({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
});
var M5 = Object.freeze({
    __proto__: null,
    base16: v5,
    base16upper: E5
});
const N5 = At({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
}), x5 = At({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
}), I5 = At({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
}), T5 = At({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
}), D5 = At({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
}), _5 = At({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
}), A5 = At({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
}), S5 = At({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
}), O5 = At({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});
var j5 = Object.freeze({
    __proto__: null,
    base32: N5,
    base32upper: x5,
    base32pad: I5,
    base32padupper: T5,
    base32hex: D5,
    base32hexupper: _5,
    base32hexpad: A5,
    base32hexpadupper: S5,
    base32z: O5
});
const C5 = Do({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), L5 = Do({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var k5 = Object.freeze({
    __proto__: null,
    base36: C5,
    base36upper: L5
});
const z5 = Do({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), P5 = Do({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var U5 = Object.freeze({
    __proto__: null,
    base58btc: z5,
    base58flickr: P5
});
const R5 = At({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
}), $5 = At({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
}), B5 = At({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
}), F5 = At({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});
var q5 = Object.freeze({
    __proto__: null,
    base64: R5,
    base64pad: $5,
    base64url: B5,
    base64urlpad: F5
});
const R1 = Array.from(""), Q5 = R1.reduce((r, e, t)=>(r[t] = e, r), []), V5 = R1.reduce((r, e, t)=>(r[e.codePointAt(0)] = t, r), []);
function Y5(r) {
    return r.reduce((e, t)=>(e += Q5[t], e), "");
}
function G5(r) {
    const e = [];
    for (const t of r){
        const n = V5[t.codePointAt(0)];
        if (n === void 0) throw new Error(`Non-base256emoji character: ${t}`);
        e.push(n);
    }
    return new Uint8Array(e);
}
const H5 = Hc({
    prefix: "",
    name: "base256emoji",
    encode: Y5,
    decode: G5
});
var W5 = Object.freeze({
    __proto__: null,
    base256emoji: H5
}), K5 = $1, Tg = 128, X5 = -128, Z5 = Math.pow(2, 31);
function $1(r, e, t) {
    e = e || [], t = t || 0;
    for(var n = t; r >= Z5;)e[t++] = r & 255 | Tg, r /= 128;
    for(; r & X5;)e[t++] = r & 255 | Tg, r >>>= 7;
    return e[t] = r | 0, $1.bytes = t - n + 1, e;
}
var J5 = ed, ek = 128, Dg = 127;
function ed(r, n) {
    var t = 0, n = n || 0, s = 0, i = n, o, a = r.length;
    do {
        if (i >= a) throw ed.bytes = 0, new RangeError("Could not decode varint");
        o = r[i++], t += s < 28 ? (o & Dg) << s : (o & Dg) * Math.pow(2, s), s += 7;
    }while (o >= ek)
    return ed.bytes = i - n, t;
}
var tk = Math.pow(2, 7), rk = Math.pow(2, 14), nk = Math.pow(2, 21), ik = Math.pow(2, 28), sk = Math.pow(2, 35), ok = Math.pow(2, 42), ak = Math.pow(2, 49), ck = Math.pow(2, 56), uk = Math.pow(2, 63), lk = function(r) {
    return r < tk ? 1 : r < rk ? 2 : r < nk ? 3 : r < ik ? 4 : r < sk ? 5 : r < ok ? 6 : r < ak ? 7 : r < ck ? 8 : r < uk ? 9 : 10;
}, dk = {
    encode: K5,
    decode: J5,
    encodingLength: lk
}, B1 = dk;
const _g = (r, e, t = 0)=>(B1.encode(r, e, t), e), Ag = (r)=>B1.encodingLength(r), td = (r, e)=>{
    const t = e.byteLength, n = Ag(r), s = n + Ag(t), i = new Uint8Array(s + t);
    return _g(r, i, 0), _g(t, i, n), i.set(e, s), new hk(r, t, e, i);
};
class hk {
    constructor(e, t, n, s){
        this.code = e, this.size = t, this.digest = n, this.bytes = s;
    }
}
const F1 = ({ name: r, code: e, encode: t })=>new fk(r, e, t);
class fk {
    constructor(e, t, n){
        this.name = e, this.code = t, this.encode = n;
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const t = this.encode(e);
            return t instanceof Uint8Array ? td(this.code, t) : t.then((n)=>td(this.code, n));
        } else throw Error("Unknown type, must be binary type");
    }
}
const q1 = (r)=>async (e)=>new Uint8Array(await crypto.subtle.digest(r, e)), pk = F1({
    name: "sha2-256",
    code: 18,
    encode: q1("SHA-256")
}), gk = F1({
    name: "sha2-512",
    code: 19,
    encode: q1("SHA-512")
});
var yk = Object.freeze({
    __proto__: null,
    sha256: pk,
    sha512: gk
});
const Q1 = 0, wk = "identity", V1 = P1, mk = (r)=>td(Q1, V1(r)), bk = {
    code: Q1,
    name: wk,
    encode: V1,
    digest: mk
};
var vk = Object.freeze({
    __proto__: null,
    identity: bk
});
new TextEncoder(), new TextDecoder();
const Sg = {
    ...f5,
    ...g5,
    ...w5,
    ...b5,
    ...M5,
    ...j5,
    ...k5,
    ...U5,
    ...q5,
    ...W5
};
({
    ...yk,
    ...vk
});
function Y1(r) {
    return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function Ek(r = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Y1(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function G1(r, e, t, n) {
    return {
        name: r,
        prefix: e,
        encoder: {
            name: r,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: n
        }
    };
}
const Og = G1("utf8", "u", (r)=>"u" + new TextDecoder("utf8").decode(r), (r)=>new TextEncoder().encode(r.substring(1))), Ju = G1("ascii", "a", (r)=>{
    let e = "a";
    for(let t = 0; t < r.length; t++)e += String.fromCharCode(r[t]);
    return e;
}, (r)=>{
    r = r.substring(1);
    const e = Ek(r.length);
    for(let t = 0; t < r.length; t++)e[t] = r.charCodeAt(t);
    return e;
}), Mk = {
    utf8: Og,
    "utf-8": Og,
    hex: Sg.base16,
    latin1: Ju,
    ascii: Ju,
    binary: Ju,
    ...Sg
};
function Nk(r, e = "utf8") {
    const t = Mk[e];
    if (!t) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Y1(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var xk = Object.defineProperty, Ik = (r, e, t)=>e in r ? xk(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, zr = (r, e, t)=>Ik(r, typeof e != "symbol" ? e + "" : e, t);
class Tk {
    constructor(e, t){
        this.core = e, this.logger = t, zr(this, "keychain", /* @__PURE__ */ new Map()), zr(this, "name", IL), zr(this, "version", TL), zr(this, "initialized", !1), zr(this, "storagePrefix", Wr), zr(this, "init", async ()=>{
            if (!this.initialized) {
                const n = await this.getKeyChain();
                typeof n < "u" && (this.keychain = n), this.initialized = !0;
            }
        }), zr(this, "has", (n)=>(this.isInitialized(), this.keychain.has(n))), zr(this, "set", async (n, s)=>{
            this.isInitialized(), this.keychain.set(n, s), await this.persist();
        }), zr(this, "get", (n)=>{
            this.isInitialized();
            const s = this.keychain.get(n);
            if (typeof s > "u") {
                const { message: i } = ce("NO_MATCHING_KEY", `${this.name}: ${n}`);
                throw new Error(i);
            }
            return s;
        }), zr(this, "del", async (n)=>{
            this.isInitialized(), this.keychain.delete(n), await this.persist();
        }), this.core = e, this.logger = ur(t, this.name);
    }
    get context() {
        return nr(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
    }
    async setKeyChain(e) {
        await this.core.storage.setItem(this.storageKey, Ul(e));
    }
    async getKeyChain() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? Rl(e) : void 0;
    }
    async persist() {
        await this.setKeyChain(this.keychain);
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
}
var Dk = Object.defineProperty, _k = (r, e, t)=>e in r ? Dk(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, yt = (r, e, t)=>_k(r, typeof e != "symbol" ? e + "" : e, t);
class Ak {
    constructor(e, t, n){
        this.core = e, this.logger = t, yt(this, "name", NL), yt(this, "keychain"), yt(this, "randomSessionIdentifier", Kl()), yt(this, "initialized", !1), yt(this, "clientId"), yt(this, "init", async ()=>{
            this.initialized || (await this.keychain.init(), this.initialized = !0);
        }), yt(this, "hasKeys", (s)=>(this.isInitialized(), this.keychain.has(s))), yt(this, "getClientId", async ()=>{
            if (this.isInitialized(), this.clientId) return this.clientId;
            const s = await this.getClientSeed(), i = Gf(s), o = fw(i.publicKey);
            return this.clientId = o, o;
        }), yt(this, "generateKeyPair", ()=>{
            this.isInitialized();
            const s = Lj();
            return this.setPrivateKey(s.publicKey, s.privateKey);
        }), yt(this, "signJWT", async (s)=>{
            this.isInitialized();
            const i = await this.getClientSeed(), o = Gf(i), a = this.randomSessionIdentifier;
            return await oD(a, s, xL, o);
        }), yt(this, "generateSharedKey", (s, i, o)=>{
            this.isInitialized();
            const a = this.getPrivateKey(s), u = kj(a, i);
            return this.setSymKey(u, o);
        }), yt(this, "setSymKey", async (s, i)=>{
            this.isInitialized();
            const o = i || Ma(s);
            return await this.keychain.set(o, s), o;
        }), yt(this, "deleteKeyPair", async (s)=>{
            this.isInitialized(), await this.keychain.del(s);
        }), yt(this, "deleteSymKey", async (s)=>{
            this.isInitialized(), await this.keychain.del(s);
        }), yt(this, "encode", async (s, i, o)=>{
            this.isInitialized();
            const a = N1(o), u = Mi(i);
            if (ig(a)) return Uj(u, o == null ? void 0 : o.encoding);
            if (ng(a)) {
                const h = a.senderPublicKey, f = a.receiverPublicKey;
                s = await this.generateSharedKey(h, f);
            }
            const c = this.getSymKey(s), { type: l, senderPublicKey: d } = a;
            return zj({
                type: l,
                symKey: c,
                message: u,
                senderPublicKey: d,
                encoding: o == null ? void 0 : o.encoding
            });
        }), yt(this, "decode", async (s, i, o)=>{
            this.isInitialized();
            const a = $j(i, o);
            if (ig(a)) {
                const u = Rj(i, o == null ? void 0 : o.encoding);
                return ss(u);
            }
            if (ng(a)) {
                const u = a.receiverPublicKey, c = a.senderPublicKey;
                s = await this.generateSharedKey(u, c);
            }
            try {
                const u = this.getSymKey(s), c = Pj({
                    symKey: u,
                    encoded: i,
                    encoding: o == null ? void 0 : o.encoding
                });
                return ss(c);
            } catch (u) {
                this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(u);
            }
        }), yt(this, "getPayloadType", (s, i = Zt)=>{
            const o = fo({
                encoded: s,
                encoding: i
            });
            return Ti(o.type);
        }), yt(this, "getPayloadSenderPublicKey", (s, i = Zt)=>{
            const o = fo({
                encoded: s,
                encoding: i
            });
            return o.senderPublicKey ? tr(o.senderPublicKey, qt) : void 0;
        }), this.core = e, this.logger = ur(t, this.name), this.keychain = n || new Tk(this.core, this.logger);
    }
    get context() {
        return nr(this.logger);
    }
    async setPrivateKey(e, t) {
        return await this.keychain.set(e, t), e;
    }
    getPrivateKey(e) {
        return this.keychain.get(e);
    }
    async getClientSeed() {
        let e = "";
        try {
            e = this.keychain.get(xg);
        } catch  {
            e = Kl(), await this.keychain.set(xg, e);
        }
        return Nk(e, "base16");
    }
    getSymKey(e) {
        return this.keychain.get(e);
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
}
var Sk = Object.defineProperty, Ok = Object.defineProperties, jk = Object.getOwnPropertyDescriptors, jg = Object.getOwnPropertySymbols, Ck = Object.prototype.hasOwnProperty, Lk = Object.prototype.propertyIsEnumerable, rd = (r, e, t)=>e in r ? Sk(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, kk = (r, e)=>{
    for(var t in e || (e = {}))Ck.call(e, t) && rd(r, t, e[t]);
    if (jg) for (var t of jg(e))Lk.call(e, t) && rd(r, t, e[t]);
    return r;
}, zk = (r, e)=>Ok(r, jk(e)), ir = (r, e, t)=>rd(r, typeof e != "symbol" ? e + "" : e, t);
class Pk extends iI {
    constructor(e, t){
        super(e, t), this.logger = e, this.core = t, ir(this, "messages", /* @__PURE__ */ new Map()), ir(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), ir(this, "name", DL), ir(this, "version", _L), ir(this, "initialized", !1), ir(this, "storagePrefix", Wr), ir(this, "init", async ()=>{
            if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                    const n = await this.getRelayerMessages();
                    typeof n < "u" && (this.messages = n);
                    const s = await this.getRelayerMessagesWithoutClientAck();
                    typeof s < "u" && (this.messagesWithoutClientAck = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                        type: "method",
                        method: "restore",
                        size: this.messages.size
                    });
                } catch (n) {
                    this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
                } finally{
                    this.initialized = !0;
                }
            }
        }), ir(this, "set", async (n, s, i)=>{
            this.isInitialized();
            const o = yr(s);
            let a = this.messages.get(n);
            if (typeof a > "u" && (a = {}), typeof a[o] < "u") return o;
            if (a[o] = s, this.messages.set(n, a), i === Na.inbound) {
                const u = this.messagesWithoutClientAck.get(n) || {};
                this.messagesWithoutClientAck.set(n, zk(kk({}, u), {
                    [o]: s
                }));
            }
            return await this.persist(), o;
        }), ir(this, "get", (n)=>{
            this.isInitialized();
            let s = this.messages.get(n);
            return typeof s > "u" && (s = {}), s;
        }), ir(this, "getWithoutAck", (n)=>{
            this.isInitialized();
            const s = {};
            for (const i of n){
                const o = this.messagesWithoutClientAck.get(i) || {};
                s[i] = Object.values(o);
            }
            return s;
        }), ir(this, "has", (n, s)=>{
            this.isInitialized();
            const i = this.get(n), o = yr(s);
            return typeof i[o] < "u";
        }), ir(this, "ack", async (n, s)=>{
            this.isInitialized();
            const i = this.messagesWithoutClientAck.get(n);
            if (typeof i > "u") return;
            const o = yr(s);
            delete i[o], Object.keys(i).length === 0 ? this.messagesWithoutClientAck.delete(n) : this.messagesWithoutClientAck.set(n, i), await this.persist();
        }), ir(this, "del", async (n)=>{
            this.isInitialized(), this.messages.delete(n), this.messagesWithoutClientAck.delete(n), await this.persist();
        }), this.logger = ur(e, this.name), this.core = t;
    }
    get context() {
        return nr(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
    }
    get storageKeyWithoutClientAck() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
    }
    async setRelayerMessages(e) {
        await this.core.storage.setItem(this.storageKey, Ul(e));
    }
    async setRelayerMessagesWithoutClientAck(e) {
        await this.core.storage.setItem(this.storageKeyWithoutClientAck, Ul(e));
    }
    async getRelayerMessages() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? Rl(e) : void 0;
    }
    async getRelayerMessagesWithoutClientAck() {
        const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
        return typeof e < "u" ? Rl(e) : void 0;
    }
    async persist() {
        await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
}
var Uk = Object.defineProperty, Rk = Object.defineProperties, $k = Object.getOwnPropertyDescriptors, Cg = Object.getOwnPropertySymbols, Bk = Object.prototype.hasOwnProperty, Fk = Object.prototype.propertyIsEnumerable, nd = (r, e, t)=>e in r ? Uk(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Qi = (r, e)=>{
    for(var t in e || (e = {}))Bk.call(e, t) && nd(r, t, e[t]);
    if (Cg) for (var t of Cg(e))Fk.call(e, t) && nd(r, t, e[t]);
    return r;
}, Lg = (r, e)=>Rk(r, $k(e)), hr = (r, e, t)=>nd(r, typeof e != "symbol" ? e + "" : e, t);
class qk extends sI {
    constructor(e, t){
        super(e, t), this.relayer = e, this.logger = t, hr(this, "events", new rr.EventEmitter()), hr(this, "name", SL), hr(this, "queue", /* @__PURE__ */ new Map()), hr(this, "publishTimeout", ue.toMiliseconds(ue.ONE_MINUTE)), hr(this, "initialPublishTimeout", ue.toMiliseconds(ue.ONE_SECOND * 15)), hr(this, "needsTransportRestart", !1), hr(this, "publish", async (n, s, i)=>{
            var o, a, u, c, l;
            this.logger.debug("Publishing Payload"), this.logger.trace({
                type: "method",
                method: "publish",
                params: {
                    topic: n,
                    message: s,
                    opts: i
                }
            });
            const d = (i == null ? void 0 : i.ttl) || AL, h = (i == null ? void 0 : i.prompt) || !1, f = (i == null ? void 0 : i.tag) || 0, g = (i == null ? void 0 : i.id) || Yn().toString(), p = Xi(Va().protocol), m = {
                id: g,
                method: (i == null ? void 0 : i.publishMethod) || p.publish,
                params: Qi({
                    topic: n,
                    message: s,
                    ttl: d,
                    prompt: h,
                    tag: f,
                    attestation: i == null ? void 0 : i.attestation
                }, i == null ? void 0 : i.tvf)
            }, x = `Failed to publish payload, please try again. id:${g} tag:${f}`;
            try {
                pt((o = m.params) == null ? void 0 : o.prompt) && ((a = m.params) == null || delete a.prompt), pt((u = m.params) == null ? void 0 : u.tag) && ((c = m.params) == null || delete c.tag);
                const _ = new Promise(async (v)=>{
                    const N = ({ id: z })=>{
                        var P;
                        ((P = m.id) == null ? void 0 : P.toString()) === z.toString() && (this.removeRequestFromQueue(z), this.relayer.events.removeListener(st.publish, N), v());
                    };
                    this.relayer.events.on(st.publish, N);
                    const O = Yr(new Promise((z, P)=>{
                        this.rpcPublish(m, i).then(z).catch((U)=>{
                            this.logger.warn(U, U == null ? void 0 : U.message), P(U);
                        });
                    }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${g} tag:${f}`);
                    try {
                        await O, this.events.removeListener(st.publish, N);
                    } catch (z) {
                        this.queue.set(g, {
                            request: m,
                            opts: i,
                            attempt: 1
                        }), this.logger.warn(z, z == null ? void 0 : z.message);
                    }
                });
                this.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                        id: g,
                        topic: n,
                        message: s,
                        opts: i
                    }
                }), await Yr(_, this.publishTimeout, x);
            } catch (_) {
                if (this.logger.debug("Failed to Publish Payload"), this.logger.error(_), (l = i == null ? void 0 : i.internal) != null && l.throwOnFailedPublish) throw _;
            } finally{
                this.queue.delete(g);
            }
        }), hr(this, "publishCustom", async (n)=>{
            var s, i, o, a, u;
            this.logger.debug("Publishing custom payload"), this.logger.trace({
                type: "method",
                method: "publishCustom",
                params: n
            });
            const { payload: c, opts: l = {} } = n, { attestation: d, tvf: h, publishMethod: f, prompt: g, tag: p, ttl: m = ue.FIVE_MINUTES } = l, x = l.id || Yn().toString(), _ = Xi(Va().protocol), v = f || _.publish, N = {
                id: x,
                method: v,
                params: Qi(Lg(Qi({}, c), {
                    ttl: m,
                    prompt: g,
                    tag: p,
                    attestation: d
                }), h)
            }, O = `Failed to publish custom payload, please try again. id:${x} tag:${p}`;
            try {
                pt((s = N.params) == null ? void 0 : s.prompt) && ((i = N.params) == null || delete i.prompt), pt((o = N.params) == null ? void 0 : o.tag) && ((a = N.params) == null || delete a.tag);
                const z = new Promise(async (P)=>{
                    const U = ({ id: G })=>{
                        var F;
                        ((F = N.id) == null ? void 0 : F.toString()) === G.toString() && (this.removeRequestFromQueue(G), this.relayer.events.removeListener(st.publish, U), P());
                    };
                    this.relayer.events.on(st.publish, U);
                    const R = Yr(new Promise((G, F)=>{
                        this.rpcPublish(N, l).then(G).catch((H)=>{
                            this.logger.warn(H, H == null ? void 0 : H.message), F(H);
                        });
                    }), this.initialPublishTimeout, `Failed initial custom payload publish, retrying.... method:${v} id:${x} tag:${p}`);
                    try {
                        await R, this.events.removeListener(st.publish, U);
                    } catch (G) {
                        this.queue.set(x, {
                            request: N,
                            opts: l,
                            attempt: 1
                        }), this.logger.warn(G, G == null ? void 0 : G.message);
                    }
                });
                this.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                        id: x,
                        payload: c,
                        opts: l
                    }
                }), await Yr(z, this.publishTimeout, O);
            } catch (z) {
                if (this.logger.debug("Failed to Publish Payload"), this.logger.error(z), (u = l == null ? void 0 : l.internal) != null && u.throwOnFailedPublish) throw z;
            } finally{
                this.queue.delete(x);
            }
        }), hr(this, "on", (n, s)=>{
            this.events.on(n, s);
        }), hr(this, "once", (n, s)=>{
            this.events.once(n, s);
        }), hr(this, "off", (n, s)=>{
            this.events.off(n, s);
        }), hr(this, "removeListener", (n, s)=>{
            this.events.removeListener(n, s);
        }), this.relayer = e, this.logger = ur(t, this.name), this.registerEventListeners();
    }
    get context() {
        return nr(this.logger);
    }
    async rpcPublish(e, t) {
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: e
        });
        const n = await this.relayer.request(e);
        return this.relayer.events.emit(st.publish, Qi(Qi({}, e), t)), this.logger.debug("Successfully Published Payload"), n;
    }
    removeRequestFromQueue(e) {
        this.queue.delete(e);
    }
    checkQueue() {
        this.queue.forEach(async (e, t)=>{
            var n;
            const s = e.attempt + 1;
            this.queue.set(t, Lg(Qi({}, e), {
                attempt: s
            })), this.logger.warn({}, `Publisher: queue->publishing: ${e.request.id}, tag: ${(n = e.request.params) == null ? void 0 : n.tag}, attempt: ${s}`), await this.rpcPublish(e.request, e.opts), this.logger.warn({}, `Publisher: queue->published: ${e.request.id}`);
        });
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(Oi.pulse, ()=>{
            if (this.needsTransportRestart) {
                this.needsTransportRestart = !1, this.relayer.events.emit(st.connection_stalled);
                return;
            }
            this.checkQueue();
        }), this.relayer.on(st.message_ack, (e)=>{
            this.removeRequestFromQueue(e.id.toString());
        });
    }
}
var Qk = Object.defineProperty, Vk = (r, e, t)=>e in r ? Qk(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Vi = (r, e, t)=>Vk(r, typeof e != "symbol" ? e + "" : e, t);
class Yk {
    constructor(){
        Vi(this, "map", /* @__PURE__ */ new Map()), Vi(this, "set", (e, t)=>{
            const n = this.get(e);
            this.exists(e, t) || this.map.set(e, [
                ...n,
                t
            ]);
        }), Vi(this, "get", (e)=>this.map.get(e) || []), Vi(this, "exists", (e, t)=>this.get(e).includes(t)), Vi(this, "delete", (e, t)=>{
            if (typeof t > "u") {
                this.map.delete(e);
                return;
            }
            if (!this.map.has(e)) return;
            const n = this.get(e);
            if (!this.exists(e, t)) return;
            const s = n.filter((i)=>i !== t);
            if (!s.length) {
                this.map.delete(e);
                return;
            }
            this.map.set(e, s);
        }), Vi(this, "clear", ()=>{
            this.map.clear();
        });
    }
    get topics() {
        return Array.from(this.map.keys());
    }
}
var Gk = Object.defineProperty, Hk = Object.defineProperties, Wk = Object.getOwnPropertyDescriptors, kg = Object.getOwnPropertySymbols, Kk = Object.prototype.hasOwnProperty, Xk = Object.prototype.propertyIsEnumerable, id = (r, e, t)=>e in r ? Gk(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, qs = (r, e)=>{
    for(var t in e || (e = {}))Kk.call(e, t) && id(r, t, e[t]);
    if (kg) for (var t of kg(e))Xk.call(e, t) && id(r, t, e[t]);
    return r;
}, el = (r, e)=>Hk(r, Wk(e)), qe = (r, e, t)=>id(r, typeof e != "symbol" ? e + "" : e, t);
class Zk extends cI {
    constructor(e, t){
        super(e, t), this.relayer = e, this.logger = t, qe(this, "subscriptions", /* @__PURE__ */ new Map()), qe(this, "topicMap", new Yk()), qe(this, "events", new rr.EventEmitter()), qe(this, "name", PL), qe(this, "version", UL), qe(this, "pending", /* @__PURE__ */ new Map()), qe(this, "cached", []), qe(this, "initialized", !1), qe(this, "storagePrefix", Wr), qe(this, "subscribeTimeout", ue.toMiliseconds(ue.ONE_MINUTE)), qe(this, "initialSubscribeTimeout", ue.toMiliseconds(ue.ONE_SECOND * 15)), qe(this, "clientId"), qe(this, "batchSubscribeTopicsLimit", 500), qe(this, "init", async ()=>{
            this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = !0;
        }), qe(this, "subscribe", async (n, s)=>{
            var i;
            this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
                type: "method",
                method: "subscribe",
                params: {
                    topic: n,
                    opts: s
                }
            });
            try {
                const o = Va(s), a = {
                    topic: n,
                    relay: o,
                    transportType: s == null ? void 0 : s.transportType
                };
                (i = s == null ? void 0 : s.internal) != null && i.skipSubscribe || this.pending.set(n, a);
                const u = await this.rpcSubscribe(n, o, s);
                return typeof u == "string" && (this.onSubscribe(u, a), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: {
                        topic: n,
                        opts: s
                    }
                })), u;
            } catch (o) {
                throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(o), o;
            }
        }), qe(this, "unsubscribe", async (n, s)=>{
            this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(n, s.id, s) : await this.unsubscribeByTopic(n, s);
        }), qe(this, "isSubscribed", (n)=>new Promise((s)=>{
                s(this.topicMap.topics.includes(n));
            })), qe(this, "isKnownTopic", (n)=>new Promise((s)=>{
                s(this.topicMap.topics.includes(n) || this.pending.has(n) || this.cached.some((i)=>i.topic === n));
            })), qe(this, "on", (n, s)=>{
            this.events.on(n, s);
        }), qe(this, "once", (n, s)=>{
            this.events.once(n, s);
        }), qe(this, "off", (n, s)=>{
            this.events.off(n, s);
        }), qe(this, "removeListener", (n, s)=>{
            this.events.removeListener(n, s);
        }), qe(this, "start", async ()=>{
            await this.onConnect();
        }), qe(this, "stop", async ()=>{
            await this.onDisconnect();
        }), qe(this, "restart", async ()=>{
            await this.restore(), await this.onRestart();
        }), qe(this, "checkPending", async ()=>{
            if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
            const n = [];
            this.pending.forEach((s)=>{
                n.push(s);
            }), await this.batchSubscribe(n);
        }), qe(this, "registerEventListeners", ()=>{
            this.relayer.core.heartbeat.on(Oi.pulse, async ()=>{
                await this.checkPending();
            }), this.events.on(sr.created, async (n)=>{
                const s = sr.created;
                this.logger.info(`Emitting ${s}`), this.logger.debug({
                    type: "event",
                    event: s,
                    data: n
                }), await this.persist();
            }), this.events.on(sr.deleted, async (n)=>{
                const s = sr.deleted;
                this.logger.info(`Emitting ${s}`), this.logger.debug({
                    type: "event",
                    event: s,
                    data: n
                }), await this.persist();
            });
        }), this.relayer = e, this.logger = ur(t, this.name), this.clientId = "";
    }
    get context() {
        return nr(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
    }
    get length() {
        return this.subscriptions.size;
    }
    get ids() {
        return Array.from(this.subscriptions.keys());
    }
    get values() {
        return Array.from(this.subscriptions.values());
    }
    get topics() {
        return this.topicMap.topics;
    }
    get hasAnyTopics() {
        return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
    }
    hasSubscription(e, t) {
        let n = !1;
        try {
            n = this.getSubscription(e).topic === t;
        } catch  {}
        return n;
    }
    reset() {
        this.cached = [], this.initialized = !0;
    }
    onDisable() {
        this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
    }
    async unsubscribeByTopic(e, t) {
        const n = this.topicMap.get(e);
        await Promise.all(n.map(async (s)=>await this.unsubscribeById(e, s, t)));
    }
    async unsubscribeById(e, t, n) {
        this.logger.debug("Unsubscribing Topic"), this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: {
                topic: e,
                id: t,
                opts: n
            }
        });
        try {
            const s = Va(n);
            await this.restartToComplete({
                topic: e,
                id: t,
                relay: s
            }), await this.rpcUnsubscribe(e, t, s);
            const i = rt("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, i), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: {
                    topic: e,
                    id: t,
                    opts: n
                }
            });
        } catch (s) {
            throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
        }
    }
    async rpcSubscribe(e, t, n) {
        var s, i;
        const o = await this.getSubscriptionId(e);
        if ((s = n == null ? void 0 : n.internal) != null && s.skipSubscribe) return o;
        (!n || (n == null ? void 0 : n.transportType) === Ge.relay) && await this.restartToComplete({
            topic: e,
            id: e,
            relay: t
        });
        const a = {
            method: Xi(t.protocol).subscribe,
            params: {
                topic: e
            }
        };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: a
        });
        const u = (i = n == null ? void 0 : n.internal) == null ? void 0 : i.throwOnFailedPublish;
        try {
            if ((n == null ? void 0 : n.transportType) === Ge.link_mode) return setTimeout(()=>{
                (this.relayer.connected || this.relayer.connecting) && this.relayer.request(a).catch((d)=>this.logger.warn(d));
            }, ue.toMiliseconds(ue.ONE_SECOND)), o;
            const c = new Promise(async (d)=>{
                const h = (f)=>{
                    f.topic === e && (this.events.removeListener(sr.created, h), d(f.id));
                };
                this.events.on(sr.created, h);
                try {
                    const f = await Yr(new Promise((g, p)=>{
                        this.relayer.request(a).catch((m)=>{
                            this.logger.warn(m, m == null ? void 0 : m.message), p(m);
                        }).then(g);
                    }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
                    this.events.removeListener(sr.created, h), d(f);
                } catch  {}
            }), l = await Yr(c, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
            if (!l && u) throw new Error(`Subscribing to ${e} failed, please try again`);
            return l ? o : null;
        } catch (c) {
            if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(st.connection_stalled), u) throw c;
        }
        return null;
    }
    async rpcBatchSubscribe(e) {
        if (!e.length) return;
        const t = e[0].relay, n = {
            method: Xi(t.protocol).batchSubscribe,
            params: {
                topics: e.map((s)=>s.topic)
            }
        };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: n
        });
        try {
            await await Yr(new Promise((s)=>{
                this.relayer.request(n).catch((i)=>this.logger.warn(i)).then(s);
            }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
        } catch  {
            this.relayer.events.emit(st.connection_stalled);
        }
    }
    async rpcBatchFetchMessages(e) {
        if (!e.length) return;
        const t = e[0].relay, n = {
            method: Xi(t.protocol).batchFetchMessages,
            params: {
                topics: e.map((i)=>i.topic)
            }
        };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: n
        });
        let s;
        try {
            s = await await Yr(new Promise((i, o)=>{
                this.relayer.request(n).catch((a)=>{
                    this.logger.warn(a), o(a);
                }).then(i);
            }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
        } catch  {
            this.relayer.events.emit(st.connection_stalled);
        }
        return s;
    }
    rpcUnsubscribe(e, t, n) {
        const s = {
            method: Xi(n.protocol).unsubscribe,
            params: {
                topic: e,
                id: t
            }
        };
        return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: s
        }), this.relayer.request(s);
    }
    onSubscribe(e, t) {
        this.setSubscription(e, el(qs({}, t), {
            id: e
        })), this.pending.delete(t.topic);
    }
    onBatchSubscribe(e) {
        e.length && e.forEach((t)=>{
            this.setSubscription(t.id, qs({}, t)), this.pending.delete(t.topic);
        });
    }
    async onUnsubscribe(e, t, n) {
        this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, n), await this.relayer.messages.del(e);
    }
    async setRelayerSubscriptions(e) {
        await this.relayer.core.storage.setItem(this.storageKey, e);
    }
    async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey);
    }
    setSubscription(e, t) {
        this.logger.debug("Setting subscription"), this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: e,
            subscription: t
        }), this.addSubscription(e, t);
    }
    addSubscription(e, t) {
        this.subscriptions.set(e, qs({}, t)), this.topicMap.set(t.topic, e), this.events.emit(sr.created, t);
    }
    getSubscription(e) {
        this.logger.debug("Getting subscription"), this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: e
        });
        const t = this.subscriptions.get(e);
        if (!t) {
            const { message: n } = ce("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(n);
        }
        return t;
    }
    deleteSubscription(e, t) {
        this.logger.debug("Deleting subscription"), this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: e,
            reason: t
        });
        const n = this.getSubscription(e);
        this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(sr.deleted, el(qs({}, n), {
            reason: t
        }));
    }
    async persist() {
        await this.setRelayerSubscriptions(this.values), this.events.emit(sr.sync);
    }
    async onRestart() {
        if (this.cached.length) {
            const e = [
                ...this.cached
            ], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
            for(let n = 0; n < t; n++){
                const s = e.splice(0, this.batchSubscribeTopicsLimit);
                await this.batchSubscribe(s);
            }
        }
        this.events.emit(sr.resubscribed);
    }
    async restore() {
        try {
            const e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length) return;
            if (this.subscriptions.size && !e.every((t)=>{
                var n;
                return t.topic === ((n = this.subscriptions.get(t.id)) == null ? void 0 : n.topic);
            })) {
                const { message: t } = ce("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
            }
            this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values
            });
        } catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
        }
    }
    async batchSubscribe(e) {
        e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t)=>el(qs({}, t), {
                id: await this.getSubscriptionId(t.topic)
            })))));
    }
    async batchFetchMessages(e) {
        if (!e.length) return;
        this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
        const t = await this.rpcBatchFetchMessages(e);
        t && t.messages && (await r4(ue.toMiliseconds(ue.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
    }
    async onConnect() {
        await this.restart(), this.reset();
    }
    onDisconnect() {
        this.onDisable();
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
    async restartToComplete(e) {
        !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
    }
    async getClientId() {
        return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
    }
    async getSubscriptionId(e) {
        return yr(e + await this.getClientId());
    }
}
var Jk = Object.defineProperty, zg = Object.getOwnPropertySymbols, ez = Object.prototype.hasOwnProperty, tz = Object.prototype.propertyIsEnumerable, sd = (r, e, t)=>e in r ? Jk(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Pg = (r, e)=>{
    for(var t in e || (e = {}))ez.call(e, t) && sd(r, t, e[t]);
    if (zg) for (var t of zg(e))tz.call(e, t) && sd(r, t, e[t]);
    return r;
}, ke = (r, e, t)=>sd(r, typeof e != "symbol" ? e + "" : e, t);
class rz extends oI {
    constructor(e){
        var t;
        super(e), ke(this, "protocol", "wc"), ke(this, "version", 2), ke(this, "core"), ke(this, "logger"), ke(this, "events", new rr.EventEmitter()), ke(this, "provider"), ke(this, "messages"), ke(this, "subscriber"), ke(this, "publisher"), ke(this, "name", jL), ke(this, "transportExplicitlyClosed", !1), ke(this, "initialized", !1), ke(this, "connectionAttemptInProgress", !1), ke(this, "relayUrl"), ke(this, "projectId"), ke(this, "packageName"), ke(this, "bundleId"), ke(this, "hasExperiencedNetworkDisruption", !1), ke(this, "pingTimeout"), ke(this, "heartBeatTimeout", ue.toMiliseconds(ue.THIRTY_SECONDS + ue.FIVE_SECONDS)), ke(this, "reconnectTimeout"), ke(this, "connectPromise"), ke(this, "reconnectInProgress", !1), ke(this, "requestsInFlight", []), ke(this, "connectTimeout", ue.toMiliseconds(ue.ONE_SECOND * 15)), ke(this, "request", async (n)=>{
            var s, i;
            this.logger.debug("Publishing Request Payload");
            const o = n.id || Yn().toString();
            await this.toEstablishConnection();
            try {
                this.logger.trace({
                    id: o,
                    method: n.method,
                    topic: (s = n.params) == null ? void 0 : s.topic
                }, "relayer.request - publishing...");
                const a = `${o}:${((i = n.params) == null ? void 0 : i.tag) || ""}`;
                this.requestsInFlight.push(a);
                const u = await this.provider.request(n);
                return this.requestsInFlight = this.requestsInFlight.filter((c)=>c !== a), u;
            } catch (a) {
                throw this.logger.debug(`Failed to Publish Request: ${o}`), a;
            }
        }), ke(this, "resetPingTimeout", ()=>{
            Ra() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(()=>{
                var n, s, i, o;
                try {
                    this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (o = (i = (s = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : s.socket) == null ? void 0 : i.terminate) == null || o.call(i);
                } catch (a) {
                    this.logger.warn(a, a == null ? void 0 : a.message);
                }
            }, this.heartBeatTimeout));
        }), ke(this, "onPayloadHandler", (n)=>{
            this.onProviderPayload(n), this.resetPingTimeout();
        }), ke(this, "onConnectHandler", ()=>{
            this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(st.connect);
        }), ke(this, "onDisconnectHandler", ()=>{
            this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
        }), ke(this, "onProviderErrorHandler", (n)=>{
            this.logger.fatal(`Fatal socket error: ${n.message}`), this.events.emit(st.error, n), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
        }), ke(this, "registerProviderListeners", ()=>{
            this.provider.on(dr.payload, this.onPayloadHandler), this.provider.on(dr.connect, this.onConnectHandler), this.provider.on(dr.disconnect, this.onDisconnectHandler), this.provider.on(dr.error, this.onProviderErrorHandler);
        }), this.core = e.core, this.logger = D1({
            logger: (t = e.logger) != null ? t : OL,
            name: this.name
        }), this.messages = new Pk(this.logger, e.core), this.subscriber = new Zk(this, this.logger), this.publisher = new qk(this, this.logger), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || k1, $O() ? this.packageName = Ip() : BO() && (this.bundleId = Ip()), this.provider = {};
    }
    async init() {
        this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([
            this.messages.init(),
            this.subscriber.init()
        ]), this.initialized = !0, this.transportOpen().catch((e)=>this.logger.warn(e, e == null ? void 0 : e.message));
    }
    get context() {
        return nr(this.logger);
    }
    get connected() {
        var e, t, n;
        return ((n = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : n.readyState) === 1 || !1;
    }
    get connecting() {
        var e, t, n;
        return ((n = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : n.readyState) === 0 || this.connectPromise !== void 0 || !1;
    }
    async publish(e, t, n) {
        this.isInitialized(), await this.publisher.publish(e, t, n), await this.recordMessageEvent({
            topic: e,
            message: t,
            publishedAt: Date.now(),
            transportType: Ge.relay
        }, Na.outbound);
    }
    async publishCustom(e) {
        this.isInitialized(), await this.publisher.publishCustom(e);
    }
    async subscribe(e, t) {
        var n, s, i;
        this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
        const o = typeof ((n = t == null ? void 0 : t.internal) == null ? void 0 : n.throwOnFailedPublish) > "u" ? !0 : (s = t == null ? void 0 : t.internal) == null ? void 0 : s.throwOnFailedPublish;
        let a = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || "", u;
        const c = (l)=>{
            l.topic === e && (this.subscriber.off(sr.created, c), u());
        };
        return await Promise.all([
            new Promise((l)=>{
                u = l, this.subscriber.on(sr.created, c);
            }),
            new Promise(async (l, d)=>{
                a = await this.subscriber.subscribe(e, Pg({
                    internal: {
                        throwOnFailedPublish: o
                    }
                }, t)).catch((h)=>{
                    o && d(h);
                }) || a, l();
            })
        ]), a;
    }
    async unsubscribe(e, t) {
        this.isInitialized(), await this.subscriber.unsubscribe(e, t);
    }
    on(e, t) {
        this.events.on(e, t);
    }
    once(e, t) {
        this.events.once(e, t);
    }
    off(e, t) {
        this.events.off(e, t);
    }
    removeListener(e, t) {
        this.events.removeListener(e, t);
    }
    async transportDisconnect() {
        this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await Yr(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(()=>this.onProviderDisconnect()) : this.onProviderDisconnect();
    }
    async transportClose() {
        this.transportExplicitlyClosed = !0, await this.transportDisconnect();
    }
    async transportOpen(e) {
        if (!this.subscriber.hasAnyTopics) {
            this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
            return;
        }
        if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, n)=>{
            await this.connect(e).then(t).catch(n).finally(()=>{
                this.connectPromise = void 0;
            });
        }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
    }
    async restartTransport(e) {
        this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
    }
    async confirmOnlineStateOrThrow() {
        if (!await wg()) throw new Error("No internet connection detected. Please restart your network and try again.");
    }
    async handleBatchMessageEvents(e) {
        if ((e == null ? void 0 : e.length) === 0) {
            this.logger.trace("Batch message events is empty. Ignoring...");
            return;
        }
        const t = e.sort((n, s)=>n.publishedAt - s.publishedAt);
        this.logger.debug(`Batch of ${t.length} message events sorted`);
        for (const n of t)try {
            await this.onMessageEvent(n);
        } catch (s) {
            this.logger.warn(s, "Error while processing batch message event: " + (s == null ? void 0 : s.message));
        }
        this.logger.trace(`Batch of ${t.length} message events processed`);
    }
    async onLinkMessageEvent(e, t) {
        const { topic: n } = e;
        if (!t.sessionExists) {
            const s = dt(ue.FIVE_MINUTES), i = {
                topic: n,
                expiry: s,
                relay: {
                    protocol: "irn"
                },
                active: !1
            };
            await this.core.pairing.pairings.set(n, i);
        }
        this.events.emit(st.message, e), await this.recordMessageEvent(e, Na.inbound);
    }
    async connect(e) {
        await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
        let t = 1;
        for(; t < 6;){
            try {
                if (this.transportExplicitlyClosed) break;
                this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (n, s)=>{
                    const i = ()=>{
                        s(new Error("Connection interrupted while trying to connect"));
                    };
                    this.provider.once(dr.disconnect, i), await Yr(new Promise((o, a)=>{
                        this.provider.connect().then(o).catch(a);
                    }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o)=>{
                        s(o);
                    }).finally(()=>{
                        this.provider.off(dr.disconnect, i), clearTimeout(this.reconnectTimeout);
                    }), await new Promise(async (o, a)=>{
                        const u = ()=>{
                            s(new Error("Connection interrupted while trying to subscribe"));
                        };
                        this.provider.once(dr.disconnect, u), await this.subscriber.start().then(o).catch(a).finally(()=>{
                            this.provider.off(dr.disconnect, u);
                        });
                    }), this.hasExperiencedNetworkDisruption = !1, n();
                });
            } catch (n) {
                await this.subscriber.stop();
                const s = n;
                this.logger.warn({}, s.message), this.hasExperiencedNetworkDisruption = !0;
            } finally{
                this.connectionAttemptInProgress = !1;
            }
            if (this.connected) {
                this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
                break;
            }
            await new Promise((n)=>setTimeout(n, ue.toMiliseconds(t * 1))), t++;
        }
    }
    startPingTimeout() {
        var e, t, n, s, i;
        if (Ra()) try {
            (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((i = (s = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : s.socket) == null || i.on("ping", ()=>{
                this.resetPingTimeout();
            })), this.resetPingTimeout();
        } catch (o) {
            this.logger.warn(o, o == null ? void 0 : o.message);
        }
    }
    async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new yL(new vL(YO({
            sdkVersion: Jl,
            protocol: this.protocol,
            version: this.version,
            relayUrl: this.relayUrl,
            projectId: this.projectId,
            auth: e,
            useOnCloseEvent: !0,
            bundleId: this.bundleId,
            packageName: this.packageName
        }))), this.registerProviderListeners();
    }
    async recordMessageEvent(e, t) {
        const { topic: n, message: s } = e;
        await this.messages.set(n, s, t);
    }
    async shouldIgnoreMessageEvent(e) {
        const { topic: t, message: n } = e;
        if (!n || n.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${n}`), !0;
        if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), !0;
        const s = this.messages.has(t, n);
        return s && this.logger.warn(`Ignoring duplicate message: ${n}`), s;
    }
    async onProviderPayload(e) {
        if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "incoming",
            payload: e
        }), hh(e)) {
            if (!e.method.endsWith(CL)) return;
            const t = e.params, { topic: n, message: s, publishedAt: i, attestation: o } = t.data, a = {
                topic: n,
                message: s,
                publishedAt: i,
                transportType: Ge.relay,
                attestation: o
            };
            this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Pg({
                type: "event",
                event: t.id
            }, a)), this.events.emit(t.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
        } else Gc(e) && this.events.emit(st.message_ack, e);
    }
    async onMessageEvent(e) {
        await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, Na.inbound), this.events.emit(st.message, e));
    }
    async acknowledgePayload(e) {
        const t = Ga(e.id, !0);
        await this.provider.connection.send(t);
    }
    unregisterProviderListeners() {
        this.provider.off(dr.payload, this.onPayloadHandler), this.provider.off(dr.connect, this.onConnectHandler), this.provider.off(dr.disconnect, this.onDisconnectHandler), this.provider.off(dr.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
    }
    async registerEventListeners() {
        let e = await wg();
        $C(async (t)=>{
            e !== t && (e = t, t ? await this.transportOpen().catch((n)=>this.logger.error(n, n == null ? void 0 : n.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
        }), this.core.heartbeat.on(Oi.pulse, async ()=>{
            if (!this.transportExplicitlyClosed && !this.connected && qC()) try {
                await this.confirmOnlineStateOrThrow(), await this.transportOpen();
            } catch (t) {
                this.logger.warn(t, t == null ? void 0 : t.message);
            }
        });
    }
    async onProviderDisconnect() {
        clearTimeout(this.pingTimeout), this.events.emit(st.disconnect), this.connectionAttemptInProgress = !1, !this.reconnectInProgress && (this.reconnectInProgress = !0, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async ()=>{
            await this.transportOpen().catch((e)=>this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = !1;
        }, ue.toMiliseconds(LL)))));
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
    async toEstablishConnection() {
        if (await this.confirmOnlineStateOrThrow(), !this.connected) {
            if (this.connectPromise) {
                await this.connectPromise;
                return;
            }
            await this.connect();
        }
    }
}
function nz(r, e) {
    return r === e || Number.isNaN(r) && Number.isNaN(e);
}
function Ug(r) {
    return Object.getOwnPropertySymbols(r).filter((e)=>Object.prototype.propertyIsEnumerable.call(r, e));
}
function Rg(r) {
    return r == null ? r === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r);
}
const iz = "[object RegExp]", sz = "[object String]", oz = "[object Number]", az = "[object Boolean]", $g = "[object Arguments]", cz = "[object Symbol]", uz = "[object Date]", lz = "[object Map]", dz = "[object Set]", hz = "[object Array]", fz = "[object Function]", pz = "[object ArrayBuffer]", tl = "[object Object]", gz = "[object Error]", yz = "[object DataView]", wz = "[object Uint8Array]", mz = "[object Uint8ClampedArray]", bz = "[object Uint16Array]", vz = "[object Uint32Array]", Ez = "[object BigUint64Array]", Mz = "[object Int8Array]", Nz = "[object Int16Array]", xz = "[object Int32Array]", Iz = "[object BigInt64Array]", Tz = "[object Float32Array]", Dz = "[object Float64Array]";
function _z() {}
function Bg(r) {
    if (!r || typeof r != "object") return !1;
    const e = Object.getPrototypeOf(r);
    return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r) === "[object Object]" : !1;
}
function Az(r, e, t) {
    return Ks(r, e, void 0, void 0, void 0, void 0, t);
}
function Ks(r, e, t, n, s, i, o) {
    const a = o(r, e, t, n, s, i);
    if (a !== void 0) return a;
    if (typeof r == typeof e) switch(typeof r){
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined":
            return r === e;
        case "number":
            return r === e || Object.is(r, e);
        case "function":
            return r === e;
        case "object":
            return no(r, e, i, o);
    }
    return no(r, e, i, o);
}
function no(r, e, t, n) {
    if (Object.is(r, e)) return !0;
    let s = Rg(r), i = Rg(e);
    if (s === $g && (s = tl), i === $g && (i = tl), s !== i) return !1;
    switch(s){
        case sz:
            return r.toString() === e.toString();
        case oz:
            {
                const u = r.valueOf(), c = e.valueOf();
                return nz(u, c);
            }
        case az:
        case uz:
        case cz:
            return Object.is(r.valueOf(), e.valueOf());
        case iz:
            return r.source === e.source && r.flags === e.flags;
        case fz:
            return r === e;
    }
    t = t ?? /* @__PURE__ */ new Map();
    const o = t.get(r), a = t.get(e);
    if (o != null && a != null) return o === e;
    t.set(r, e), t.set(e, r);
    try {
        switch(s){
            case lz:
                {
                    if (r.size !== e.size) return !1;
                    for (const [u, c] of r.entries())if (!e.has(u) || !Ks(c, e.get(u), u, r, e, t, n)) return !1;
                    return !0;
                }
            case dz:
                {
                    if (r.size !== e.size) return !1;
                    const u = Array.from(r.values()), c = Array.from(e.values());
                    for(let l = 0; l < u.length; l++){
                        const d = u[l], h = c.findIndex((f)=>Ks(d, f, void 0, r, e, t, n));
                        if (h === -1) return !1;
                        c.splice(h, 1);
                    }
                    return !0;
                }
            case hz:
            case wz:
            case mz:
            case bz:
            case vz:
            case Ez:
            case Mz:
            case Nz:
            case xz:
            case Iz:
            case Tz:
            case Dz:
                {
                    if (typeof ye.Buffer < "u" && ye.Buffer.isBuffer(r) !== ye.Buffer.isBuffer(e) || r.length !== e.length) return !1;
                    for(let u = 0; u < r.length; u++)if (!Ks(r[u], e[u], u, r, e, t, n)) return !1;
                    return !0;
                }
            case pz:
                return r.byteLength !== e.byteLength ? !1 : no(new Uint8Array(r), new Uint8Array(e), t, n);
            case yz:
                return r.byteLength !== e.byteLength || r.byteOffset !== e.byteOffset ? !1 : no(new Uint8Array(r), new Uint8Array(e), t, n);
            case gz:
                return r.name === e.name && r.message === e.message;
            case tl:
                {
                    if (!(no(r.constructor, e.constructor, t, n) || Bg(r) && Bg(e))) return !1;
                    const u = [
                        ...Object.keys(r),
                        ...Ug(r)
                    ], c = [
                        ...Object.keys(e),
                        ...Ug(e)
                    ];
                    if (u.length !== c.length) return !1;
                    for(let l = 0; l < u.length; l++){
                        const d = u[l], h = r[d];
                        if (!Object.hasOwn(e, d)) return !1;
                        const f = e[d];
                        if (!Ks(h, f, d, r, e, t, n)) return !1;
                    }
                    return !0;
                }
            default:
                return !1;
        }
    } finally{
        t.delete(r), t.delete(e);
    }
}
function Sz(r, e) {
    return Az(r, e, _z);
}
var Oz = Object.defineProperty, Fg = Object.getOwnPropertySymbols, jz = Object.prototype.hasOwnProperty, Cz = Object.prototype.propertyIsEnumerable, od = (r, e, t)=>e in r ? Oz(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, qg = (r, e)=>{
    for(var t in e || (e = {}))jz.call(e, t) && od(r, t, e[t]);
    if (Fg) for (var t of Fg(e))Cz.call(e, t) && od(r, t, e[t]);
    return r;
}, Yt = (r, e, t)=>od(r, typeof e != "symbol" ? e + "" : e, t);
class ki extends aI {
    constructor(e, t, n, s = Wr, i = void 0){
        super(e, t, n, s), this.core = e, this.logger = t, this.name = n, Yt(this, "map", /* @__PURE__ */ new Map()), Yt(this, "version", kL), Yt(this, "cached", []), Yt(this, "initialized", !1), Yt(this, "getKey"), Yt(this, "storagePrefix", Wr), Yt(this, "recentlyDeleted", []), Yt(this, "recentlyDeletedLimit", 200), Yt(this, "init", async ()=>{
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o)=>{
                this.getKey && o !== null && !pt(o) ? this.map.set(this.getKey(o), o) : wC(o) ? this.map.set(o.id, o) : mC(o) && this.map.set(o.topic, o);
            }), this.cached = [], this.initialized = !0);
        }), Yt(this, "set", async (o, a)=>{
            this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({
                type: "method",
                method: "set",
                key: o,
                value: a
            }), this.map.set(o, a), await this.persist());
        }), Yt(this, "get", (o)=>(this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
                type: "method",
                method: "get",
                key: o
            }), this.getData(o))), Yt(this, "getAll", (o)=>(this.isInitialized(), o ? this.values.filter((a)=>Object.keys(o).every((u)=>Sz(a[u], o[u]))) : this.values)), Yt(this, "update", async (o, a)=>{
            this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
                type: "method",
                method: "update",
                key: o,
                update: a
            });
            const u = qg(qg({}, this.getData(o)), a);
            this.map.set(o, u), await this.persist();
        }), Yt(this, "delete", async (o, a)=>{
            this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({
                type: "method",
                method: "delete",
                key: o,
                reason: a
            }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
        }), this.logger = ur(t, this.name), this.storagePrefix = s, this.getKey = i;
    }
    get context() {
        return nr(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
    }
    get length() {
        return this.map.size;
    }
    get keys() {
        return Array.from(this.map.keys());
    }
    get values() {
        return Array.from(this.map.values());
    }
    addToRecentlyDeleted(e) {
        this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
    }
    async setDataStore(e) {
        await this.core.storage.setItem(this.storageKey, e);
    }
    async getDataStore() {
        return await this.core.storage.getItem(this.storageKey);
    }
    getData(e) {
        const t = this.map.get(e);
        if (!t) {
            if (this.recentlyDeleted.includes(e)) {
                const { message: s } = ce("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
                throw this.logger.error(s), new Error(s);
            }
            const { message: n } = ce("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.error(n), new Error(n);
        }
        return t;
    }
    async persist() {
        await this.setDataStore(this.values);
    }
    async restore() {
        try {
            const e = await this.getDataStore();
            if (typeof e > "u" || !e.length) return;
            if (this.map.size) {
                const { message: t } = ce("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t), new Error(t);
            }
            this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values
            });
        } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
}
var Lz = Object.defineProperty, kz = (r, e, t)=>e in r ? Lz(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, je = (r, e, t)=>kz(r, typeof e != "symbol" ? e + "" : e, t);
class zz {
    constructor(e, t){
        this.core = e, this.logger = t, je(this, "name", RL), je(this, "version", $L), je(this, "events", new Md()), je(this, "pairings"), je(this, "initialized", !1), je(this, "storagePrefix", Wr), je(this, "ignoredPayloadTypes", [
            pn
        ]), je(this, "registeredMethods", []), je(this, "init", async ()=>{
            this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
        }), je(this, "register", ({ methods: n })=>{
            this.isInitialized(), this.registeredMethods = [
                .../* @__PURE__ */ new Set([
                    ...this.registeredMethods,
                    ...n
                ])
            ];
        }), je(this, "create", async (n)=>{
            this.isInitialized();
            const s = Kl(), i = await this.core.crypto.setSymKey(s), o = dt(ue.FIVE_MINUTES), a = {
                protocol: L1
            }, u = {
                topic: i,
                expiry: o,
                relay: a,
                active: !1,
                methods: n == null ? void 0 : n.methods
            }, c = cg({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: i,
                symKey: s,
                relay: a,
                expiryTimestamp: o,
                methods: n == null ? void 0 : n.methods
            });
            return this.events.emit(fi.create, u), this.core.expirer.set(i, o), await this.pairings.set(i, u), await this.core.relayer.subscribe(i, {
                transportType: n == null ? void 0 : n.transportType,
                internal: n == null ? void 0 : n.internal
            }), {
                topic: i,
                uri: c
            };
        }), je(this, "pair", async (n)=>{
            this.isInitialized();
            const s = this.core.eventClient.createEvent({
                properties: {
                    topic: n == null ? void 0 : n.uri,
                    trace: [
                        Br.pairing_started
                    ]
                }
            });
            this.isValidPair(n, s);
            const { topic: i, symKey: o, relay: a, expiryTimestamp: u, methods: c } = ag(n.uri);
            s.props.properties.topic = i, s.addTrace(Br.pairing_uri_validation_success), s.addTrace(Br.pairing_uri_not_expired);
            let l;
            if (this.pairings.keys.includes(i)) {
                if (l = this.pairings.get(i), s.addTrace(Br.existing_pairing), l.active) throw s.setError(on.active_pairing_already_exists), new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
                s.addTrace(Br.pairing_not_expired);
            }
            const d = u || dt(ue.FIVE_MINUTES), h = {
                topic: i,
                relay: a,
                expiry: d,
                active: !1,
                methods: c
            };
            this.core.expirer.set(i, d), await this.pairings.set(i, h), s.addTrace(Br.store_new_pairing), n.activatePairing && await this.activate({
                topic: i
            }), this.events.emit(fi.create, h), s.addTrace(Br.emit_inactive_pairing), this.core.crypto.keychain.has(i) || await this.core.crypto.setSymKey(o, i), s.addTrace(Br.subscribing_pairing_topic);
            try {
                await this.core.relayer.confirmOnlineStateOrThrow();
            } catch  {
                s.setError(on.no_internet_connection);
            }
            try {
                await this.core.relayer.subscribe(i, {
                    relay: a
                });
            } catch (f) {
                throw s.setError(on.subscribe_pairing_topic_failure), f;
            }
            return s.addTrace(Br.subscribe_pairing_topic_success), h;
        }), je(this, "activate", async ({ topic: n })=>{
            this.isInitialized();
            const s = dt(ue.FIVE_MINUTES);
            this.core.expirer.set(n, s), await this.pairings.update(n, {
                active: !0,
                expiry: s
            });
        }), je(this, "ping", async (n)=>{
            this.isInitialized(), await this.isValidPing(n), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
            const { topic: s } = n;
            if (this.pairings.keys.includes(s)) {
                const i = await this.sendRequest(s, "wc_pairingPing", {}), { done: o, resolve: a, reject: u } = di();
                this.events.once(Pe("pairing_ping", i), ({ error: c })=>{
                    c ? u(c) : a();
                }), await o();
            }
        }), je(this, "updateExpiry", async ({ topic: n, expiry: s })=>{
            this.isInitialized(), await this.pairings.update(n, {
                expiry: s
            });
        }), je(this, "updateMetadata", async ({ topic: n, metadata: s })=>{
            this.isInitialized(), await this.pairings.update(n, {
                peerMetadata: s
            });
        }), je(this, "getPairings", ()=>(this.isInitialized(), this.pairings.values)), je(this, "disconnect", async (n)=>{
            this.isInitialized(), await this.isValidDisconnect(n);
            const { topic: s } = n;
            this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", rt("USER_DISCONNECTED")), await this.deletePairing(s));
        }), je(this, "formatUriFromPairing", (n)=>{
            this.isInitialized();
            const { topic: s, relay: i, expiry: o, methods: a } = n, u = this.core.crypto.keychain.get(s);
            return cg({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: s,
                symKey: u,
                relay: i,
                expiryTimestamp: o,
                methods: a
            });
        }), je(this, "sendRequest", async (n, s, i)=>{
            const o = ln(s, i), a = await this.core.crypto.encode(n, o), u = Bs[s].req;
            return this.core.history.set(n, o), this.core.relayer.publish(n, a, u), o.id;
        }), je(this, "sendResult", async (n, s, i)=>{
            const o = Ga(n, i), a = await this.core.crypto.encode(s, o), u = (await this.core.history.get(s, n)).request.method, c = Bs[u].res;
            await this.core.relayer.publish(s, a, c), await this.core.history.resolve(o);
        }), je(this, "sendError", async (n, s, i)=>{
            const o = dh(n, i), a = await this.core.crypto.encode(s, o), u = (await this.core.history.get(s, n)).request.method, c = Bs[u] ? Bs[u].res : Bs.unregistered_method.res;
            await this.core.relayer.publish(s, a, c), await this.core.history.resolve(o);
        }), je(this, "deletePairing", async (n, s)=>{
            await this.core.relayer.unsubscribe(n), await Promise.all([
                this.pairings.delete(n, rt("USER_DISCONNECTED")),
                this.core.crypto.deleteSymKey(n),
                s ? Promise.resolve() : this.core.expirer.del(n)
            ]);
        }), je(this, "cleanup", async ()=>{
            const n = this.pairings.getAll().filter((s)=>jn(s.expiry));
            await Promise.all(n.map((s)=>this.deletePairing(s.topic)));
        }), je(this, "onRelayEventRequest", async (n)=>{
            const { topic: s, payload: i } = n;
            switch(i.method){
                case "wc_pairingPing":
                    return await this.onPairingPingRequest(s, i);
                case "wc_pairingDelete":
                    return await this.onPairingDeleteRequest(s, i);
                default:
                    return await this.onUnknownRpcMethodRequest(s, i);
            }
        }), je(this, "onRelayEventResponse", async (n)=>{
            const { topic: s, payload: i } = n, o = (await this.core.history.get(s, i.id)).request.method;
            switch(o){
                case "wc_pairingPing":
                    return this.onPairingPingResponse(s, i);
                default:
                    return this.onUnknownRpcMethodResponse(o);
            }
        }), je(this, "onPairingPingRequest", async (n, s)=>{
            const { id: i } = s;
            try {
                this.isValidPing({
                    topic: n
                }), await this.sendResult(i, n, !0), this.events.emit(fi.ping, {
                    id: i,
                    topic: n
                });
            } catch (o) {
                await this.sendError(i, n, o), this.logger.error(o);
            }
        }), je(this, "onPairingPingResponse", (n, s)=>{
            const { id: i } = s;
            setTimeout(()=>{
                Qr(s) ? this.events.emit(Pe("pairing_ping", i), {}) : wr(s) && this.events.emit(Pe("pairing_ping", i), {
                    error: s.error
                });
            }, 500);
        }), je(this, "onPairingDeleteRequest", async (n, s)=>{
            const { id: i } = s;
            try {
                this.isValidDisconnect({
                    topic: n
                }), await this.deletePairing(n), this.events.emit(fi.delete, {
                    id: i,
                    topic: n
                });
            } catch (o) {
                await this.sendError(i, n, o), this.logger.error(o);
            }
        }), je(this, "onUnknownRpcMethodRequest", async (n, s)=>{
            const { id: i, method: o } = s;
            try {
                if (this.registeredMethods.includes(o)) return;
                const a = rt("WC_METHOD_UNSUPPORTED", o);
                await this.sendError(i, n, a), this.logger.error(a);
            } catch (a) {
                await this.sendError(i, n, a), this.logger.error(a);
            }
        }), je(this, "onUnknownRpcMethodResponse", (n)=>{
            this.registeredMethods.includes(n) || this.logger.error(rt("WC_METHOD_UNSUPPORTED", n));
        }), je(this, "isValidPair", (n, s)=>{
            var i;
            if (!Wt(n)) {
                const { message: a } = ce("MISSING_OR_INVALID", `pair() params: ${n}`);
                throw s.setError(on.malformed_pairing_uri), new Error(a);
            }
            if (!yC(n.uri)) {
                const { message: a } = ce("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
                throw s.setError(on.malformed_pairing_uri), new Error(a);
            }
            const o = ag(n == null ? void 0 : n.uri);
            if (!((i = o == null ? void 0 : o.relay) != null && i.protocol)) {
                const { message: a } = ce("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                throw s.setError(on.malformed_pairing_uri), new Error(a);
            }
            if (!(o != null && o.symKey)) {
                const { message: a } = ce("MISSING_OR_INVALID", "pair() uri#symKey");
                throw s.setError(on.malformed_pairing_uri), new Error(a);
            }
            if (o != null && o.expiryTimestamp && ue.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()) {
                s.setError(on.pairing_expired);
                const { message: a } = ce("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
                throw new Error(a);
            }
        }), je(this, "isValidPing", async (n)=>{
            if (!Wt(n)) {
                const { message: i } = ce("MISSING_OR_INVALID", `ping() params: ${n}`);
                throw new Error(i);
            }
            const { topic: s } = n;
            await this.isValidPairingTopic(s);
        }), je(this, "isValidDisconnect", async (n)=>{
            if (!Wt(n)) {
                const { message: i } = ce("MISSING_OR_INVALID", `disconnect() params: ${n}`);
                throw new Error(i);
            }
            const { topic: s } = n;
            await this.isValidPairingTopic(s);
        }), je(this, "isValidPairingTopic", async (n)=>{
            if (!ct(n, !1)) {
                const { message: s } = ce("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
                throw new Error(s);
            }
            if (!this.pairings.keys.includes(n)) {
                const { message: s } = ce("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
                throw new Error(s);
            }
            if (jn(this.pairings.get(n).expiry)) {
                await this.deletePairing(n);
                const { message: s } = ce("EXPIRED", `pairing topic: ${n}`);
                throw new Error(s);
            }
        }), this.core = e, this.logger = ur(t, this.name), this.pairings = new ki(this.core, this.logger, this.name, this.storagePrefix);
    }
    get context() {
        return nr(this.logger);
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
    registerRelayerEvents() {
        this.core.relayer.on(st.message, async (e)=>{
            const { topic: t, message: n, transportType: s } = e;
            if (this.pairings.keys.includes(t) && s !== Ge.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))) try {
                const i = await this.core.crypto.decode(t, n);
                hh(i) ? (this.core.history.set(t, i), await this.onRelayEventRequest({
                    topic: t,
                    payload: i
                })) : Gc(i) && (await this.core.history.resolve(i), await this.onRelayEventResponse({
                    topic: t,
                    payload: i
                }), this.core.history.delete(t, i.id)), await this.core.relayer.messages.ack(t, n);
            } catch (i) {
                this.logger.error(i);
            }
        });
    }
    registerExpirerEvents() {
        this.core.expirer.on(fr.expired, async (e)=>{
            const { topic: t } = Tm(e.target);
            t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(fi.expire, {
                topic: t
            }));
        });
    }
}
var Pz = Object.defineProperty, Uz = (r, e, t)=>e in r ? Pz(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, It = (r, e, t)=>Uz(r, typeof e != "symbol" ? e + "" : e, t);
class Rz extends nI {
    constructor(e, t){
        super(e, t), this.core = e, this.logger = t, It(this, "records", /* @__PURE__ */ new Map()), It(this, "events", new rr.EventEmitter()), It(this, "name", BL), It(this, "version", FL), It(this, "cached", []), It(this, "initialized", !1), It(this, "storagePrefix", Wr), It(this, "init", async ()=>{
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n)=>this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
        }), It(this, "set", (n, s, i)=>{
            if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
                type: "method",
                method: "set",
                topic: n,
                request: s,
                chainId: i
            }), this.records.has(s.id)) return;
            const o = {
                id: s.id,
                topic: n,
                request: {
                    method: s.method,
                    params: s.params || null
                },
                chainId: i,
                expiry: dt(ue.THIRTY_DAYS)
            };
            this.records.set(o.id, o), this.persist(), this.events.emit(xr.created, o);
        }), It(this, "resolve", async (n)=>{
            if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
                type: "method",
                method: "update",
                response: n
            }), !this.records.has(n.id)) return;
            const s = await this.getRecord(n.id);
            typeof s.response > "u" && (s.response = wr(n) ? {
                error: n.error
            } : {
                result: n.result
            }, this.records.set(s.id, s), this.persist(), this.events.emit(xr.updated, s));
        }), It(this, "get", async (n, s)=>(this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
                type: "method",
                method: "get",
                topic: n,
                id: s
            }), await this.getRecord(s))), It(this, "delete", (n, s)=>{
            this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
                type: "method",
                method: "delete",
                id: s
            }), this.values.forEach((i)=>{
                if (i.topic === n) {
                    if (typeof s < "u" && i.id !== s) return;
                    this.records.delete(i.id), this.events.emit(xr.deleted, i);
                }
            }), this.persist();
        }), It(this, "exists", async (n, s)=>(this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === n : !1)), It(this, "on", (n, s)=>{
            this.events.on(n, s);
        }), It(this, "once", (n, s)=>{
            this.events.once(n, s);
        }), It(this, "off", (n, s)=>{
            this.events.off(n, s);
        }), It(this, "removeListener", (n, s)=>{
            this.events.removeListener(n, s);
        }), this.logger = ur(t, this.name);
    }
    get context() {
        return nr(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
    }
    get size() {
        return this.records.size;
    }
    get keys() {
        return Array.from(this.records.keys());
    }
    get values() {
        return Array.from(this.records.values());
    }
    get pending() {
        const e = [];
        return this.values.forEach((t)=>{
            if (typeof t.response < "u") return;
            const n = {
                topic: t.topic,
                request: ln(t.request.method, t.request.params, t.id),
                chainId: t.chainId
            };
            return e.push(n);
        }), e;
    }
    async setJsonRpcRecords(e) {
        await this.core.storage.setItem(this.storageKey, e);
    }
    async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey);
    }
    getRecord(e) {
        this.isInitialized();
        const t = this.records.get(e);
        if (!t) {
            const { message: n } = ce("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(n);
        }
        return t;
    }
    async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(xr.sync);
    }
    async restore() {
        try {
            const e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length) return;
            if (this.records.size) {
                const { message: t } = ce("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t), new Error(t);
            }
            this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values
            });
        } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
        }
    }
    registerEventListeners() {
        this.events.on(xr.created, (e)=>{
            const t = xr.created;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                record: e
            });
        }), this.events.on(xr.updated, (e)=>{
            const t = xr.updated;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                record: e
            });
        }), this.events.on(xr.deleted, (e)=>{
            const t = xr.deleted;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                record: e
            });
        }), this.core.heartbeat.on(Oi.pulse, ()=>{
            this.cleanup();
        });
    }
    cleanup() {
        try {
            this.isInitialized();
            let e = !1;
            this.records.forEach((t)=>{
                ue.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(xr.deleted, t, !1), e = !0);
            }), e && this.persist();
        } catch (e) {
            this.logger.warn(e);
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
}
var $z = Object.defineProperty, Bz = (r, e, t)=>e in r ? $z(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, kt = (r, e, t)=>Bz(r, typeof e != "symbol" ? e + "" : e, t);
class Fz extends uI {
    constructor(e, t){
        super(e, t), this.core = e, this.logger = t, kt(this, "expirations", /* @__PURE__ */ new Map()), kt(this, "events", new rr.EventEmitter()), kt(this, "name", qL), kt(this, "version", QL), kt(this, "cached", []), kt(this, "initialized", !1), kt(this, "storagePrefix", Wr), kt(this, "init", async ()=>{
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n)=>this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
        }), kt(this, "has", (n)=>{
            try {
                const s = this.formatTarget(n);
                return typeof this.getExpiration(s) < "u";
            } catch  {
                return !1;
            }
        }), kt(this, "set", (n, s)=>{
            this.isInitialized();
            const i = this.formatTarget(n), o = {
                target: i,
                expiry: s
            };
            this.expirations.set(i, o), this.checkExpiry(i, o), this.events.emit(fr.created, {
                target: i,
                expiration: o
            });
        }), kt(this, "get", (n)=>{
            this.isInitialized();
            const s = this.formatTarget(n);
            return this.getExpiration(s);
        }), kt(this, "del", (n)=>{
            if (this.isInitialized(), this.has(n)) {
                const s = this.formatTarget(n), i = this.getExpiration(s);
                this.expirations.delete(s), this.events.emit(fr.deleted, {
                    target: s,
                    expiration: i
                });
            }
        }), kt(this, "on", (n, s)=>{
            this.events.on(n, s);
        }), kt(this, "once", (n, s)=>{
            this.events.once(n, s);
        }), kt(this, "off", (n, s)=>{
            this.events.off(n, s);
        }), kt(this, "removeListener", (n, s)=>{
            this.events.removeListener(n, s);
        }), this.logger = ur(t, this.name);
    }
    get context() {
        return nr(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
    }
    get length() {
        return this.expirations.size;
    }
    get keys() {
        return Array.from(this.expirations.keys());
    }
    get values() {
        return Array.from(this.expirations.values());
    }
    formatTarget(e) {
        if (typeof e == "string") return GO(e);
        if (typeof e == "number") return HO(e);
        const { message: t } = ce("UNKNOWN_TYPE", `Target type: ${typeof e}`);
        throw new Error(t);
    }
    async setExpirations(e) {
        await this.core.storage.setItem(this.storageKey, e);
    }
    async getExpirations() {
        return await this.core.storage.getItem(this.storageKey);
    }
    async persist() {
        await this.setExpirations(this.values), this.events.emit(fr.sync);
    }
    async restore() {
        try {
            const e = await this.getExpirations();
            if (typeof e > "u" || !e.length) return;
            if (this.expirations.size) {
                const { message: t } = ce("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t), new Error(t);
            }
            this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values
            });
        } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
        }
    }
    getExpiration(e) {
        const t = this.expirations.get(e);
        if (!t) {
            const { message: n } = ce("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.warn(n), new Error(n);
        }
        return t;
    }
    checkExpiry(e, t) {
        const { expiry: n } = t;
        ue.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, t);
    }
    expire(e, t) {
        this.expirations.delete(e), this.events.emit(fr.expired, {
            target: e,
            expiration: t
        });
    }
    checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach((e, t)=>this.checkExpiry(t, e));
    }
    registerEventListeners() {
        this.core.heartbeat.on(Oi.pulse, ()=>this.checkExpirations()), this.events.on(fr.created, (e)=>{
            const t = fr.created;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                data: e
            }), this.persist();
        }), this.events.on(fr.expired, (e)=>{
            const t = fr.expired;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                data: e
            }), this.persist();
        }), this.events.on(fr.deleted, (e)=>{
            const t = fr.deleted;
            this.logger.info(`Emitting ${t}`), this.logger.debug({
                type: "event",
                event: t,
                data: e
            }), this.persist();
        });
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
}
var qz = Object.defineProperty, Qz = (r, e, t)=>e in r ? qz(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, at = (r, e, t)=>Qz(r, typeof e != "symbol" ? e + "" : e, t);
class Vz extends lI {
    constructor(e, t, n){
        super(e, t, n), this.core = e, this.logger = t, this.store = n, at(this, "name", VL), at(this, "abortController"), at(this, "isDevEnv"), at(this, "verifyUrlV3", GL), at(this, "storagePrefix", Wr), at(this, "version", C1), at(this, "publicKey"), at(this, "fetchPromise"), at(this, "init", async ()=>{
            var s;
            this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && ue.toMiliseconds((s = this.publicKey) == null ? void 0 : s.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
        }), at(this, "register", async (s)=>{
            if (!ys() || this.isDevEnv) return;
            const i = window.location.origin, { id: o, decryptedId: a } = s, u = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${i}&id=${o}&decryptedId=${a}`;
            try {
                const c = Ni(), l = this.startAbortTimer(ue.ONE_SECOND * 5), d = await new Promise((h, f)=>{
                    const g = ()=>{
                        window.removeEventListener("message", m), c.body.removeChild(p), f("attestation aborted");
                    };
                    this.abortController.signal.addEventListener("abort", g);
                    const p = c.createElement("iframe");
                    p.src = u, p.style.display = "none", p.addEventListener("error", g, {
                        signal: this.abortController.signal
                    });
                    const m = (x)=>{
                        if (x.data && typeof x.data == "string") try {
                            const _ = JSON.parse(x.data);
                            if (_.type === "verify_attestation") {
                                if (_l(_.attestation).payload.id !== o) return;
                                clearInterval(l), c.body.removeChild(p), this.abortController.signal.removeEventListener("abort", g), window.removeEventListener("message", m), h(_.attestation === null ? "" : _.attestation);
                            }
                        } catch (_) {
                            this.logger.warn(_);
                        }
                    };
                    c.body.appendChild(p), window.addEventListener("message", m, {
                        signal: this.abortController.signal
                    });
                });
                return this.logger.debug(d, "jwt attestation"), d;
            } catch (c) {
                this.logger.warn(c);
            }
            return "";
        }), at(this, "resolve", async (s)=>{
            if (this.isDevEnv) return "";
            const { attestationId: i, hash: o, encryptedId: a } = s;
            if (i === "") {
                this.logger.debug("resolve: attestationId is empty, skipping");
                return;
            }
            if (i) {
                if (_l(i).payload.id !== a) return;
                const c = await this.isValidJwtAttestation(i);
                if (c) {
                    if (!c.isVerified) {
                        this.logger.warn("resolve: jwt attestation: origin url not verified");
                        return;
                    }
                    return c;
                }
            }
            if (!o) return;
            const u = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl);
            return this.fetchAttestation(o, u);
        }), at(this, "fetchAttestation", async (s, i)=>{
            this.logger.debug(`resolving attestation: ${s} from url: ${i}`);
            const o = this.startAbortTimer(ue.ONE_SECOND * 5), a = await fetch(`${i}/attestation/${s}?v2Supported=true`, {
                signal: this.abortController.signal
            });
            return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
        }), at(this, "getVerifyUrl", (s)=>{
            let i = s || ro;
            return HL.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${ro}`), i = ro), i;
        }), at(this, "fetchPublicKey", async ()=>{
            try {
                this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
                const s = this.startAbortTimer(ue.FIVE_SECONDS), i = await fetch(`${this.verifyUrlV3}/public-key`, {
                    signal: this.abortController.signal
                });
                return clearTimeout(s), await i.json();
            } catch (s) {
                this.logger.warn(s);
            }
        }), at(this, "persistPublicKey", async (s)=>{
            this.logger.debug(s, "persisting public key to local storage"), await this.store.setItem(this.storeKey, s), this.publicKey = s;
        }), at(this, "removePublicKey", async ()=>{
            this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
        }), at(this, "isValidJwtAttestation", async (s)=>{
            const i = await this.getPublicKey();
            try {
                if (i) return this.validateAttestation(s, i);
            } catch (a) {
                this.logger.error(a), this.logger.warn("error validating attestation");
            }
            const o = await this.fetchAndPersistPublicKey();
            try {
                if (o) return this.validateAttestation(s, o);
            } catch (a) {
                this.logger.error(a), this.logger.warn("error validating attestation");
            }
        }), at(this, "getPublicKey", async ()=>this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), at(this, "fetchAndPersistPublicKey", async ()=>{
            if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
            this.fetchPromise = new Promise(async (i)=>{
                const o = await this.fetchPublicKey();
                o && (await this.persistPublicKey(o), i(o));
            });
            const s = await this.fetchPromise;
            return this.fetchPromise = void 0, s;
        }), at(this, "validateAttestation", (s, i)=>{
            const o = Fj(s, i.publicKey), a = {
                hasExpired: ue.toMiliseconds(o.exp) < Date.now(),
                payload: o
            };
            if (a.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
            return {
                origin: a.payload.origin,
                isScam: a.payload.isScam,
                isVerified: a.payload.isVerified
            };
        }), this.logger = ur(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Zd(), this.init();
    }
    get storeKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
    }
    get context() {
        return nr(this.logger);
    }
    startAbortTimer(e) {
        return this.abortController = new AbortController(), setTimeout(()=>this.abortController.abort(), ue.toMiliseconds(e));
    }
}
var Yz = Object.defineProperty, Gz = (r, e, t)=>e in r ? Yz(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Qg = (r, e, t)=>Gz(r, typeof e != "symbol" ? e + "" : e, t);
class Hz extends dI {
    constructor(e, t){
        super(e, t), this.projectId = e, this.logger = t, Qg(this, "context", WL), Qg(this, "registerDeviceToken", async (n)=>{
            const { clientId: s, token: i, notificationType: o, enableEncrypted: a = !1 } = n, u = `${KL}/${this.projectId}/clients`;
            await fetch(u, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    client_id: s,
                    type: o,
                    token: i,
                    always_raw: a
                })
            });
        }), this.logger = ur(t, this.context);
    }
}
var Wz = Object.defineProperty, Vg = Object.getOwnPropertySymbols, Kz = Object.prototype.hasOwnProperty, Xz = Object.prototype.propertyIsEnumerable, ad = (r, e, t)=>e in r ? Wz(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Qs = (r, e)=>{
    for(var t in e || (e = {}))Kz.call(e, t) && ad(r, t, e[t]);
    if (Vg) for (var t of Vg(e))Xz.call(e, t) && ad(r, t, e[t]);
    return r;
}, wt = (r, e, t)=>ad(r, typeof e != "symbol" ? e + "" : e, t);
class Zz extends hI {
    constructor(e, t, n = !0){
        super(e, t, n), this.core = e, this.logger = t, wt(this, "context", ZL), wt(this, "storagePrefix", Wr), wt(this, "storageVersion", XL), wt(this, "events", /* @__PURE__ */ new Map()), wt(this, "shouldPersist", !1), wt(this, "init", async ()=>{
            if (!Zd()) try {
                const s = {
                    eventId: Dp(),
                    timestamp: Date.now(),
                    domain: this.getAppDomain(),
                    props: {
                        event: "INIT",
                        type: "",
                        properties: {
                            client_id: await this.core.crypto.getClientId(),
                            user_agent: xm(this.core.relayer.protocol, this.core.relayer.version, Jl)
                        }
                    }
                };
                await this.sendEvent([
                    s
                ]);
            } catch (s) {
                this.logger.warn(s);
            }
        }), wt(this, "createEvent", (s)=>{
            const { event: i = "ERROR", type: o = "", properties: { topic: a, trace: u } } = s, c = Dp(), l = this.core.projectId || "", d = Date.now(), h = Qs({
                eventId: c,
                timestamp: d,
                props: {
                    event: i,
                    type: o,
                    properties: {
                        topic: a,
                        trace: u
                    }
                },
                bundleId: l,
                domain: this.getAppDomain()
            }, this.setMethods(c));
            return this.telemetryEnabled && (this.events.set(c, h), this.shouldPersist = !0), h;
        }), wt(this, "getEvent", (s)=>{
            const { eventId: i, topic: o } = s;
            if (i) return this.events.get(i);
            const a = Array.from(this.events.values()).find((u)=>u.props.properties.topic === o);
            if (a) return Qs(Qs({}, a), this.setMethods(a.eventId));
        }), wt(this, "deleteEvent", (s)=>{
            const { eventId: i } = s;
            this.events.delete(i), this.shouldPersist = !0;
        }), wt(this, "setEventListeners", ()=>{
            this.core.heartbeat.on(Oi.pulse, async ()=>{
                this.shouldPersist && await this.persist(), this.events.forEach((s)=>{
                    ue.fromMiliseconds(Date.now()) - ue.fromMiliseconds(s.timestamp) > JL && (this.events.delete(s.eventId), this.shouldPersist = !0);
                });
            });
        }), wt(this, "setMethods", (s)=>({
                addTrace: (i)=>this.addTrace(s, i),
                setError: (i)=>this.setError(s, i)
            })), wt(this, "addTrace", (s, i)=>{
            const o = this.events.get(s);
            o && (o.props.properties.trace.push(i), this.events.set(s, o), this.shouldPersist = !0);
        }), wt(this, "setError", (s, i)=>{
            const o = this.events.get(s);
            o && (o.props.type = i, o.timestamp = Date.now(), this.events.set(s, o), this.shouldPersist = !0);
        }), wt(this, "persist", async ()=>{
            await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
        }), wt(this, "restore", async ()=>{
            try {
                const s = await this.core.storage.getItem(this.storageKey) || [];
                if (!s.length) return;
                s.forEach((i)=>{
                    this.events.set(i.eventId, Qs(Qs({}, i), this.setMethods(i.eventId)));
                });
            } catch (s) {
                this.logger.warn(s);
            }
        }), wt(this, "submit", async ()=>{
            if (!this.telemetryEnabled || this.events.size === 0) return;
            const s = [];
            for (const [i, o] of this.events)o.props.type && s.push(o);
            if (s.length !== 0) try {
                if ((await this.sendEvent(s)).ok) for (const i of s)this.events.delete(i.eventId), this.shouldPersist = !0;
            } catch (i) {
                this.logger.warn(i);
            }
        }), wt(this, "sendEvent", async (s)=>{
            const i = this.getAppDomain() ? "" : "&sp=desktop";
            return await fetch(`${e5}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Jl}${i}`, {
                method: "POST",
                body: JSON.stringify(s)
            });
        }), wt(this, "getAppDomain", ()=>Nm().url), this.logger = ur(t, this.context), this.telemetryEnabled = n, n ? this.restore().then(async ()=>{
            await this.submit(), this.setEventListeners();
        }) : this.persist();
    }
    get storageKey() {
        return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
    }
}
var Jz = Object.defineProperty, Yg = Object.getOwnPropertySymbols, eP = Object.prototype.hasOwnProperty, tP = Object.prototype.propertyIsEnumerable, cd = (r, e, t)=>e in r ? Jz(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Gg = (r, e)=>{
    for(var t in e || (e = {}))eP.call(e, t) && cd(r, t, e[t]);
    if (Yg) for (var t of Yg(e))tP.call(e, t) && cd(r, t, e[t]);
    return r;
}, Ve = (r, e, t)=>cd(r, typeof e != "symbol" ? e + "" : e, t);
class fh extends Jx {
    constructor(e){
        var t;
        super(e), Ve(this, "protocol", j1), Ve(this, "version", C1), Ve(this, "name", Zl), Ve(this, "relayUrl"), Ve(this, "projectId"), Ve(this, "customStoragePrefix"), Ve(this, "events", new rr.EventEmitter()), Ve(this, "logger"), Ve(this, "heartbeat"), Ve(this, "relayer"), Ve(this, "crypto"), Ve(this, "storage"), Ve(this, "history"), Ve(this, "expirer"), Ve(this, "pairing"), Ve(this, "verify"), Ve(this, "echoClient"), Ve(this, "linkModeSupportedApps"), Ve(this, "eventClient"), Ve(this, "initialized", !1), Ve(this, "logChunkController"), Ve(this, "on", (a, u)=>this.events.on(a, u)), Ve(this, "once", (a, u)=>this.events.once(a, u)), Ve(this, "off", (a, u)=>this.events.off(a, u)), Ve(this, "removeListener", (a, u)=>this.events.removeListener(a, u)), Ve(this, "dispatchEnvelope", ({ topic: a, message: u, sessionExists: c })=>{
            if (!a || !u) return;
            const l = {
                topic: a,
                message: u,
                publishedAt: Date.now(),
                transportType: Ge.link_mode
            };
            this.relayer.onLinkMessageEvent(l, {
                sessionExists: c
            });
        });
        const n = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
        if (n) try {
            return this.customStoragePrefix = n.customStoragePrefix, this.logger = n.logger, this.heartbeat = n.heartbeat, this.crypto = n.crypto, this.history = n.history, this.expirer = n.expirer, this.storage = n.storage, this.relayer = n.relayer, this.pairing = n.pairing, this.verify = n.verify, this.echoClient = n.echoClient, this.linkModeSupportedApps = n.linkModeSupportedApps, this.eventClient = n.eventClient, this.initialized = n.initialized, this.logChunkController = n.logChunkController, n;
        } catch (a) {
            console.warn("Failed to copy global core", a);
        }
        this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || k1, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
        const s = Yx({
            level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : EL.logger,
            name: Zl
        }), { logger: i, chunkLoggerController: o } = Uy({
            opts: s,
            maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes,
            loggerOverride: e == null ? void 0 : e.logger
        });
        this.logChunkController = o, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async ()=>{
            var a, u;
            (a = this.logChunkController) != null && a.downloadLogsBlobInBrowser && ((u = this.logChunkController) == null || u.downloadLogsBlobInBrowser({
                clientId: await this.crypto.getClientId()
            }));
        }), this.logger = ur(i, this.name), this.heartbeat = new TN(), this.crypto = new Ak(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Rz(this, this.logger), this.expirer = new Fz(this, this.logger), this.storage = e != null && e.storage ? e.storage : new cx(Gg(Gg({}, ML), e == null ? void 0 : e.storageOptions)), this.relayer = new rz({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId
        }), this.pairing = new zz(this, this.logger), this.verify = new Vz(this, this.logger, this.storage), this.echoClient = new Hz(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Zz(this, this.logger, e == null ? void 0 : e.telemetryEnabled), this.setGlobalCore(this);
    }
    static async init(e) {
        const t = new fh(e);
        await t.initialize();
        const n = await t.crypto.getClientId();
        return await t.storage.setItem(zL, n), t;
    }
    get context() {
        return nr(this.logger);
    }
    async start() {
        this.initialized || await this.initialize();
    }
    async getLogsBlob() {
        var e;
        return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({
            clientId: await this.crypto.getClientId()
        });
    }
    async addLinkModeSupportedApp(e) {
        this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Ig, this.linkModeSupportedApps));
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Ig) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
        } catch (e) {
            throw this.logger.warn(e, `Core Initialization Failure at epoch ${Date.now()}`), this.logger.error(e.message), e;
        }
    }
    getGlobalCore(e = "") {
        try {
            if (this.isGlobalCoreDisabled()) return;
            const t = `_walletConnectCore_${e}`, n = `${t}_count`;
            return globalThis[n] = (globalThis[n] || 0) + 1, globalThis[n] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[n]} times.`), globalThis[t];
        } catch (t) {
            console.warn("Failed to get global WalletConnect core", t);
            return;
        }
    }
    setGlobalCore(e) {
        var t;
        try {
            if (this.isGlobalCoreDisabled()) return;
            const n = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
            globalThis[n] = e;
        } catch (n) {
            console.warn("Failed to set global WalletConnect core", n);
        }
    }
    isGlobalCoreDisabled() {
        try {
            return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
        } catch  {
            return !0;
        }
    }
}
const rP = fh, H1 = "wc", W1 = 2, K1 = "client", ph = `${H1}@${W1}:${K1}:`, rl = {
    name: K1,
    logger: "error"
}, Hg = "WALLETCONNECT_DEEPLINK_CHOICE", nP = "proposal", Wg = "Proposal expired", iP = "session", Yi = ue.SEVEN_DAYS, sP = "engine", Tt = {
    wc_sessionPropose: {
        req: {
            ttl: ue.FIVE_MINUTES,
            prompt: !0,
            tag: 1100
        },
        res: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1101
        },
        reject: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1120
        },
        autoReject: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1121
        }
    },
    wc_sessionSettle: {
        req: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1102
        },
        res: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1103
        }
    },
    wc_sessionUpdate: {
        req: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1104
        },
        res: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1105
        }
    },
    wc_sessionExtend: {
        req: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1106
        },
        res: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1107
        }
    },
    wc_sessionRequest: {
        req: {
            ttl: ue.FIVE_MINUTES,
            prompt: !0,
            tag: 1108
        },
        res: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1109
        }
    },
    wc_sessionEvent: {
        req: {
            ttl: ue.FIVE_MINUTES,
            prompt: !0,
            tag: 1110
        },
        res: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1111
        }
    },
    wc_sessionDelete: {
        req: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1112
        },
        res: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1113
        }
    },
    wc_sessionPing: {
        req: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1114
        },
        res: {
            ttl: ue.ONE_DAY,
            prompt: !1,
            tag: 1115
        }
    },
    wc_sessionAuthenticate: {
        req: {
            ttl: ue.ONE_HOUR,
            prompt: !0,
            tag: 1116
        },
        res: {
            ttl: ue.ONE_HOUR,
            prompt: !1,
            tag: 1117
        },
        reject: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1118
        },
        autoReject: {
            ttl: ue.FIVE_MINUTES,
            prompt: !1,
            tag: 1119
        }
    }
}, nl = {
    min: ue.FIVE_MINUTES,
    max: ue.SEVEN_DAYS
}, Pr = {
    idle: "IDLE",
    active: "ACTIVE"
}, oP = {
    eth_sendTransaction: {
        key: ""
    },
    eth_sendRawTransaction: {
        key: ""
    },
    wallet_sendCalls: {
        key: ""
    },
    solana_signTransaction: {
        key: "signature"
    },
    solana_signAllTransactions: {
        key: "transactions"
    },
    solana_signAndSendTransaction: {
        key: "signature"
    },
    sui_signAndExecuteTransaction: {
        key: "digest"
    },
    sui_signTransaction: {
        key: ""
    },
    hedera_signAndExecuteTransaction: {
        key: "transactionId"
    },
    hedera_executeTransaction: {
        key: "transactionId"
    },
    near_signTransaction: {
        key: ""
    },
    near_signTransactions: {
        key: ""
    },
    tron_signTransaction: {
        key: "txID"
    },
    xrpl_signTransaction: {
        key: ""
    },
    xrpl_signTransactionFor: {
        key: ""
    },
    algo_signTxn: {
        key: ""
    },
    sendTransfer: {
        key: "txid"
    },
    stacks_stxTransfer: {
        key: "txId"
    },
    polkadot_signTransaction: {
        key: ""
    },
    cosmos_signDirect: {
        key: ""
    }
}, aP = "request", cP = [
    "wc_sessionPropose",
    "wc_sessionRequest",
    "wc_authRequest",
    "wc_sessionAuthenticate"
], uP = "wc", lP = "auth", dP = "authKeys", hP = "pairingTopics", fP = "requests", Wc = `${uP}@${1.5}:${lP}:`, xa = `${Wc}:PUB_KEY`;
var pP = Object.defineProperty, gP = Object.defineProperties, yP = Object.getOwnPropertyDescriptors, Kg = Object.getOwnPropertySymbols, wP = Object.prototype.hasOwnProperty, mP = Object.prototype.propertyIsEnumerable, ud = (r, e, t)=>e in r ? pP(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Ue = (r, e)=>{
    for(var t in e || (e = {}))wP.call(e, t) && ud(r, t, e[t]);
    if (Kg) for (var t of Kg(e))mP.call(e, t) && ud(r, t, e[t]);
    return r;
}, zt = (r, e)=>gP(r, yP(e)), ae = (r, e, t)=>ud(r, typeof e != "symbol" ? e + "" : e, t);
class bP extends yI {
    constructor(e){
        super(e), ae(this, "name", sP), ae(this, "events", new Md()), ae(this, "initialized", !1), ae(this, "requestQueue", {
            state: Pr.idle,
            queue: []
        }), ae(this, "sessionRequestQueue", {
            state: Pr.idle,
            queue: []
        }), ae(this, "emittedSessionRequests", new n4({
            limit: 500
        })), ae(this, "requestQueueDelay", ue.ONE_SECOND), ae(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), ae(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), ae(this, "recentlyDeletedLimit", 200), ae(this, "relayMessageCache", []), ae(this, "pendingSessions", /* @__PURE__ */ new Map()), ae(this, "init", async ()=>{
            this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({
                methods: Object.keys(Tt)
            }), this.initialized = !0, setTimeout(async ()=>{
                await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
            }, ue.toMiliseconds(this.requestQueueDelay)));
        }), ae(this, "connect", async (t)=>{
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            const n = zt(Ue({}, t), {
                requiredNamespaces: t.requiredNamespaces || {},
                optionalNamespaces: t.optionalNamespaces || {}
            });
            await this.isValidConnect(n), n.optionalNamespaces = dC(n.requiredNamespaces, n.optionalNamespaces), n.requiredNamespaces = {};
            const { pairingTopic: s, requiredNamespaces: i, optionalNamespaces: o, sessionProperties: a, scopedProperties: u, relays: c } = n;
            let l = s, d, h = !1;
            try {
                if (l) {
                    const z = this.client.core.pairing.pairings.get(l);
                    this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), h = z.active;
                }
            } catch (z) {
                throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`), z;
            }
            if (!l || !h) {
                const { topic: z, uri: P } = await this.client.core.pairing.create({
                    internal: {
                        skipSubscribe: !0
                    }
                });
                l = z, d = P;
            }
            if (!l) {
                const { message: z } = ce("NO_MATCHING_KEY", `connect() pairing topic: ${l}`);
                throw new Error(z);
            }
            const f = await this.client.core.crypto.generateKeyPair(), g = Tt.wc_sessionPropose.req.ttl || ue.FIVE_MINUTES, p = dt(g), m = zt(Ue(Ue({
                requiredNamespaces: i,
                optionalNamespaces: o,
                relays: c ?? [
                    {
                        protocol: L1
                    }
                ],
                proposer: {
                    publicKey: f,
                    metadata: this.client.metadata
                },
                expiryTimestamp: p,
                pairingTopic: l
            }, a && {
                sessionProperties: a
            }), u && {
                scopedProperties: u
            }), {
                id: qr()
            }), x = Pe("session_connect", m.id), { reject: _, resolve: v, done: N } = di(g, Wg), O = ({ id: z })=>{
                z === m.id && (this.client.events.off("proposal_expire", O), this.pendingSessions.delete(m.id), this.events.emit(x, {
                    error: {
                        message: Wg,
                        code: 0
                    }
                }));
            };
            return this.client.events.on("proposal_expire", O), this.events.once(x, ({ error: z, session: P })=>{
                this.client.events.off("proposal_expire", O), z ? _(z) : P && v(P);
            }), await this.sendProposeSession({
                proposal: m,
                publishOpts: {
                    internal: {
                        throwOnFailedPublish: !0
                    },
                    tvf: {
                        correlationId: m.id
                    }
                }
            }), await this.setProposal(m.id, m), {
                uri: d,
                approval: N
            };
        }), ae(this, "pair", async (t)=>{
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
                return await this.client.core.pairing.pair(t);
            } catch (n) {
                throw this.client.logger.error("pair() failed"), n;
            }
        }), ae(this, "approve", async (t)=>{
            var n, s, i;
            const o = this.client.core.eventClient.createEvent({
                properties: {
                    topic: (n = t == null ? void 0 : t.id) == null ? void 0 : n.toString(),
                    trace: [
                        Ir.session_approve_started
                    ]
                }
            });
            try {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
            } catch (R) {
                throw o.setError(oi.no_internet_connection), R;
            }
            try {
                await this.isValidProposalId(t == null ? void 0 : t.id);
            } catch (R) {
                throw this.client.logger.error(`approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`), o.setError(oi.proposal_not_found), R;
            }
            try {
                await this.isValidApprove(t);
            } catch (R) {
                throw this.client.logger.error("approve() -> isValidApprove() failed"), o.setError(oi.session_approve_namespace_validation_failure), R;
            }
            const { id: a, relayProtocol: u, namespaces: c, sessionProperties: l, scopedProperties: d, sessionConfig: h } = t, f = this.client.proposal.get(a);
            this.client.core.eventClient.deleteEvent({
                eventId: o.eventId
            });
            const { pairingTopic: g, proposer: p, requiredNamespaces: m, optionalNamespaces: x } = f;
            let _ = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({
                topic: g
            });
            _ || (_ = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({
                type: Ir.session_approve_started,
                properties: {
                    topic: g,
                    trace: [
                        Ir.session_approve_started,
                        Ir.session_namespaces_validation_success
                    ]
                }
            }));
            const v = await this.client.core.crypto.generateKeyPair(), N = p.publicKey, O = await this.client.core.crypto.generateSharedKey(v, N), z = Ue(Ue(Ue({
                relay: {
                    protocol: u ?? "irn"
                },
                namespaces: c,
                controller: {
                    publicKey: v,
                    metadata: this.client.metadata
                },
                expiry: dt(Yi)
            }, l && {
                sessionProperties: l
            }), d && {
                scopedProperties: d
            }), h && {
                sessionConfig: h
            }), P = Ge.relay;
            _.addTrace(Ir.subscribing_session_topic);
            try {
                await this.client.core.relayer.subscribe(O, {
                    transportType: P,
                    internal: {
                        skipSubscribe: !0
                    }
                });
            } catch (R) {
                throw _.setError(oi.subscribe_session_topic_failure), R;
            }
            _.addTrace(Ir.subscribe_session_topic_success);
            const U = zt(Ue({}, z), {
                topic: O,
                requiredNamespaces: m,
                optionalNamespaces: x,
                pairingTopic: g,
                acknowledged: !1,
                self: z.controller,
                peer: {
                    publicKey: p.publicKey,
                    metadata: p.metadata
                },
                controller: v,
                transportType: Ge.relay
            });
            await this.client.session.set(O, U), _.addTrace(Ir.store_session);
            try {
                await this.sendApproveSession({
                    sessionTopic: O,
                    proposal: f,
                    pairingProposalResponse: {
                        relay: {
                            protocol: u ?? "irn"
                        },
                        responderPublicKey: v
                    },
                    sessionSettleRequest: z,
                    publishOpts: {
                        internal: {
                            throwOnFailedPublish: !0
                        },
                        tvf: {
                            correlationId: a
                        }
                    }
                }), _.addTrace(Ir.session_approve_publish_success);
            } catch (R) {
                throw this.client.logger.error(R), this.client.session.delete(O, rt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(O), R;
            }
            return this.client.core.eventClient.deleteEvent({
                eventId: _.eventId
            }), await this.client.core.pairing.updateMetadata({
                topic: g,
                metadata: p.metadata
            }), await this.deleteProposal(a), await this.client.core.pairing.activate({
                topic: g
            }), await this.setExpiry(O, dt(Yi)), {
                topic: O,
                acknowledged: ()=>Promise.resolve(this.client.session.get(O))
            };
        }), ae(this, "reject", async (t)=>{
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidReject(t);
            } catch (o) {
                throw this.client.logger.error("reject() -> isValidReject() failed"), o;
            }
            const { id: n, reason: s } = t;
            let i;
            try {
                i = this.client.proposal.get(n).pairingTopic;
            } catch (o) {
                throw this.client.logger.error(`reject() -> proposal.get(${n}) failed`), o;
            }
            i && await this.sendError({
                id: n,
                topic: i,
                error: s,
                rpcOpts: Tt.wc_sessionPropose.reject
            }), await this.deleteProposal(n);
        }), ae(this, "update", async (t)=>{
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidUpdate(t);
            } catch (d) {
                throw this.client.logger.error("update() -> isValidUpdate() failed"), d;
            }
            const { topic: n, namespaces: s } = t, { done: i, resolve: o, reject: a } = di(), u = qr(), c = Yn().toString(), l = this.client.session.get(n).namespaces;
            return this.events.once(Pe("session_update", u), ({ error: d })=>{
                d ? a(d) : o();
            }), await this.client.session.update(n, {
                namespaces: s
            }), await this.sendRequest({
                topic: n,
                method: "wc_sessionUpdate",
                params: {
                    namespaces: s
                },
                throwOnFailedPublish: !0,
                clientRpcId: u,
                relayRpcId: c
            }).catch((d)=>{
                this.client.logger.error(d), this.client.session.update(n, {
                    namespaces: l
                }), a(d);
            }), {
                acknowledged: i
            };
        }), ae(this, "extend", async (t)=>{
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidExtend(t);
            } catch (u) {
                throw this.client.logger.error("extend() -> isValidExtend() failed"), u;
            }
            const { topic: n } = t, s = qr(), { done: i, resolve: o, reject: a } = di();
            return this.events.once(Pe("session_extend", s), ({ error: u })=>{
                u ? a(u) : o();
            }), await this.setExpiry(n, dt(Yi)), this.sendRequest({
                topic: n,
                method: "wc_sessionExtend",
                params: {},
                clientRpcId: s,
                throwOnFailedPublish: !0
            }).catch((u)=>{
                a(u);
            }), {
                acknowledged: i
            };
        }), ae(this, "request", async (t)=>{
            this.isInitialized();
            try {
                await this.isValidRequest(t);
            } catch (m) {
                throw this.client.logger.error("request() -> isValidRequest() failed"), m;
            }
            const { chainId: n, request: s, topic: i, expiry: o = Tt.wc_sessionRequest.req.ttl } = t, a = this.client.session.get(i);
            (a == null ? void 0 : a.transportType) === Ge.relay && await this.confirmOnlineStateOrThrow();
            const u = qr(), c = Yn().toString(), { done: l, resolve: d, reject: h } = di(o, "Request expired. Please try again.");
            this.events.once(Pe("session_request", u), ({ error: m, result: x })=>{
                m ? h(m) : d(x);
            });
            const f = "wc_sessionRequest", g = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
            if (g) return await this.sendRequest({
                clientRpcId: u,
                relayRpcId: c,
                topic: i,
                method: f,
                params: {
                    request: zt(Ue({}, s), {
                        expiryTimestamp: dt(o)
                    }),
                    chainId: n
                },
                expiry: o,
                throwOnFailedPublish: !0,
                appLink: g
            }).catch((m)=>h(m)), this.client.events.emit("session_request_sent", {
                topic: i,
                request: s,
                chainId: n,
                id: u
            }), await l();
            const p = {
                request: zt(Ue({}, s), {
                    expiryTimestamp: dt(o)
                }),
                chainId: n
            };
            return await Promise.all([
                new Promise(async (m)=>{
                    await this.sendRequest({
                        clientRpcId: u,
                        relayRpcId: c,
                        topic: i,
                        method: f,
                        params: p,
                        expiry: o,
                        throwOnFailedPublish: !0,
                        tvf: this.getTVFParams(u, p)
                    }).catch((x)=>h(x)), this.client.events.emit("session_request_sent", {
                        topic: i,
                        request: s,
                        chainId: n,
                        id: u
                    }), m();
                }),
                new Promise(async (m)=>{
                    var x;
                    if (!((x = a.sessionConfig) != null && x.disableDeepLink)) {
                        const _ = await ZO(this.client.core.storage, Hg);
                        await WO({
                            id: u,
                            topic: i,
                            wcDeepLink: _
                        });
                    }
                    m();
                }),
                l()
            ]).then((m)=>m[2]);
        }), ae(this, "respond", async (t)=>{
            var n, s;
            this.isInitialized();
            const i = this.client.core.eventClient.createEvent({
                properties: {
                    topic: (t == null ? void 0 : t.topic) || ((s = (n = t == null ? void 0 : t.response) == null ? void 0 : n.id) == null ? void 0 : s.toString()),
                    trace: [
                        Ir.session_request_response_started
                    ]
                }
            });
            try {
                await this.isValidRespond(t);
            } catch (d) {
                throw i.addTrace(d == null ? void 0 : d.message), i.setError(oi.session_request_response_validation_failure), d;
            }
            i.addTrace(Ir.session_request_response_validation_success);
            const { topic: o, response: a } = t, { id: u } = a, c = this.client.session.get(o);
            c.transportType === Ge.relay && await this.confirmOnlineStateOrThrow();
            const l = this.getAppLinkIfEnabled(c.peer.metadata, c.transportType);
            try {
                i.addTrace(Ir.session_request_response_publish_started), Qr(a) ? await this.sendResult({
                    id: u,
                    topic: o,
                    result: a.result,
                    throwOnFailedPublish: !0,
                    appLink: l
                }) : wr(a) && await this.sendError({
                    id: u,
                    topic: o,
                    error: a.error,
                    appLink: l
                }), this.cleanupAfterResponse(t);
            } catch (d) {
                throw i.addTrace(d == null ? void 0 : d.message), i.setError(oi.session_request_response_publish_failure), d;
            }
        }), ae(this, "ping", async (t)=>{
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidPing(t);
            } catch (s) {
                throw this.client.logger.error("ping() -> isValidPing() failed"), s;
            }
            const { topic: n } = t;
            if (this.client.session.keys.includes(n)) {
                const s = qr(), i = Yn().toString(), { done: o, resolve: a, reject: u } = di();
                this.events.once(Pe("session_ping", s), ({ error: c })=>{
                    c ? u(c) : a();
                }), await Promise.all([
                    this.sendRequest({
                        topic: n,
                        method: "wc_sessionPing",
                        params: {},
                        throwOnFailedPublish: !0,
                        clientRpcId: s,
                        relayRpcId: i
                    }),
                    o()
                ]);
            } else this.client.core.pairing.pairings.keys.includes(n) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({
                topic: n
            }));
        }), ae(this, "emit", async (t)=>{
            this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t);
            const { topic: n, event: s, chainId: i } = t, o = Yn().toString(), a = qr();
            await this.sendRequest({
                topic: n,
                method: "wc_sessionEvent",
                params: {
                    event: s,
                    chainId: i
                },
                throwOnFailedPublish: !0,
                relayRpcId: o,
                clientRpcId: a
            });
        }), ae(this, "disconnect", async (t)=>{
            this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t);
            const { topic: n } = t;
            if (this.client.session.keys.includes(n)) await this.sendRequest({
                topic: n,
                method: "wc_sessionDelete",
                params: rt("USER_DISCONNECTED"),
                throwOnFailedPublish: !0
            }), await this.deleteSession({
                topic: n,
                emitEvent: !1
            });
            else if (this.client.core.pairing.pairings.keys.includes(n)) await this.client.core.pairing.disconnect({
                topic: n
            });
            else {
                const { message: s } = ce("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
                throw new Error(s);
            }
        }), ae(this, "find", (t)=>(this.isInitialized(), this.client.session.getAll().filter((n)=>pC(n, t)))), ae(this, "getPendingSessionRequests", ()=>this.client.pendingRequest.getAll()), ae(this, "authenticate", async (t, n)=>{
            var s;
            this.isInitialized(), this.isValidAuthenticate(t);
            const i = n && this.client.core.linkModeSupportedApps.includes(n) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), o = i ? Ge.link_mode : Ge.relay;
            o === Ge.relay && await this.confirmOnlineStateOrThrow();
            const { chains: a, statement: u = "", uri: c, domain: l, nonce: d, type: h, exp: f, nbf: g, methods: p = [], expiry: m } = t, x = [
                ...t.resources || []
            ], { topic: _, uri: v } = await this.client.core.pairing.create({
                methods: [
                    "wc_sessionAuthenticate"
                ],
                transportType: o
            });
            this.client.logger.info({
                message: "Generated new pairing",
                pairing: {
                    topic: _,
                    uri: v
                }
            });
            const N = await this.client.core.crypto.generateKeyPair(), O = Ma(N);
            if (await Promise.all([
                this.client.auth.authKeys.set(xa, {
                    responseTopic: O,
                    publicKey: N
                }),
                this.client.auth.pairingTopics.set(O, {
                    topic: O,
                    pairingTopic: _
                })
            ]), await this.client.core.relayer.subscribe(O, {
                transportType: o
            }), this.client.logger.info(`sending request to new pairing topic: ${_}`), p.length > 0) {
                const { namespace: M } = va(a[0]);
                let D = p3(M, "request", p);
                Ea(x) && (D = y3(D, x.pop())), x.push(D);
            }
            const z = m && m > Tt.wc_sessionAuthenticate.req.ttl ? m : Tt.wc_sessionAuthenticate.req.ttl, P = {
                authPayload: {
                    type: h ?? "caip122",
                    chains: a,
                    statement: u,
                    aud: c,
                    domain: l,
                    version: "1",
                    nonce: d,
                    iat: /* @__PURE__ */ new Date().toISOString(),
                    exp: f,
                    nbf: g,
                    resources: x
                },
                requester: {
                    publicKey: N,
                    metadata: this.client.metadata
                },
                expiryTimestamp: dt(z)
            }, U = {
                eip155: {
                    chains: a,
                    methods: [
                        .../* @__PURE__ */ new Set([
                            "personal_sign",
                            ...p
                        ])
                    ],
                    events: [
                        "chainChanged",
                        "accountsChanged"
                    ]
                }
            }, R = {
                requiredNamespaces: {},
                optionalNamespaces: U,
                relays: [
                    {
                        protocol: "irn"
                    }
                ],
                pairingTopic: _,
                proposer: {
                    publicKey: N,
                    metadata: this.client.metadata
                },
                expiryTimestamp: dt(Tt.wc_sessionPropose.req.ttl),
                id: qr()
            }, { done: G, resolve: F, reject: H } = di(z, "Request expired"), B = qr(), C = Pe("session_connect", R.id), T = Pe("session_request", B), I = async ({ error: M, session: D })=>{
                this.events.off(T, y), M ? H(M) : D && F({
                    session: D
                });
            }, y = async (M)=>{
                var D, A, L;
                if (await this.deletePendingAuthRequest(B, {
                    message: "fulfilled",
                    code: 0
                }), M.error) {
                    const oe = rt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
                    return M.error.code === oe.code ? void 0 : (this.events.off(C, I), H(M.error.message));
                }
                await this.deleteProposal(R.id), this.events.off(C, I);
                const { cacaos: V, responder: Y } = M.result, K = [], J = [];
                for (const oe of V){
                    await Up({
                        cacao: oe,
                        projectId: this.client.core.projectId
                    }) || (this.client.logger.error(oe, "Signature verification failed"), H(rt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
                    const { p: le } = oe, fe = Ea(le.resources), Q = [
                        $l(le.iss)
                    ], Z = Ba(le.iss);
                    if (fe) {
                        const W = Rp(fe), ee = $p(fe);
                        K.push(...W), Q.push(...ee);
                    }
                    for (const W of Q)J.push(`${W}:${Z}`);
                }
                const ne = await this.client.core.crypto.generateSharedKey(N, Y.publicKey);
                let ie;
                K.length > 0 && (ie = {
                    topic: ne,
                    acknowledged: !0,
                    self: {
                        publicKey: N,
                        metadata: this.client.metadata
                    },
                    peer: Y,
                    controller: Y.publicKey,
                    expiry: dt(Yi),
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    relay: {
                        protocol: "irn"
                    },
                    pairingTopic: _,
                    namespaces: hg([
                        ...new Set(K)
                    ], [
                        ...new Set(J)
                    ]),
                    transportType: o
                }, await this.client.core.relayer.subscribe(ne, {
                    transportType: o
                }), await this.client.session.set(ne, ie), _ && await this.client.core.pairing.updateMetadata({
                    topic: _,
                    metadata: Y.metadata
                }), ie = this.client.session.get(ne)), (D = this.client.metadata.redirect) != null && D.linkMode && (A = Y.metadata.redirect) != null && A.linkMode && (L = Y.metadata.redirect) != null && L.universal && n && (this.client.core.addLinkModeSupportedApp(Y.metadata.redirect.universal), this.client.session.update(ne, {
                    transportType: Ge.link_mode
                })), F({
                    auths: V,
                    session: ie
                });
            };
            this.events.once(C, I), this.events.once(T, y);
            let w;
            try {
                if (i) {
                    const M = ln("wc_sessionAuthenticate", P, B);
                    this.client.core.history.set(_, M);
                    const D = await this.client.core.crypto.encode("", M, {
                        type: To,
                        encoding: qn
                    });
                    w = na(n, _, D);
                } else await Promise.all([
                    this.sendRequest({
                        topic: _,
                        method: "wc_sessionAuthenticate",
                        params: P,
                        expiry: t.expiry,
                        throwOnFailedPublish: !0,
                        clientRpcId: B
                    }),
                    this.sendRequest({
                        topic: _,
                        method: "wc_sessionPropose",
                        params: R,
                        expiry: Tt.wc_sessionPropose.req.ttl,
                        throwOnFailedPublish: !0,
                        clientRpcId: R.id
                    })
                ]);
            } catch (M) {
                throw this.events.off(C, I), this.events.off(T, y), M;
            }
            return await this.setProposal(R.id, R), await this.setAuthRequest(B, {
                request: zt(Ue({}, P), {
                    verifyContext: {}
                }),
                pairingTopic: _,
                transportType: o
            }), {
                uri: w ?? v,
                response: G
            };
        }), ae(this, "approveSessionAuthenticate", async (t)=>{
            const { id: n, auths: s } = t, i = this.client.core.eventClient.createEvent({
                properties: {
                    topic: n.toString(),
                    trace: [
                        ai.authenticated_session_approve_started
                    ]
                }
            });
            try {
                this.isInitialized();
            } catch (m) {
                throw i.setError(Fs.no_internet_connection), m;
            }
            const o = this.getPendingAuthRequest(n);
            if (!o) throw i.setError(Fs.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${n}`);
            const a = o.transportType || Ge.relay;
            a === Ge.relay && await this.confirmOnlineStateOrThrow();
            const u = o.requester.publicKey, c = await this.client.core.crypto.generateKeyPair(), l = Ma(u), d = {
                type: pn,
                receiverPublicKey: u,
                senderPublicKey: c
            }, h = [], f = [];
            for (const m of s){
                if (!await Up({
                    cacao: m,
                    projectId: this.client.core.projectId
                })) {
                    i.setError(Fs.invalid_cacao);
                    const O = rt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
                    throw await this.sendError({
                        id: n,
                        topic: l,
                        error: O,
                        encodeOpts: d
                    }), new Error(O.message);
                }
                i.addTrace(ai.cacaos_verified);
                const { p: x } = m, _ = Ea(x.resources), v = [
                    $l(x.iss)
                ], N = Ba(x.iss);
                if (_) {
                    const O = Rp(_), z = $p(_);
                    h.push(...O), v.push(...z);
                }
                for (const O of v)f.push(`${O}:${N}`);
            }
            const g = await this.client.core.crypto.generateSharedKey(c, u);
            i.addTrace(ai.create_authenticated_session_topic);
            let p;
            if ((h == null ? void 0 : h.length) > 0) {
                p = {
                    topic: g,
                    acknowledged: !0,
                    self: {
                        publicKey: c,
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: u,
                        metadata: o.requester.metadata
                    },
                    controller: u,
                    expiry: dt(Yi),
                    authentication: s,
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    relay: {
                        protocol: "irn"
                    },
                    pairingTopic: o.pairingTopic,
                    namespaces: hg([
                        ...new Set(h)
                    ], [
                        ...new Set(f)
                    ]),
                    transportType: a
                }, i.addTrace(ai.subscribing_authenticated_session_topic);
                try {
                    await this.client.core.relayer.subscribe(g, {
                        transportType: a
                    });
                } catch (m) {
                    throw i.setError(Fs.subscribe_authenticated_session_topic_failure), m;
                }
                i.addTrace(ai.subscribe_authenticated_session_topic_success), await this.client.session.set(g, p), i.addTrace(ai.store_authenticated_session), await this.client.core.pairing.updateMetadata({
                    topic: o.pairingTopic,
                    metadata: o.requester.metadata
                });
            }
            i.addTrace(ai.publishing_authenticated_session_approve);
            try {
                await this.sendResult({
                    topic: l,
                    id: n,
                    result: {
                        cacaos: s,
                        responder: {
                            publicKey: c,
                            metadata: this.client.metadata
                        }
                    },
                    encodeOpts: d,
                    throwOnFailedPublish: !0,
                    appLink: this.getAppLinkIfEnabled(o.requester.metadata, a)
                });
            } catch (m) {
                throw i.setError(Fs.authenticated_session_approve_publish_failure), m;
            }
            return await this.client.auth.requests.delete(n, {
                message: "fulfilled",
                code: 0
            }), await this.client.core.pairing.activate({
                topic: o.pairingTopic
            }), this.client.core.eventClient.deleteEvent({
                eventId: i.eventId
            }), {
                session: p
            };
        }), ae(this, "rejectSessionAuthenticate", async (t)=>{
            this.isInitialized();
            const { id: n, reason: s } = t, i = this.getPendingAuthRequest(n);
            if (!i) throw new Error(`Could not find pending auth request with id ${n}`);
            i.transportType === Ge.relay && await this.confirmOnlineStateOrThrow();
            const o = i.requester.publicKey, a = await this.client.core.crypto.generateKeyPair(), u = Ma(o), c = {
                type: pn,
                receiverPublicKey: o,
                senderPublicKey: a
            };
            await this.sendError({
                id: n,
                topic: u,
                error: s,
                encodeOpts: c,
                rpcOpts: Tt.wc_sessionAuthenticate.reject,
                appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType)
            }), await this.client.auth.requests.delete(n, {
                message: "rejected",
                code: 0
            }), await this.deleteProposal(n);
        }), ae(this, "formatAuthMessage", (t)=>{
            this.isInitialized();
            const { request: n, iss: s } = t;
            return Fm(n, s);
        }), ae(this, "processRelayMessageCache", ()=>{
            setTimeout(async ()=>{
                if (this.relayMessageCache.length !== 0) for(; this.relayMessageCache.length > 0;)try {
                    const t = this.relayMessageCache.shift();
                    t && await this.onRelayMessage(t);
                } catch (t) {
                    this.client.logger.error(t);
                }
            }, 50);
        }), ae(this, "cleanupDuplicatePairings", async (t)=>{
            if (t.pairingTopic) try {
                const n = this.client.core.pairing.pairings.get(t.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i)=>{
                    var o, a;
                    return ((o = i.peerMetadata) == null ? void 0 : o.url) && ((a = i.peerMetadata) == null ? void 0 : a.url) === t.peer.metadata.url && i.topic && i.topic !== n.topic;
                });
                if (s.length === 0) return;
                this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i)=>this.client.core.pairing.disconnect({
                        topic: i.topic
                    }))), this.client.logger.info("Duplicate pairings clean up finished");
            } catch (n) {
                this.client.logger.error(n);
            }
        }), ae(this, "deleteSession", async (t)=>{
            var n;
            const { topic: s, expirerHasDeleted: i = !1, emitEvent: o = !0, id: a = 0 } = t, { self: u } = this.client.session.get(s);
            await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, rt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(u.publicKey) && await this.client.core.crypto.deleteKeyPair(u.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Hg).catch((c)=>this.client.logger.warn(c)), this.getPendingSessionRequests().forEach((c)=>{
                c.topic === s && this.deletePendingSessionRequest(c.id, rt("USER_DISCONNECTED"));
            }), s === ((n = this.sessionRequestQueue.queue[0]) == null ? void 0 : n.topic) && (this.sessionRequestQueue.state = Pr.idle), o && this.client.events.emit("session_delete", {
                id: a,
                topic: s
            });
        }), ae(this, "deleteProposal", async (t, n)=>{
            if (n) try {
                const s = this.client.proposal.get(t), i = this.client.core.eventClient.getEvent({
                    topic: s.pairingTopic
                });
                i == null || i.setError(oi.proposal_expired);
            } catch  {}
            await Promise.all([
                this.client.proposal.delete(t, rt("USER_DISCONNECTED")),
                n ? Promise.resolve() : this.client.core.expirer.del(t)
            ]), this.addToRecentlyDeleted(t, "proposal");
        }), ae(this, "deletePendingSessionRequest", async (t, n, s = !1)=>{
            await Promise.all([
                this.client.pendingRequest.delete(t, n),
                s ? Promise.resolve() : this.client.core.expirer.del(t)
            ]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i)=>i.id !== t), s && (this.sessionRequestQueue.state = Pr.idle, this.client.events.emit("session_request_expire", {
                id: t
            }));
        }), ae(this, "deletePendingAuthRequest", async (t, n, s = !1)=>{
            await Promise.all([
                this.client.auth.requests.delete(t, n),
                s ? Promise.resolve() : this.client.core.expirer.del(t)
            ]);
        }), ae(this, "setExpiry", async (t, n)=>{
            this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, n), await this.client.session.update(t, {
                expiry: n
            }));
        }), ae(this, "setProposal", async (t, n)=>{
            this.client.core.expirer.set(t, dt(Tt.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, n);
        }), ae(this, "setAuthRequest", async (t, n)=>{
            const { request: s, pairingTopic: i, transportType: o = Ge.relay } = n;
            this.client.core.expirer.set(t, s.expiryTimestamp), await this.client.auth.requests.set(t, {
                authPayload: s.authPayload,
                requester: s.requester,
                expiryTimestamp: s.expiryTimestamp,
                id: t,
                pairingTopic: i,
                verifyContext: s.verifyContext,
                transportType: o
            });
        }), ae(this, "setPendingSessionRequest", async (t)=>{
            const { id: n, topic: s, params: i, verifyContext: o } = t, a = i.request.expiryTimestamp || dt(Tt.wc_sessionRequest.req.ttl);
            this.client.core.expirer.set(n, a), await this.client.pendingRequest.set(n, {
                id: n,
                topic: s,
                params: i,
                verifyContext: o
            });
        }), ae(this, "sendRequest", async (t)=>{
            const { topic: n, method: s, params: i, expiry: o, relayRpcId: a, clientRpcId: u, throwOnFailedPublish: c, appLink: l, tvf: d, publishOpts: h = {} } = t, f = ln(s, i, u);
            let g;
            const p = !!l;
            try {
                const _ = p ? qn : Zt;
                g = await this.client.core.crypto.encode(n, f, {
                    encoding: _
                });
            } catch (_) {
                throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${n} failed`), _;
            }
            let m;
            if (cP.includes(s)) {
                const _ = yr(JSON.stringify(f)), v = yr(g);
                m = await this.client.core.verify.register({
                    id: v,
                    decryptedId: _
                });
            }
            const x = Ue(Ue({}, Tt[s].req), h);
            if (x.attestation = m, o && (x.ttl = o), a && (x.id = a), this.client.core.history.set(n, f), p) {
                const _ = na(l, n, g);
                await /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking.openURL(_, this.client.name);
            } else x.tvf = zt(Ue({}, d), {
                correlationId: f.id
            }), c ? (x.internal = zt(Ue({}, x.internal), {
                throwOnFailedPublish: !0
            }), await this.client.core.relayer.publish(n, g, x)) : this.client.core.relayer.publish(n, g, x).catch((_)=>this.client.logger.error(_));
            return f.id;
        }), ae(this, "sendProposeSession", async (t)=>{
            const { proposal: n, publishOpts: s } = t, i = ln("wc_sessionPropose", n, n.id);
            this.client.core.history.set(n.pairingTopic, i);
            const o = await this.client.core.crypto.encode(n.pairingTopic, i, {
                encoding: Zt
            }), a = yr(JSON.stringify(i)), u = yr(o), c = await this.client.core.verify.register({
                id: u,
                decryptedId: a
            });
            await this.client.core.relayer.publishCustom({
                payload: {
                    pairingTopic: n.pairingTopic,
                    sessionProposal: o
                },
                opts: zt(Ue({}, s), {
                    publishMethod: "wc_proposeSession",
                    attestation: c
                })
            });
        }), ae(this, "sendApproveSession", async (t)=>{
            const { sessionTopic: n, pairingProposalResponse: s, proposal: i, sessionSettleRequest: o, publishOpts: a } = t, u = Ga(i.id, s), c = await this.client.core.crypto.encode(i.pairingTopic, u, {
                encoding: Zt
            }), l = ln("wc_sessionSettle", o, a == null ? void 0 : a.id), d = await this.client.core.crypto.encode(n, l, {
                encoding: Zt
            });
            this.client.core.history.set(n, l), await this.client.core.relayer.publishCustom({
                payload: {
                    sessionTopic: n,
                    pairingTopic: i.pairingTopic,
                    sessionProposalResponse: c,
                    sessionSettlementRequest: d
                },
                opts: zt(Ue({}, a), {
                    publishMethod: "wc_approveSession"
                })
            });
        }), ae(this, "sendResult", async (t)=>{
            const { id: n, topic: s, result: i, throwOnFailedPublish: o, encodeOpts: a, appLink: u } = t, c = Ga(n, i);
            let l;
            const d = u && typeof (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking) < "u";
            try {
                const g = d ? qn : Zt;
                l = await this.client.core.crypto.encode(s, c, zt(Ue({}, a || {}), {
                    encoding: g
                }));
            } catch (g) {
                throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), g;
            }
            let h, f;
            try {
                h = await this.client.core.history.get(s, n);
                const g = h.request;
                try {
                    f = this.getTVFParams(n, g.params, i);
                } catch (p) {
                    this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${p == null ? void 0 : p.message}`);
                }
            } catch (g) {
                throw this.client.logger.error(`sendResult() -> history.get(${s}, ${n}) failed`), g;
            }
            if (d) {
                const g = na(u, s, l);
                await /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking.openURL(g, this.client.name);
            } else {
                const g = h.request.method, p = Tt[g].res;
                p.tvf = zt(Ue({}, f), {
                    correlationId: n
                }), o ? (p.internal = zt(Ue({}, p.internal), {
                    throwOnFailedPublish: !0
                }), await this.client.core.relayer.publish(s, l, p)) : this.client.core.relayer.publish(s, l, p).catch((m)=>this.client.logger.error(m));
            }
            await this.client.core.history.resolve(c);
        }), ae(this, "sendError", async (t)=>{
            const { id: n, topic: s, error: i, encodeOpts: o, rpcOpts: a, appLink: u } = t, c = dh(n, i);
            let l;
            const d = u && typeof (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking) < "u";
            try {
                const f = d ? qn : Zt;
                l = await this.client.core.crypto.encode(s, c, zt(Ue({}, o || {}), {
                    encoding: f
                }));
            } catch (f) {
                throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), f;
            }
            let h;
            try {
                h = await this.client.core.history.get(s, n);
            } catch (f) {
                throw this.client.logger.error(`sendError() -> history.get(${s}, ${n}) failed`), f;
            }
            if (d) {
                const f = na(u, s, l);
                await /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking.openURL(f, this.client.name);
            } else {
                const f = h.request.method, g = a || Tt[f].res;
                this.client.core.relayer.publish(s, l, g);
            }
            await this.client.core.history.resolve(c);
        }), ae(this, "cleanup", async ()=>{
            const t = [], n = [];
            this.client.session.getAll().forEach((s)=>{
                let i = !1;
                jn(s.expiry) && (i = !0), this.client.core.crypto.keychain.has(s.topic) || (i = !0), i && t.push(s.topic);
            }), this.client.proposal.getAll().forEach((s)=>{
                jn(s.expiryTimestamp) && n.push(s.id);
            }), await Promise.all([
                ...t.map((s)=>this.deleteSession({
                        topic: s
                    })),
                ...n.map((s)=>this.deleteProposal(s))
            ]);
        }), ae(this, "onProviderMessageEvent", async (t)=>{
            !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t);
        }), ae(this, "onRelayEventRequest", async (t)=>{
            this.requestQueue.queue.push(t), await this.processRequestsQueue();
        }), ae(this, "processRequestsQueue", async ()=>{
            if (this.requestQueue.state === Pr.active) {
                this.client.logger.info("Request queue already active, skipping...");
                return;
            }
            for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;){
                this.requestQueue.state = Pr.active;
                const t = this.requestQueue.queue.shift();
                if (t) try {
                    await this.processRequest(t);
                } catch (n) {
                    this.client.logger.warn(n);
                }
            }
            this.requestQueue.state = Pr.idle;
        }), ae(this, "processRequest", async (t)=>{
            const { topic: n, payload: s, attestation: i, transportType: o, encryptedId: a } = t, u = s.method;
            if (!this.shouldIgnorePairingRequest({
                topic: n,
                requestMethod: u
            })) switch(u){
                case "wc_sessionPropose":
                    return await this.onSessionProposeRequest({
                        topic: n,
                        payload: s,
                        attestation: i,
                        encryptedId: a
                    });
                case "wc_sessionSettle":
                    return await this.onSessionSettleRequest(n, s);
                case "wc_sessionUpdate":
                    return await this.onSessionUpdateRequest(n, s);
                case "wc_sessionExtend":
                    return await this.onSessionExtendRequest(n, s);
                case "wc_sessionPing":
                    return await this.onSessionPingRequest(n, s);
                case "wc_sessionDelete":
                    return await this.onSessionDeleteRequest(n, s);
                case "wc_sessionRequest":
                    return await this.onSessionRequest({
                        topic: n,
                        payload: s,
                        attestation: i,
                        encryptedId: a,
                        transportType: o
                    });
                case "wc_sessionEvent":
                    return await this.onSessionEventRequest(n, s);
                case "wc_sessionAuthenticate":
                    return await this.onSessionAuthenticateRequest({
                        topic: n,
                        payload: s,
                        attestation: i,
                        encryptedId: a,
                        transportType: o
                    });
                default:
                    return this.client.logger.info(`Unsupported request method ${u}`);
            }
        }), ae(this, "onRelayEventResponse", async (t)=>{
            const { topic: n, payload: s, transportType: i } = t, o = (await this.client.core.history.get(n, s.id)).request.method;
            switch(o){
                case "wc_sessionPropose":
                    return this.onSessionProposeResponse(n, s, i);
                case "wc_sessionSettle":
                    return this.onSessionSettleResponse(n, s);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateResponse(n, s);
                case "wc_sessionExtend":
                    return this.onSessionExtendResponse(n, s);
                case "wc_sessionPing":
                    return this.onSessionPingResponse(n, s);
                case "wc_sessionRequest":
                    return this.onSessionRequestResponse(n, s);
                case "wc_sessionAuthenticate":
                    return this.onSessionAuthenticateResponse(n, s);
                default:
                    return this.client.logger.info(`Unsupported response method ${o}`);
            }
        }), ae(this, "onRelayEventUnknownPayload", (t)=>{
            const { topic: n } = t, { message: s } = ce("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
            throw new Error(s);
        }), ae(this, "shouldIgnorePairingRequest", (t)=>{
            const { topic: n, requestMethod: s } = t, i = this.expectedPairingMethodMap.get(n);
            return !i || i.includes(s) ? !1 : !!(i.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
        }), ae(this, "onSessionProposeRequest", async (t)=>{
            const { topic: n, payload: s, attestation: i, encryptedId: o } = t, { params: a, id: u } = s;
            try {
                const c = this.client.core.eventClient.getEvent({
                    topic: n
                });
                this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c == null || c.setError(on.proposal_listener_not_found)), this.isValidConnect(Ue({}, s.params));
                const l = a.expiryTimestamp || dt(Tt.wc_sessionPropose.req.ttl), d = Ue({
                    id: u,
                    pairingTopic: n,
                    expiryTimestamp: l,
                    attestation: i,
                    encryptedId: o
                }, a);
                await this.setProposal(u, d);
                const h = await this.getVerifyContext({
                    attestationId: i,
                    hash: yr(JSON.stringify(s)),
                    encryptedId: o,
                    metadata: d.proposer.metadata
                });
                c == null || c.addTrace(Br.emit_session_proposal), this.client.events.emit("session_proposal", {
                    id: u,
                    params: d,
                    verifyContext: h
                });
            } catch (c) {
                await this.sendError({
                    id: u,
                    topic: n,
                    error: c,
                    rpcOpts: Tt.wc_sessionPropose.autoReject
                }), this.client.logger.error(c);
            }
        }), ae(this, "onSessionProposeResponse", async (t, n, s)=>{
            const { id: i } = n;
            if (Qr(n)) {
                const { result: o } = n;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    result: o
                });
                const a = this.client.proposal.get(i);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    proposal: a
                });
                const u = a.proposer.publicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    selfPublicKey: u
                });
                const c = o.responderPublicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    peerPublicKey: c
                });
                const l = await this.client.core.crypto.generateSharedKey(u, c);
                this.pendingSessions.set(i, {
                    sessionTopic: l,
                    pairingTopic: t,
                    proposalId: i,
                    publicKey: u
                });
                const d = await this.client.core.relayer.subscribe(l, {
                    transportType: s
                });
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    subscriptionId: d
                }), await this.client.core.pairing.activate({
                    topic: t
                });
            } else if (wr(n)) {
                await this.deleteProposal(i);
                const o = Pe("session_connect", i);
                if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners, 954`);
                this.events.emit(o, {
                    error: n.error
                });
            }
        }), ae(this, "onSessionSettleRequest", async (t, n)=>{
            const { id: s, params: i } = n;
            try {
                this.isValidSessionSettleRequest(i);
                const { relay: o, controller: a, expiry: u, namespaces: c, sessionProperties: l, scopedProperties: d, sessionConfig: h } = n.params, f = [
                    ...this.pendingSessions.values()
                ].find((m)=>m.sessionTopic === t);
                if (!f) return this.client.logger.error(`Pending session not found for topic ${t}`);
                const g = this.client.proposal.get(f.proposalId), p = zt(Ue(Ue(Ue({
                    topic: t,
                    relay: o,
                    expiry: u,
                    namespaces: c,
                    acknowledged: !0,
                    pairingTopic: f.pairingTopic,
                    requiredNamespaces: g.requiredNamespaces,
                    optionalNamespaces: g.optionalNamespaces,
                    controller: a.publicKey,
                    self: {
                        publicKey: f.publicKey,
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: a.publicKey,
                        metadata: a.metadata
                    }
                }, l && {
                    sessionProperties: l
                }), d && {
                    scopedProperties: d
                }), h && {
                    sessionConfig: h
                }), {
                    transportType: Ge.relay
                });
                await this.client.session.set(p.topic, p), await this.setExpiry(p.topic, p.expiry), await this.client.core.pairing.updateMetadata({
                    topic: f.pairingTopic,
                    metadata: p.peer.metadata
                }), this.client.events.emit("session_connect", {
                    session: p
                }), this.events.emit(Pe("session_connect", f.proposalId), {
                    session: p
                }), this.pendingSessions.delete(f.proposalId), this.deleteProposal(f.proposalId, !1), this.cleanupDuplicatePairings(p), await this.sendResult({
                    id: n.id,
                    topic: t,
                    result: !0
                });
            } catch (o) {
                await this.sendError({
                    id: s,
                    topic: t,
                    error: o
                }), this.client.logger.error(o);
            }
        }), ae(this, "onSessionSettleResponse", async (t, n)=>{
            const { id: s } = n;
            Qr(n) ? (await this.client.session.update(t, {
                acknowledged: !0
            }), this.events.emit(Pe("session_approve", s), {})) : wr(n) && (await this.client.session.delete(t, rt("USER_DISCONNECTED")), this.events.emit(Pe("session_approve", s), {
                error: n.error
            }));
        }), ae(this, "onSessionUpdateRequest", async (t, n)=>{
            const { params: s, id: i } = n;
            try {
                const o = `${t}_session_update`, a = $s.get(o);
                if (a && this.isRequestOutOfSync(a, i)) {
                    this.client.logger.warn(`Discarding out of sync request - ${i}`), this.sendError({
                        id: i,
                        topic: t,
                        error: rt("INVALID_UPDATE_REQUEST")
                    });
                    return;
                }
                this.isValidUpdate(Ue({
                    topic: t
                }, s));
                try {
                    $s.set(o, i), await this.client.session.update(t, {
                        namespaces: s.namespaces
                    }), await this.sendResult({
                        id: i,
                        topic: t,
                        result: !0
                    });
                } catch (u) {
                    throw $s.delete(o), u;
                }
                this.client.events.emit("session_update", {
                    id: i,
                    topic: t,
                    params: s
                });
            } catch (o) {
                await this.sendError({
                    id: i,
                    topic: t,
                    error: o
                }), this.client.logger.error(o);
            }
        }), ae(this, "isRequestOutOfSync", (t, n)=>n.toString().slice(0, -3) < t.toString().slice(0, -3)), ae(this, "onSessionUpdateResponse", (t, n)=>{
            const { id: s } = n, i = Pe("session_update", s);
            if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
            Qr(n) ? this.events.emit(Pe("session_update", s), {}) : wr(n) && this.events.emit(Pe("session_update", s), {
                error: n.error
            });
        }), ae(this, "onSessionExtendRequest", async (t, n)=>{
            const { id: s } = n;
            try {
                this.isValidExtend({
                    topic: t
                }), await this.setExpiry(t, dt(Yi)), await this.sendResult({
                    id: s,
                    topic: t,
                    result: !0
                }), this.client.events.emit("session_extend", {
                    id: s,
                    topic: t
                });
            } catch (i) {
                await this.sendError({
                    id: s,
                    topic: t,
                    error: i
                }), this.client.logger.error(i);
            }
        }), ae(this, "onSessionExtendResponse", (t, n)=>{
            const { id: s } = n, i = Pe("session_extend", s);
            if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
            Qr(n) ? this.events.emit(Pe("session_extend", s), {}) : wr(n) && this.events.emit(Pe("session_extend", s), {
                error: n.error
            });
        }), ae(this, "onSessionPingRequest", async (t, n)=>{
            const { id: s } = n;
            try {
                this.isValidPing({
                    topic: t
                }), await this.sendResult({
                    id: s,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                }), this.client.events.emit("session_ping", {
                    id: s,
                    topic: t
                });
            } catch (i) {
                await this.sendError({
                    id: s,
                    topic: t,
                    error: i
                }), this.client.logger.error(i);
            }
        }), ae(this, "onSessionPingResponse", (t, n)=>{
            const { id: s } = n, i = Pe("session_ping", s);
            setTimeout(()=>{
                if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners 2176`);
                Qr(n) ? this.events.emit(Pe("session_ping", s), {}) : wr(n) && this.events.emit(Pe("session_ping", s), {
                    error: n.error
                });
            }, 500);
        }), ae(this, "onSessionDeleteRequest", async (t, n)=>{
            const { id: s } = n;
            try {
                this.isValidDisconnect({
                    topic: t,
                    reason: n.params
                }), await Promise.all([
                    new Promise((i)=>{
                        this.client.core.relayer.once(st.publish, async ()=>{
                            i(await this.deleteSession({
                                topic: t,
                                id: s
                            }));
                        });
                    }),
                    this.sendResult({
                        id: s,
                        topic: t,
                        result: !0
                    }),
                    this.cleanupPendingSentRequestsForTopic({
                        topic: t,
                        error: rt("USER_DISCONNECTED")
                    })
                ]).catch((i)=>this.client.logger.error(i));
            } catch (i) {
                this.client.logger.error(i);
            }
        }), ae(this, "onSessionRequest", async (t)=>{
            var n, s, i;
            const { topic: o, payload: a, attestation: u, encryptedId: c, transportType: l } = t, { id: d, params: h } = a;
            try {
                await this.isValidRequest(Ue({
                    topic: o
                }, h));
                const f = this.client.session.get(o), g = await this.getVerifyContext({
                    attestationId: u,
                    hash: yr(JSON.stringify(ln("wc_sessionRequest", h, d))),
                    encryptedId: c,
                    metadata: f.peer.metadata,
                    transportType: l
                }), p = {
                    id: d,
                    topic: o,
                    params: h,
                    verifyContext: g
                };
                await this.setPendingSessionRequest(p), l === Ge.link_mode && (n = f.peer.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp((s = f.peer.metadata.redirect) == null ? void 0 : s.universal), (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(p) : (this.addSessionRequestToSessionRequestQueue(p), this.processSessionRequestQueue());
            } catch (f) {
                await this.sendError({
                    id: d,
                    topic: o,
                    error: f
                }), this.client.logger.error(f);
            }
        }), ae(this, "onSessionRequestResponse", (t, n)=>{
            const { id: s } = n, i = Pe("session_request", s);
            if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
            Qr(n) ? this.events.emit(Pe("session_request", s), {
                result: n.result
            }) : wr(n) && this.events.emit(Pe("session_request", s), {
                error: n.error
            });
        }), ae(this, "onSessionEventRequest", async (t, n)=>{
            const { id: s, params: i } = n;
            try {
                const o = `${t}_session_event_${i.event.name}`, a = $s.get(o);
                if (a && this.isRequestOutOfSync(a, s)) {
                    this.client.logger.info(`Discarding out of sync request - ${s}`);
                    return;
                }
                this.isValidEmit(Ue({
                    topic: t
                }, i)), this.client.events.emit("session_event", {
                    id: s,
                    topic: t,
                    params: i
                }), $s.set(o, s);
            } catch (o) {
                await this.sendError({
                    id: s,
                    topic: t,
                    error: o
                }), this.client.logger.error(o);
            }
        }), ae(this, "onSessionAuthenticateResponse", (t, n)=>{
            const { id: s } = n;
            this.client.logger.trace({
                type: "method",
                method: "onSessionAuthenticateResponse",
                topic: t,
                payload: n
            }), Qr(n) ? this.events.emit(Pe("session_request", s), {
                result: n.result
            }) : wr(n) && this.events.emit(Pe("session_request", s), {
                error: n.error
            });
        }), ae(this, "onSessionAuthenticateRequest", async (t)=>{
            var n;
            const { topic: s, payload: i, attestation: o, encryptedId: a, transportType: u } = t;
            try {
                const { requester: c, authPayload: l, expiryTimestamp: d } = i.params, h = await this.getVerifyContext({
                    attestationId: o,
                    hash: yr(JSON.stringify(i)),
                    encryptedId: a,
                    metadata: c.metadata,
                    transportType: u
                }), f = {
                    requester: c,
                    pairingTopic: s,
                    id: i.id,
                    authPayload: l,
                    verifyContext: h,
                    expiryTimestamp: d
                };
                await this.setAuthRequest(i.id, {
                    request: f,
                    pairingTopic: s,
                    transportType: u
                }), u === Ge.link_mode && (n = c.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp(c.metadata.redirect.universal), this.client.events.emit("session_authenticate", {
                    topic: s,
                    params: i.params,
                    id: i.id,
                    verifyContext: h
                });
            } catch (c) {
                this.client.logger.error(c);
                const l = i.params.requester.publicKey, d = await this.client.core.crypto.generateKeyPair(), h = this.getAppLinkIfEnabled(i.params.requester.metadata, u), f = {
                    type: pn,
                    receiverPublicKey: l,
                    senderPublicKey: d
                };
                await this.sendError({
                    id: i.id,
                    topic: s,
                    error: c,
                    encodeOpts: f,
                    rpcOpts: Tt.wc_sessionAuthenticate.autoReject,
                    appLink: h
                });
            }
        }), ae(this, "addSessionRequestToSessionRequestQueue", (t)=>{
            this.sessionRequestQueue.queue.push(t);
        }), ae(this, "cleanupAfterResponse", (t)=>{
            this.deletePendingSessionRequest(t.response.id, {
                message: "fulfilled",
                code: 0
            }), setTimeout(()=>{
                this.sessionRequestQueue.state = Pr.idle, this.processSessionRequestQueue();
            }, ue.toMiliseconds(this.requestQueueDelay));
        }), ae(this, "cleanupPendingSentRequestsForTopic", ({ topic: t, error: n })=>{
            const s = this.client.core.history.pending;
            s.length > 0 && s.filter((i)=>i.topic === t && i.request.method === "wc_sessionRequest").forEach((i)=>{
                const o = i.request.id, a = Pe("session_request", o);
                if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners`);
                this.events.emit(Pe("session_request", i.request.id), {
                    error: n
                });
            });
        }), ae(this, "processSessionRequestQueue", ()=>{
            if (this.sessionRequestQueue.state === Pr.active) {
                this.client.logger.info("session request queue is already active.");
                return;
            }
            const t = this.sessionRequestQueue.queue[0];
            if (!t) {
                this.client.logger.info("session request queue is empty.");
                return;
            }
            try {
                this.emitSessionRequest(t);
            } catch (n) {
                this.client.logger.error(n);
            }
        }), ae(this, "emitSessionRequest", (t)=>{
            if (this.emittedSessionRequests.has(t.id)) {
                this.client.logger.warn({
                    id: t.id
                }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);
                return;
            }
            this.sessionRequestQueue.state = Pr.active, this.emittedSessionRequests.add(t.id), this.client.events.emit("session_request", t);
        }), ae(this, "onPairingCreated", (t)=>{
            if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active) return;
            const n = this.client.proposal.getAll().find((s)=>s.pairingTopic === t.topic);
            n && this.onSessionProposeRequest({
                topic: t.topic,
                payload: ln("wc_sessionPropose", zt(Ue({}, n), {
                    requiredNamespaces: n.requiredNamespaces,
                    optionalNamespaces: n.optionalNamespaces,
                    relays: n.relays,
                    proposer: n.proposer,
                    sessionProperties: n.sessionProperties,
                    scopedProperties: n.scopedProperties
                }), n.id),
                attestation: n.attestation,
                encryptedId: n.encryptedId
            });
        }), ae(this, "isValidConnect", async (t)=>{
            if (!Wt(t)) {
                const { message: c } = ce("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
                throw new Error(c);
            }
            const { pairingTopic: n, requiredNamespaces: s, optionalNamespaces: i, sessionProperties: o, scopedProperties: a, relays: u } = t;
            if (pt(n) || await this.isValidPairingTopic(n), !TC(u)) {
                const { message: c } = ce("MISSING_OR_INVALID", `connect() relays: ${u}`);
                throw new Error(c);
            }
            if (s && !pt(s) && po(s) !== 0) {
                const c = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
                [
                    "fatal",
                    "error",
                    "silent"
                ].includes(this.client.logger.level) ? console.warn(c) : this.client.logger.warn(c), this.validateNamespaces(s, "requiredNamespaces");
            }
            if (i && !pt(i) && po(i) !== 0 && this.validateNamespaces(i, "optionalNamespaces"), o && !pt(o) && this.validateSessionProps(o, "sessionProperties"), a && !pt(a)) {
                this.validateSessionProps(a, "scopedProperties");
                const c = Object.keys(s || {}).concat(Object.keys(i || {}));
                if (!Object.keys(a).every((l)=>c.includes(l.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(c)}`);
            }
        }), ae(this, "validateNamespaces", (t, n)=>{
            const s = IC(t, "connect()", n);
            if (s) throw new Error(s.message);
        }), ae(this, "isValidApprove", async (t)=>{
            if (!Wt(t)) throw new Error(ce("MISSING_OR_INVALID", `approve() params: ${t}`).message);
            const { id: n, namespaces: s, relayProtocol: i, sessionProperties: o, scopedProperties: a } = t;
            this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
            const u = this.client.proposal.get(n), c = Xu(s, "approve()");
            if (c) throw new Error(c.message);
            const l = gg(u.requiredNamespaces, s, "approve()");
            if (l) throw new Error(l.message);
            if (!ct(i, !0)) {
                const { message: d } = ce("MISSING_OR_INVALID", `approve() relayProtocol: ${i}`);
                throw new Error(d);
            }
            if (o && !pt(o) && this.validateSessionProps(o, "sessionProperties"), a && !pt(a)) {
                this.validateSessionProps(a, "scopedProperties");
                const d = new Set(Object.keys(s));
                if (!Object.keys(a).every((h)=>d.has(h.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(d).join(", ")}`);
            }
        }), ae(this, "isValidReject", async (t)=>{
            if (!Wt(t)) {
                const { message: i } = ce("MISSING_OR_INVALID", `reject() params: ${t}`);
                throw new Error(i);
            }
            const { id: n, reason: s } = t;
            if (this.checkRecentlyDeleted(n), await this.isValidProposalId(n), !_C(s)) {
                const { message: i } = ce("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
                throw new Error(i);
            }
        }), ae(this, "isValidSessionSettleRequest", (t)=>{
            if (!Wt(t)) {
                const { message: c } = ce("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
                throw new Error(c);
            }
            const { relay: n, controller: s, namespaces: i, expiry: o } = t;
            if (!T1(n)) {
                const { message: c } = ce("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                throw new Error(c);
            }
            const a = bC(s, "onSessionSettleRequest()");
            if (a) throw new Error(a.message);
            const u = Xu(i, "onSessionSettleRequest()");
            if (u) throw new Error(u.message);
            if (jn(o)) {
                const { message: c } = ce("EXPIRED", "onSessionSettleRequest()");
                throw new Error(c);
            }
        }), ae(this, "isValidUpdate", async (t)=>{
            if (!Wt(t)) {
                const { message: u } = ce("MISSING_OR_INVALID", `update() params: ${t}`);
                throw new Error(u);
            }
            const { topic: n, namespaces: s } = t;
            this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
            const i = this.client.session.get(n), o = Xu(s, "update()");
            if (o) throw new Error(o.message);
            const a = gg(i.requiredNamespaces, s, "update()");
            if (a) throw new Error(a.message);
        }), ae(this, "isValidExtend", async (t)=>{
            if (!Wt(t)) {
                const { message: s } = ce("MISSING_OR_INVALID", `extend() params: ${t}`);
                throw new Error(s);
            }
            const { topic: n } = t;
            this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
        }), ae(this, "isValidRequest", async (t)=>{
            if (!Wt(t)) {
                const { message: u } = ce("MISSING_OR_INVALID", `request() params: ${t}`);
                throw new Error(u);
            }
            const { topic: n, request: s, chainId: i, expiry: o } = t;
            this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
            const { namespaces: a } = this.client.session.get(n);
            if (!pg(a, i)) {
                const { message: u } = ce("MISSING_OR_INVALID", `request() chainId: ${i}`);
                throw new Error(u);
            }
            if (!AC(s)) {
                const { message: u } = ce("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
                throw new Error(u);
            }
            if (!jC(a, i, s.method)) {
                const { message: u } = ce("MISSING_OR_INVALID", `request() method: ${s.method}`);
                throw new Error(u);
            }
            if (o && !zC(o, nl)) {
                const { message: u } = ce("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${nl.min} and ${nl.max}`);
                throw new Error(u);
            }
        }), ae(this, "isValidRespond", async (t)=>{
            var n;
            if (!Wt(t)) {
                const { message: a } = ce("MISSING_OR_INVALID", `respond() params: ${t}`);
                throw new Error(a);
            }
            const { topic: s, response: i } = t;
            try {
                await this.isValidSessionTopic(s);
            } catch (a) {
                throw (n = t == null ? void 0 : t.response) != null && n.id && this.cleanupAfterResponse(t), a;
            }
            if (!SC(i)) {
                const { message: a } = ce("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i)}`);
                throw new Error(a);
            }
            const o = this.client.pendingRequest.get(i.id);
            if (o.topic !== s) {
                const { message: a } = ce("MISMATCHED_TOPIC", `Request response topic mismatch. reqId: ${i.id}, expected topic: ${o.topic}, received topic: ${s}`);
                throw new Error(a);
            }
        }), ae(this, "isValidPing", async (t)=>{
            if (!Wt(t)) {
                const { message: s } = ce("MISSING_OR_INVALID", `ping() params: ${t}`);
                throw new Error(s);
            }
            const { topic: n } = t;
            await this.isValidSessionOrPairingTopic(n);
        }), ae(this, "isValidEmit", async (t)=>{
            if (!Wt(t)) {
                const { message: a } = ce("MISSING_OR_INVALID", `emit() params: ${t}`);
                throw new Error(a);
            }
            const { topic: n, event: s, chainId: i } = t;
            await this.isValidSessionTopic(n);
            const { namespaces: o } = this.client.session.get(n);
            if (!pg(o, i)) {
                const { message: a } = ce("MISSING_OR_INVALID", `emit() chainId: ${i}`);
                throw new Error(a);
            }
            if (!OC(s)) {
                const { message: a } = ce("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
                throw new Error(a);
            }
            if (!CC(o, i, s.name)) {
                const { message: a } = ce("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
                throw new Error(a);
            }
        }), ae(this, "isValidDisconnect", async (t)=>{
            if (!Wt(t)) {
                const { message: s } = ce("MISSING_OR_INVALID", `disconnect() params: ${t}`);
                throw new Error(s);
            }
            const { topic: n } = t;
            await this.isValidSessionOrPairingTopic(n);
        }), ae(this, "isValidAuthenticate", (t)=>{
            const { chains: n, uri: s, domain: i, nonce: o } = t;
            if (!Array.isArray(n) || n.length === 0) throw new Error("chains is required and must be a non-empty array");
            if (!ct(s, !1)) throw new Error("uri is required parameter");
            if (!ct(i, !1)) throw new Error("domain is required parameter");
            if (!ct(o, !1)) throw new Error("nonce is required parameter");
            if ([
                ...new Set(n.map((u)=>va(u).namespace))
            ].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
            const { namespace: a } = va(n[0]);
            if (a !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
        }), ae(this, "getVerifyContext", async (t)=>{
            const { attestationId: n, hash: s, encryptedId: i, metadata: o, transportType: a } = t, u = {
                verified: {
                    verifyUrl: o.verifyUrl || ro,
                    validation: "UNKNOWN",
                    origin: o.url || ""
                }
            };
            try {
                if (a === Ge.link_mode) {
                    const l = this.getAppLinkIfEnabled(o, a);
                    return u.verified.validation = l && new URL(l).origin === new URL(o.url).origin ? "VALID" : "INVALID", u;
                }
                const c = await this.client.core.verify.resolve({
                    attestationId: n,
                    hash: s,
                    encryptedId: i,
                    verifyUrl: o.verifyUrl
                });
                c && (u.verified.origin = c.origin, u.verified.isScam = c.isScam, u.verified.validation = c.origin === new URL(o.url).origin ? "VALID" : "INVALID");
            } catch (c) {
                this.client.logger.warn(c);
            }
            return this.client.logger.debug(`Verify context: ${JSON.stringify(u)}`), u;
        }), ae(this, "validateSessionProps", (t, n)=>{
            Object.values(t).forEach((s, i)=>{
                if (s == null) {
                    const { message: o } = ce("MISSING_OR_INVALID", `${n} must contain an existing value for each key. Received: ${s} for key ${Object.keys(t)[i]}`);
                    throw new Error(o);
                }
            });
        }), ae(this, "getPendingAuthRequest", (t)=>{
            const n = this.client.auth.requests.get(t);
            return typeof n == "object" ? n : void 0;
        }), ae(this, "addToRecentlyDeleted", (t, n)=>{
            if (this.recentlyDeletedMap.set(t, n), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
                let s = 0;
                const i = this.recentlyDeletedLimit / 2;
                for (const o of this.recentlyDeletedMap.keys()){
                    if (s++ >= i) break;
                    this.recentlyDeletedMap.delete(o);
                }
            }
        }), ae(this, "checkRecentlyDeleted", (t)=>{
            const n = this.recentlyDeletedMap.get(t);
            if (n) {
                const { message: s } = ce("MISSING_OR_INVALID", `Record was recently deleted - ${n}: ${t}`);
                throw new Error(s);
            }
        }), ae(this, "isLinkModeEnabled", (t, n)=>{
            var s, i, o, a, u, c, l, d, h;
            return !t || n !== Ge.link_mode ? !1 : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === !0 && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((c = (u = this.client.metadata) == null ? void 0 : u.redirect) == null ? void 0 : c.universal) !== "" && ((l = t == null ? void 0 : t.redirect) == null ? void 0 : l.universal) !== void 0 && ((d = t == null ? void 0 : t.redirect) == null ? void 0 : d.universal) !== "" && ((h = t == null ? void 0 : t.redirect) == null ? void 0 : h.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (/*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking) < "u";
        }), ae(this, "getAppLinkIfEnabled", (t, n)=>{
            var s;
            return this.isLinkModeEnabled(t, n) ? (s = t == null ? void 0 : t.redirect) == null ? void 0 : s.universal : void 0;
        }), ae(this, "handleLinkModeMessage", ({ url: t })=>{
            if (!t || !t.includes("wc_ev") || !t.includes("topic")) return;
            const n = Tp(t, "topic") || "", s = decodeURIComponent(Tp(t, "wc_ev") || ""), i = this.client.session.keys.includes(n);
            i && this.client.session.update(n, {
                transportType: Ge.link_mode
            }), this.client.core.dispatchEnvelope({
                topic: n,
                message: s,
                sessionExists: i
            });
        }), ae(this, "registerLinkModeListeners", async ()=>{
            var t;
            if (Zd() || Xn() && (t = this.client.metadata.redirect) != null && t.linkMode) {
                const n = /*TURBOPACK member replacement*/ __turbopack_context__.g == null ? void 0 : /*TURBOPACK member replacement*/ __turbopack_context__.g.Linking;
                if (typeof n < "u") {
                    n.addEventListener("url", this.handleLinkModeMessage, this.client.name);
                    const s = await n.getInitialURL();
                    s && setTimeout(()=>{
                        this.handleLinkModeMessage({
                            url: s
                        });
                    }, 50);
                }
            }
        }), ae(this, "getTVFParams", (t, n, s)=>{
            var i, o, a;
            if (!((i = n.request) != null && i.method)) return {};
            const u = {
                correlationId: t,
                rpcMethods: [
                    n.request.method
                ],
                chainId: n.chainId
            };
            try {
                const c = this.extractTxHashesFromResult(n.request, s);
                u.txHashes = c, u.contractAddresses = this.isValidContractData(n.request.params) ? [
                    (a = (o = n.request.params) == null ? void 0 : o[0]) == null ? void 0 : a.to
                ] : [];
            } catch (c) {
                this.client.logger.warn(c, "Error getting TVF params");
            }
            return u;
        }), ae(this, "isValidContractData", (t)=>{
            var n;
            if (!t) return !1;
            try {
                const s = (t == null ? void 0 : t.data) || ((n = t == null ? void 0 : t[0]) == null ? void 0 : n.data);
                if (!s.startsWith("0x")) return !1;
                const i = s.slice(2);
                return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : !1;
            } catch  {}
            return !1;
        }), ae(this, "extractTxHashesFromResult", (t, n)=>{
            var s;
            try {
                if (!n) return [];
                const i = t.method, o = oP[i];
                if (i === "sui_signTransaction") return [
                    X4(n.transactionBytes)
                ];
                if (i === "near_signTransaction") return [
                    Lp(n)
                ];
                if (i === "near_signTransactions") return n.map((u)=>Lp(u));
                if (i === "xrpl_signTransactionFor" || i === "xrpl_signTransaction") return [
                    (s = n.tx_json) == null ? void 0 : s.hash
                ];
                if (i === "polkadot_signTransaction") return [
                    XC({
                        transaction: t.params.transactionPayload,
                        signature: n.signature
                    })
                ];
                if (i === "algo_signTxn") return ls(n) ? n.map((u)=>kp(u)) : [
                    kp(n)
                ];
                if (i === "cosmos_signDirect") return [
                    J4(n)
                ];
                if (i === "wallet_sendCalls") return e3(n);
                if (typeof n == "string") return [
                    n
                ];
                const a = n[o.key];
                if (ls(a)) return i === "solana_signAllTransactions" ? a.map((u)=>K4(u)) : a;
                if (typeof a == "string") return [
                    a
                ];
            } catch (i) {
                this.client.logger.warn(i, "Error extracting tx hashes from result");
            }
            return [];
        });
    }
    async processPendingMessageEvents() {
        try {
            const e = this.client.session.keys, t = this.client.core.relayer.messages.getWithoutAck(e);
            for (const [n, s] of Object.entries(t))for (const i of s)try {
                await this.onProviderMessageEvent({
                    topic: n,
                    message: i,
                    publishedAt: Date.now()
                });
            } catch  {
                this.client.logger.warn(`Error processing pending message event for topic: ${n}, message: ${i}`);
            }
        } catch (e) {
            this.client.logger.warn(e, "processPendingMessageEvents failed");
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const { message: e } = ce("NOT_INITIALIZED", this.name);
            throw new Error(e);
        }
    }
    async confirmOnlineStateOrThrow() {
        await this.client.core.relayer.confirmOnlineStateOrThrow();
    }
    registerRelayerEvents() {
        this.client.core.relayer.on(st.message, (e)=>{
            this.onProviderMessageEvent(e);
        });
    }
    async onRelayMessage(e) {
        const { topic: t, message: n, attestation: s, transportType: i } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes(xa) ? this.client.auth.authKeys.get(xa) : {
            publicKey: void 0
        };
        try {
            const a = await this.client.core.crypto.decode(t, n, {
                receiverPublicKey: o,
                encoding: i === Ge.link_mode ? qn : Zt
            });
            hh(a) ? (this.client.core.history.set(t, a), await this.onRelayEventRequest({
                topic: t,
                payload: a,
                attestation: s,
                transportType: i,
                encryptedId: yr(n)
            })) : Gc(a) ? (await this.client.core.history.resolve(a), await this.onRelayEventResponse({
                topic: t,
                payload: a,
                transportType: i
            }), this.client.core.history.delete(t, a.id)) : await this.onRelayEventUnknownPayload({
                topic: t,
                payload: a,
                transportType: i
            }), await this.client.core.relayer.messages.ack(t, n);
        } catch (a) {
            this.client.logger.error(a);
        }
    }
    registerExpirerEvents() {
        this.client.core.expirer.on(fr.expired, async (e)=>{
            const { topic: t, id: n } = Tm(e.target);
            if (n && this.client.pendingRequest.keys.includes(n)) return await this.deletePendingSessionRequest(n, ce("EXPIRED"), !0);
            if (n && this.client.auth.requests.keys.includes(n)) return await this.deletePendingAuthRequest(n, ce("EXPIRED"), !0);
            t ? this.client.session.keys.includes(t) && (await this.deleteSession({
                topic: t,
                expirerHasDeleted: !0
            }), this.client.events.emit("session_expire", {
                topic: t
            })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", {
                id: n
            }));
        });
    }
    registerPairingEvents() {
        this.client.core.pairing.events.on(fi.create, (e)=>this.onPairingCreated(e)), this.client.core.pairing.events.on(fi.delete, (e)=>{
            this.addToRecentlyDeleted(e.topic, "pairing");
        });
    }
    isValidPairingTopic(e) {
        if (!ct(e, !1)) {
            const { message: t } = ce("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
            throw new Error(t);
        }
        if (!this.client.core.pairing.pairings.keys.includes(e)) {
            const { message: t } = ce("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
            throw new Error(t);
        }
        if (jn(this.client.core.pairing.pairings.get(e).expiry)) {
            const { message: t } = ce("EXPIRED", `pairing topic: ${e}`);
            throw new Error(t);
        }
    }
    async isValidSessionTopic(e) {
        if (!ct(e, !1)) {
            const { message: t } = ce("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
            throw new Error(t);
        }
        if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
            const { message: t } = ce("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
            throw new Error(t);
        }
        if (jn(this.client.session.get(e).expiry)) {
            await this.deleteSession({
                topic: e
            });
            const { message: t } = ce("EXPIRED", `session topic: ${e}`);
            throw new Error(t);
        }
        if (!this.client.core.crypto.keychain.has(e)) {
            const { message: t } = ce("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
            throw await this.deleteSession({
                topic: e
            }), new Error(t);
        }
    }
    async isValidSessionOrPairingTopic(e) {
        if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
        else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
        else if (ct(e, !1)) {
            const { message: t } = ce("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
            throw new Error(t);
        } else {
            const { message: t } = ce("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
            throw new Error(t);
        }
    }
    async isValidProposalId(e) {
        if (!DC(e)) {
            const { message: t } = ce("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
            throw new Error(t);
        }
        if (!this.client.proposal.keys.includes(e)) {
            const { message: t } = ce("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
            throw new Error(t);
        }
        if (jn(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            const { message: t } = ce("EXPIRED", `proposal id: ${e}`);
            throw new Error(t);
        }
    }
}
class vP extends ki {
    constructor(e, t){
        super(e, t, nP, ph), this.core = e, this.logger = t;
    }
}
class EP extends ki {
    constructor(e, t){
        super(e, t, iP, ph), this.core = e, this.logger = t;
    }
}
class MP extends ki {
    constructor(e, t){
        super(e, t, aP, ph, (n)=>n.id), this.core = e, this.logger = t;
    }
}
class NP extends ki {
    constructor(e, t){
        super(e, t, dP, Wc, ()=>xa), this.core = e, this.logger = t;
    }
}
class xP extends ki {
    constructor(e, t){
        super(e, t, hP, Wc), this.core = e, this.logger = t;
    }
}
class IP extends ki {
    constructor(e, t){
        super(e, t, fP, Wc, (n)=>n.id), this.core = e, this.logger = t;
    }
}
var TP = Object.defineProperty, DP = (r, e, t)=>e in r ? TP(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, il = (r, e, t)=>DP(r, typeof e != "symbol" ? e + "" : e, t);
class _P {
    constructor(e, t){
        this.core = e, this.logger = t, il(this, "authKeys"), il(this, "pairingTopics"), il(this, "requests"), this.authKeys = new NP(this.core, this.logger), this.pairingTopics = new xP(this.core, this.logger), this.requests = new IP(this.core, this.logger);
    }
    async init() {
        await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
    }
}
var AP = Object.defineProperty, SP = (r, e, t)=>e in r ? AP(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, Ce = (r, e, t)=>SP(r, typeof e != "symbol" ? e + "" : e, t);
class Ha extends gI {
    constructor(e){
        super(e), Ce(this, "protocol", H1), Ce(this, "version", W1), Ce(this, "name", rl.name), Ce(this, "metadata"), Ce(this, "core"), Ce(this, "logger"), Ce(this, "events", new rr.EventEmitter()), Ce(this, "engine"), Ce(this, "session"), Ce(this, "proposal"), Ce(this, "pendingRequest"), Ce(this, "auth"), Ce(this, "signConfig"), Ce(this, "on", (n, s)=>this.events.on(n, s)), Ce(this, "once", (n, s)=>this.events.once(n, s)), Ce(this, "off", (n, s)=>this.events.off(n, s)), Ce(this, "removeListener", (n, s)=>this.events.removeListener(n, s)), Ce(this, "removeAllListeners", (n)=>this.events.removeAllListeners(n)), Ce(this, "connect", async (n)=>{
            try {
                return await this.engine.connect(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "pair", async (n)=>{
            try {
                return await this.engine.pair(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "approve", async (n)=>{
            try {
                return await this.engine.approve(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "reject", async (n)=>{
            try {
                return await this.engine.reject(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "update", async (n)=>{
            try {
                return await this.engine.update(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "extend", async (n)=>{
            try {
                return await this.engine.extend(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "request", async (n)=>{
            try {
                return await this.engine.request(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "respond", async (n)=>{
            try {
                return await this.engine.respond(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "ping", async (n)=>{
            try {
                return await this.engine.ping(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "emit", async (n)=>{
            try {
                return await this.engine.emit(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "disconnect", async (n)=>{
            try {
                return await this.engine.disconnect(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "find", (n)=>{
            try {
                return this.engine.find(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "getPendingSessionRequests", ()=>{
            try {
                return this.engine.getPendingSessionRequests();
            } catch (n) {
                throw this.logger.error(n.message), n;
            }
        }), Ce(this, "authenticate", async (n, s)=>{
            try {
                return await this.engine.authenticate(n, s);
            } catch (i) {
                throw this.logger.error(i.message), i;
            }
        }), Ce(this, "formatAuthMessage", (n)=>{
            try {
                return this.engine.formatAuthMessage(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "approveSessionAuthenticate", async (n)=>{
            try {
                return await this.engine.approveSessionAuthenticate(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), Ce(this, "rejectSessionAuthenticate", async (n)=>{
            try {
                return await this.engine.rejectSessionAuthenticate(n);
            } catch (s) {
                throw this.logger.error(s.message), s;
            }
        }), this.name = (e == null ? void 0 : e.name) || rl.name, this.metadata = qO(e == null ? void 0 : e.metadata), this.signConfig = e == null ? void 0 : e.signConfig;
        const t = D1({
            logger: (e == null ? void 0 : e.logger) || rl.logger,
            name: this.name
        });
        this.logger = t, this.core = (e == null ? void 0 : e.core) || new rP(e), this.session = new EP(this.core, this.logger), this.proposal = new vP(this.core, this.logger), this.pendingRequest = new MP(this.core, this.logger), this.engine = new bP(this), this.auth = new _P(this.core, this.logger);
    }
    static async init(e) {
        const t = new Ha(e);
        return await t.initialize(), t;
    }
    get context() {
        return nr(this.logger);
    }
    get pairing() {
        return this.core.pairing.pairings;
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
        } catch (e) {
            throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
        }
    }
}
const OP = Symbol(), Xg = Object.getPrototypeOf, ld = /* @__PURE__ */ new WeakMap(), jP = (r)=>r && (ld.has(r) ? ld.get(r) : Xg(r) === Object.prototype || Xg(r) === Array.prototype), CP = (r)=>jP(r) && r[OP] || null, Zg = (r, e = !0)=>{
    ld.set(r, e);
}, Wa = {}, sl = (r)=>typeof r == "object" && r !== null, zn = /* @__PURE__ */ new WeakMap(), ia = /* @__PURE__ */ new WeakSet(), LP = (r = Object.is, e = (c, l)=>new Proxy(c, l), t = (c)=>sl(c) && !ia.has(c) && (Array.isArray(c) || !(Symbol.iterator in c)) && !(c instanceof WeakMap) && !(c instanceof WeakSet) && !(c instanceof Error) && !(c instanceof Number) && !(c instanceof Date) && !(c instanceof String) && !(c instanceof RegExp) && !(c instanceof ArrayBuffer), n = (c)=>{
    switch(c.status){
        case "fulfilled":
            return c.value;
        case "rejected":
            throw c.reason;
        default:
            throw c;
    }
}, s = /* @__PURE__ */ new WeakMap(), i = (c, l, d = n)=>{
    const h = s.get(c);
    if ((h == null ? void 0 : h[0]) === l) return h[1];
    const f = Array.isArray(c) ? [] : Object.create(Object.getPrototypeOf(c));
    return Zg(f, !0), s.set(c, [
        l,
        f
    ]), Reflect.ownKeys(c).forEach((g)=>{
        if (Object.getOwnPropertyDescriptor(f, g)) return;
        const p = Reflect.get(c, g), m = {
            value: p,
            enumerable: !0,
            // This is intentional to avoid copying with proxy-compare.
            // It's still non-writable, so it avoids assigning a value.
            configurable: !0
        };
        if (ia.has(p)) Zg(p, !1);
        else if (p instanceof Promise) delete m.value, m.get = ()=>d(p);
        else if (zn.has(p)) {
            const [x, _] = zn.get(p);
            m.value = i(x, _(), d);
        }
        Object.defineProperty(f, g, m);
    }), Object.preventExtensions(f);
}, o = /* @__PURE__ */ new WeakMap(), a = [
    1,
    1
], u = (c)=>{
    if (!sl(c)) throw new Error("object required");
    const l = o.get(c);
    if (l) return l;
    let d = a[0];
    const h = /* @__PURE__ */ new Set(), f = (R, G = ++a[0])=>{
        d !== G && (d = G, h.forEach((F)=>F(R, G)));
    };
    let g = a[1];
    const p = (R = ++a[1])=>(g !== R && !h.size && (g = R, x.forEach(([G])=>{
            const F = G[1](R);
            F > d && (d = F);
        })), d), m = (R)=>(G, F)=>{
            const H = [
                ...G
            ];
            H[1] = [
                R,
                ...H[1]
            ], f(H, F);
        }, x = /* @__PURE__ */ new Map(), _ = (R, G)=>{
        if ((("TURBOPACK compile-time truthy", 1) ? "production" : "TURBOPACK unreachable") !== "production" && x.has(R)) //TURBOPACK unreachable
        ;
        if (h.size) {
            const F = G[3](m(R));
            x.set(R, [
                G,
                F
            ]);
        } else x.set(R, [
            G
        ]);
    }, v = (R)=>{
        var G;
        const F = x.get(R);
        F && (x.delete(R), (G = F[1]) == null || G.call(F));
    }, N = (R)=>(h.add(R), h.size === 1 && x.forEach(([F, H], B)=>{
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            const C = F[3](m(B));
            x.set(B, [
                F,
                C
            ]);
        }), ()=>{
            h.delete(R), h.size === 0 && x.forEach(([F, H], B)=>{
                H && (H(), x.set(B, [
                    F
                ]));
            });
        }), O = Array.isArray(c) ? [] : Object.create(Object.getPrototypeOf(c)), P = e(O, {
        deleteProperty (R, G) {
            const F = Reflect.get(R, G);
            v(G);
            const H = Reflect.deleteProperty(R, G);
            return H && f([
                "delete",
                [
                    G
                ],
                F
            ]), H;
        },
        set (R, G, F, H) {
            const B = Reflect.has(R, G), C = Reflect.get(R, G, H);
            if (B && (r(C, F) || o.has(F) && r(C, o.get(F)))) return !0;
            v(G), sl(F) && (F = CP(F) || F);
            let T = F;
            if (F instanceof Promise) F.then((I)=>{
                F.status = "fulfilled", F.value = I, f([
                    "resolve",
                    [
                        G
                    ],
                    I
                ]);
            }).catch((I)=>{
                F.status = "rejected", F.reason = I, f([
                    "reject",
                    [
                        G
                    ],
                    I
                ]);
            });
            else {
                !zn.has(F) && t(F) && (T = u(F));
                const I = !ia.has(T) && zn.get(T);
                I && _(G, I);
            }
            return Reflect.set(R, G, T, H), f([
                "set",
                [
                    G
                ],
                F,
                C
            ]), !0;
        }
    });
    o.set(c, P);
    const U = [
        O,
        p,
        i,
        N
    ];
    return zn.set(P, U), Reflect.ownKeys(c).forEach((R)=>{
        const G = Object.getOwnPropertyDescriptor(c, R);
        "value" in G && (P[R] = c[R], delete G.value, delete G.writable), Object.defineProperty(O, R, G);
    }), P;
})=>[
        // public functions
        u,
        // shared state
        zn,
        ia,
        // internal things
        r,
        e,
        t,
        n,
        s,
        i,
        o,
        a
    ], [kP] = LP();
function Jn(r = {}) {
    return kP(r);
}
function zi(r, e, t) {
    const n = zn.get(r);
    (("TURBOPACK compile-time truthy", 1) ? "production" : "TURBOPACK unreachable") !== "production" && !n && console.warn("Please use proxy object");
    let s;
    const i = [], o = n[3];
    let a = !1;
    const c = o((l)=>{
        i.push(l), s || (s = Promise.resolve().then(()=>{
            s = void 0, a && e(i.splice(0));
        }));
    });
    return a = !0, ()=>{
        a = !1, c();
    };
}
function zP(r, e) {
    const t = zn.get(r);
    (("TURBOPACK compile-time truthy", 1) ? "production" : "TURBOPACK unreachable") !== "production" && !t && console.warn("Please use proxy object");
    const [n, s, i] = t;
    return i(n, s(), e);
}
const mt = Jn({
    history: [
        "ConnectWallet"
    ],
    view: "ConnectWallet",
    data: void 0
}), X1 = {
    state: mt,
    subscribe (r) {
        return zi(mt, ()=>r(mt));
    },
    push (r, e) {
        r !== mt.view && (mt.view = r, e && (mt.data = e), mt.history.push(r));
    },
    reset (r) {
        mt.view = r, mt.history = [
            r
        ];
    },
    replace (r) {
        mt.history.length > 1 && (mt.history[mt.history.length - 1] = r, mt.view = r);
    },
    goBack () {
        if (mt.history.length > 1) {
            mt.history.pop();
            const [r] = mt.history.slice(-1);
            mt.view = r;
        }
    },
    setData (r) {
        mt.data = r;
    }
}, $t = {
    WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
    WCM_VERSION: "WCM_VERSION",
    RECOMMENDED_WALLET_AMOUNT: 9,
    isMobile () {
        return ("TURBOPACK compile-time value", "undefined") < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
    },
    isAndroid () {
        return $t.isMobile() && navigator.userAgent.toLowerCase().includes("android");
    },
    isIos () {
        const r = navigator.userAgent.toLowerCase();
        return $t.isMobile() && (r.includes("iphone") || r.includes("ipad"));
    },
    isHttpUrl (r) {
        return r.startsWith("http://") || r.startsWith("https://");
    },
    isArray (r) {
        return Array.isArray(r) && r.length > 0;
    },
    isTelegram () {
        return ("TURBOPACK compile-time value", "undefined") < "u" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (!!window.TelegramWebviewProxy || // eslint-disable-next-line @typescript-eslint/no-explicit-any
        !!window.Telegram || // eslint-disable-next-line @typescript-eslint/no-explicit-any
        !!window.TelegramWebviewProxyProto);
    },
    formatNativeUrl (r, e, t) {
        if ($t.isHttpUrl(r)) return this.formatUniversalUrl(r, e, t);
        let n = r;
        n.includes("://") || (n = r.replaceAll("/", "").replaceAll(":", ""), n = `${n}://`), n.endsWith("/") || (n = `${n}/`), this.setWalletConnectDeepLink(n, t);
        const s = encodeURIComponent(e);
        return `${n}wc?uri=${s}`;
    },
    formatUniversalUrl (r, e, t) {
        if (!$t.isHttpUrl(r)) return this.formatNativeUrl(r, e, t);
        let n = r;
        if (n.startsWith("https://t.me")) {
            const i = ye.Buffer.from(e).toString("base64").replace(/[=]/g, "");
            n.endsWith("/") && (n = n.slice(0, -1)), this.setWalletConnectDeepLink(n, t);
            const o = new URL(n);
            return o.searchParams.set("startapp", i), o.toString();
        }
        n.endsWith("/") || (n = `${n}/`), this.setWalletConnectDeepLink(n, t);
        const s = encodeURIComponent(e);
        return `${n}wc?uri=${s}`;
    },
    async wait (r) {
        return new Promise((e)=>{
            setTimeout(e, r);
        });
    },
    openHref (r, e) {
        const t = this.isTelegram() ? "_blank" : e;
        window.open(r, t, "noreferrer noopener");
    },
    setWalletConnectDeepLink (r, e) {
        try {
            localStorage.setItem($t.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
                href: r,
                name: e
            }));
        } catch  {
            console.info("Unable to set WalletConnect deep link");
        }
    },
    setWalletConnectAndroidDeepLink (r) {
        try {
            const [e] = r.split("?");
            localStorage.setItem($t.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
                href: e,
                name: "Android"
            }));
        } catch  {
            console.info("Unable to set WalletConnect android deep link");
        }
    },
    removeWalletConnectDeepLink () {
        try {
            localStorage.removeItem($t.WALLETCONNECT_DEEPLINK_CHOICE);
        } catch  {
            console.info("Unable to remove WalletConnect deep link");
        }
    },
    setModalVersionInStorage () {
        try {
            typeof localStorage < "u" && localStorage.setItem($t.WCM_VERSION, "2.7.0");
        } catch  {
            console.info("Unable to set Web3Modal version in storage");
        }
    },
    getWalletRouterData () {
        var r;
        const e = (r = X1.state.data) == null ? void 0 : r.Wallet;
        if (!e) throw new Error('Missing "Wallet" view data');
        return e;
    }
}, PP = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https")), Pt = Jn({
    enabled: PP,
    userSessionId: "",
    events: [],
    connectedWalletId: void 0
}), UP = {
    state: Pt,
    subscribe (r) {
        return zi(Pt.events, ()=>r(zP(Pt.events[Pt.events.length - 1])));
    },
    initialize () {
        Pt.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (Pt.userSessionId = crypto.randomUUID());
    },
    setConnectedWalletId (r) {
        Pt.connectedWalletId = r;
    },
    click (r) {
        if (Pt.enabled) {
            const e = {
                type: "CLICK",
                name: r.name,
                userSessionId: Pt.userSessionId,
                timestamp: Date.now(),
                data: r
            };
            Pt.events.push(e);
        }
    },
    track (r) {
        if (Pt.enabled) {
            const e = {
                type: "TRACK",
                name: r.name,
                userSessionId: Pt.userSessionId,
                timestamp: Date.now(),
                data: r
            };
            Pt.events.push(e);
        }
    },
    view (r) {
        if (Pt.enabled) {
            const e = {
                type: "VIEW",
                name: r.name,
                userSessionId: Pt.userSessionId,
                timestamp: Date.now(),
                data: r
            };
            Pt.events.push(e);
        }
    }
}, Ur = Jn({
    chains: void 0,
    walletConnectUri: void 0,
    isAuth: !1,
    isCustomDesktop: !1,
    isCustomMobile: !1,
    isDataLoaded: !1,
    isUiLoaded: !1
}), _r = {
    state: Ur,
    subscribe (r) {
        return zi(Ur, ()=>r(Ur));
    },
    setChains (r) {
        Ur.chains = r;
    },
    setWalletConnectUri (r) {
        Ur.walletConnectUri = r;
    },
    setIsCustomDesktop (r) {
        Ur.isCustomDesktop = r;
    },
    setIsCustomMobile (r) {
        Ur.isCustomMobile = r;
    },
    setIsDataLoaded (r) {
        Ur.isDataLoaded = r;
    },
    setIsUiLoaded (r) {
        Ur.isUiLoaded = r;
    },
    setIsAuth (r) {
        Ur.isAuth = r;
    }
}, sa = Jn({
    projectId: "",
    mobileWallets: void 0,
    desktopWallets: void 0,
    walletImages: void 0,
    chains: void 0,
    enableAuthMode: !1,
    enableExplorer: !0,
    explorerExcludedWalletIds: void 0,
    explorerRecommendedWalletIds: void 0,
    termsOfServiceUrl: void 0,
    privacyPolicyUrl: void 0
}), ds = {
    state: sa,
    subscribe (r) {
        return zi(sa, ()=>r(sa));
    },
    setConfig (r) {
        var e, t;
        UP.initialize(), _r.setChains(r.chains), _r.setIsAuth(!!r.enableAuthMode), _r.setIsCustomMobile(!!((e = r.mobileWallets) != null && e.length)), _r.setIsCustomDesktop(!!((t = r.desktopWallets) != null && t.length)), $t.setModalVersionInStorage(), Object.assign(sa, r);
    }
};
var RP = Object.defineProperty, Jg = Object.getOwnPropertySymbols, $P = Object.prototype.hasOwnProperty, BP = Object.prototype.propertyIsEnumerable, e0 = (r, e, t)=>e in r ? RP(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, FP = (r, e)=>{
    for(var t in e || (e = {}))$P.call(e, t) && e0(r, t, e[t]);
    if (Jg) for (var t of Jg(e))BP.call(e, t) && e0(r, t, e[t]);
    return r;
};
const dd = "https://explorer-api.walletconnect.com", hd = "wcm", fd = "js-2.7.0";
async function oa(r, e) {
    const t = FP({
        sdkType: hd,
        sdkVersion: fd
    }, e), n = new URL(r, dd);
    return n.searchParams.append("projectId", ds.state.projectId), Object.entries(t).forEach(([i, o])=>{
        o && n.searchParams.append(i, String(o));
    }), (await fetch(n)).json();
}
const ci = {
    async getDesktopListings (r) {
        return oa("/w3m/v1/getDesktopListings", r);
    },
    async getMobileListings (r) {
        return oa("/w3m/v1/getMobileListings", r);
    },
    async getInjectedListings (r) {
        return oa("/w3m/v1/getInjectedListings", r);
    },
    async getAllListings (r) {
        return oa("/w3m/v1/getAllListings", r);
    },
    getWalletImageUrl (r) {
        return `${dd}/w3m/v1/getWalletImage/${r}?projectId=${ds.state.projectId}&sdkType=${hd}&sdkVersion=${fd}`;
    },
    getAssetImageUrl (r) {
        return `${dd}/w3m/v1/getAssetImage/${r}?projectId=${ds.state.projectId}&sdkType=${hd}&sdkVersion=${fd}`;
    }
};
var qP = Object.defineProperty, t0 = Object.getOwnPropertySymbols, QP = Object.prototype.hasOwnProperty, VP = Object.prototype.propertyIsEnumerable, r0 = (r, e, t)=>e in r ? qP(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, YP = (r, e)=>{
    for(var t in e || (e = {}))QP.call(e, t) && r0(r, t, e[t]);
    if (t0) for (var t of t0(e))VP.call(e, t) && r0(r, t, e[t]);
    return r;
};
const n0 = $t.isMobile(), Rr = Jn({
    wallets: {
        listings: [],
        total: 0,
        page: 1
    },
    search: {
        listings: [],
        total: 0,
        page: 1
    },
    recomendedWallets: []
}), g$ = {
    state: Rr,
    async getRecomendedWallets () {
        const { explorerRecommendedWalletIds: r, explorerExcludedWalletIds: e } = ds.state;
        if (r === "NONE" || e === "ALL" && !r) return Rr.recomendedWallets;
        if ($t.isArray(r)) {
            const n = {
                recommendedIds: r.join(",")
            }, { listings: s } = await ci.getAllListings(n), i = Object.values(s);
            i.sort((o, a)=>{
                const u = r.indexOf(o.id), c = r.indexOf(a.id);
                return u - c;
            }), Rr.recomendedWallets = i;
        } else {
            const { chains: t, isAuth: n } = _r.state, s = t == null ? void 0 : t.join(","), i = $t.isArray(e), o = {
                page: 1,
                sdks: n ? "auth_v1" : void 0,
                entries: $t.RECOMMENDED_WALLET_AMOUNT,
                chains: s,
                version: 2,
                excludedIds: i ? e.join(",") : void 0
            }, { listings: a } = n0 ? await ci.getMobileListings(o) : await ci.getDesktopListings(o);
            Rr.recomendedWallets = Object.values(a);
        }
        return Rr.recomendedWallets;
    },
    async getWallets (r) {
        const e = YP({}, r), { explorerRecommendedWalletIds: t, explorerExcludedWalletIds: n } = ds.state, { recomendedWallets: s } = Rr;
        if (n === "ALL") return Rr.wallets;
        s.length ? e.excludedIds = s.map((d)=>d.id).join(",") : $t.isArray(t) && (e.excludedIds = t.join(",")), $t.isArray(n) && (e.excludedIds = [
            e.excludedIds,
            n
        ].filter(Boolean).join(",")), _r.state.isAuth && (e.sdks = "auth_v1");
        const { page: i, search: o } = r, { listings: a, total: u } = n0 ? await ci.getMobileListings(e) : await ci.getDesktopListings(e), c = Object.values(a), l = o ? "search" : "wallets";
        return Rr[l] = {
            listings: [
                ...Rr[l].listings,
                ...c
            ],
            total: u,
            page: i ?? 1
        }, {
            listings: c,
            total: u
        };
    },
    getWalletImageUrl (r) {
        return ci.getWalletImageUrl(r);
    },
    getAssetImageUrl (r) {
        return ci.getAssetImageUrl(r);
    },
    resetSearch () {
        Rr.search = {
            listings: [],
            total: 0,
            page: 1
        };
    }
}, Gi = Jn({
    open: !1
}), ol = {
    state: Gi,
    subscribe (r) {
        return zi(Gi, ()=>r(Gi));
    },
    async open (r) {
        return new Promise((e)=>{
            const { isUiLoaded: t, isDataLoaded: n } = _r.state;
            if ($t.removeWalletConnectDeepLink(), _r.setWalletConnectUri(r == null ? void 0 : r.uri), _r.setChains(r == null ? void 0 : r.chains), X1.reset("ConnectWallet"), t && n) Gi.open = !0, e();
            else {
                const s = setInterval(()=>{
                    const i = _r.state;
                    i.isUiLoaded && i.isDataLoaded && (clearInterval(s), Gi.open = !0, e());
                }, 200);
            }
        });
    },
    close () {
        Gi.open = !1;
    }
};
var GP = Object.defineProperty, i0 = Object.getOwnPropertySymbols, HP = Object.prototype.hasOwnProperty, WP = Object.prototype.propertyIsEnumerable, s0 = (r, e, t)=>e in r ? GP(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, KP = (r, e)=>{
    for(var t in e || (e = {}))HP.call(e, t) && s0(r, t, e[t]);
    if (i0) for (var t of i0(e))WP.call(e, t) && s0(r, t, e[t]);
    return r;
};
function XP() {
    return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
const Vs = Jn({
    themeMode: XP() ? "dark" : "light"
}), o0 = {
    state: Vs,
    subscribe (r) {
        return zi(Vs, ()=>r(Vs));
    },
    setThemeConfig (r) {
        const { themeMode: e, themeVariables: t } = r;
        e && (Vs.themeMode = e), t && (Vs.themeVariables = KP({}, t));
    }
}, ui = Jn({
    open: !1,
    message: "",
    variant: "success"
}), y$ = {
    state: ui,
    subscribe (r) {
        return zi(ui, ()=>r(ui));
    },
    openToast (r, e) {
        ui.open = !0, ui.message = r, ui.variant = e;
    },
    closeToast () {
        ui.open = !1;
    }
};
class ZP {
    constructor(e){
        this.openModal = ol.open, this.closeModal = ol.close, this.subscribeModal = ol.subscribe, this.setTheme = o0.setThemeConfig, o0.setThemeConfig(e), ds.setConfig(e), this.initUi();
    }
    async initUi() {
        if (("TURBOPACK compile-time value", "undefined") < "u") {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/xrpl-connect@0.4.0/node_modules/xrpl-connect/index-D5SvR30J.mjs [app-ssr] (ecmascript, async loader)");
            const e = document.createElement("wcm-modal");
            document.body.insertAdjacentElement("beforeend", e), _r.setIsUiLoaded(!0);
        }
    }
}
const JP = {
    USER_DISCONNECTED: {
        code: 6e3,
        message: "User disconnected"
    }
}, On = {
    NAME: "XRPL Connect",
    DESCRIPTION: "XRPL Wallet Connection",
    DEFAULT_URL: "https://xrpl.org",
    DEFAULT_ICON: "https://xrpl.org/favicon.ico"
}, a0 = {
    URI_PREVIEW_LENGTH: 50
}, eU = {
    ADDRESS_INDEX: 2
}, aa = {
    KEY: "xrpl",
    EVENTS: [
        "chainChanged",
        "accountsChanged"
    ]
};
function tU() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
const nt = rc("[WalletConnect]");
class rU {
    constructor(e = {}){
        this.id = "walletconnect", this.name = "WalletConnect", this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB4bWxuczp4b2RtPSJodHRwOi8vd3d3LmNvcmVsLmNvbS9jb3JlbGRyYXcvb2RtLzIwMDMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQ5NyAyNDk3IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyNDk3IDI0OTc7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojMzM5NkZGO3N0cm9rZTojNjZCMUZGO3N0cm9rZS13aWR0aDozO3N0cm9rZS1taXRlcmxpbWl0OjIyLjkyNTY7fQoJLnN0MXtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8ZyBpZD0iTGF5ZXJfeDAwMjBfMSI+Cgk8ZyBpZD0iXzI4MDYwNTAxMzY4OTYiPgoJCTxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjEyNDkiIGN5PSIxMjQ5IiByPSIxMjQ3Ij48L2NpcmNsZT4KCQk8cGF0aCBjbGFzcz0ic3QxIiBkPSJNNzY0LDkzMGMyNjctMjYxLDcwMS0yNjEsOTY5LDBsMzIsMzFjMTMsMTMsMTMsMzQsMCw0N2wtMTEwLDEwN2MtNyw3LTE4LDctMjQsMGwtNDQtNDMgICAgYy0xODctMTgyLTQ4OS0xODItNjc2LDBsLTQ3LDQ2Yy03LDctMTgsNy0yNCwwbC0xMTAtMTA3Yy0xMy0xMy0xMy0zNCwwLTQ3bDM1LTM0SDc2NHogTTE5NjAsMTE1Mmw5OCw5NmMxMywxMywxMywzNCwwLDQ3ICAgIGwtNDQyLDQzMWMtMTMsMTMtMzUsMTMtNDgsMGwtMzE0LTMwNmMtMy0zLTktMy0xMiwwbC0zMTQsMzA2Yy0xMywxMy0zNSwxMy00OCwwbC00NDItNDMxYy0xMy0xMy0xMy0zNCwwLTQ3bDk4LTk2ICAgIGMxMy0xMywzNS0xMyw0OCwwbDMxNCwzMDZjMywzLDksMywxMiwwbDMxNC0zMDZjMTMtMTMsMzUtMTMsNDgsMGwzMTQsMzA2YzMsMyw5LDMsMTIsMGwzMTQtMzA2QzE5MjUsMTEzOSwxOTQ3LDExMzksMTk2MCwxMTUyICAgIEwxOTYwLDExNTJ6Ij48L3BhdGg+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==", this.url = "https://walletconnect.com", this.client = null, this.session = null, this.currentAccount = null, this.initializationPromise = null, this.pendingConnection = null, this.modal = null, this.options = e;
    }
    /**
   * WalletConnect is always available (uses QR code)
   */ async isAvailable() {
        return !0;
    }
    /**
   * Initialize WalletConnect modal
   * This provides the official WalletConnect UI with 300+ wallets and automatic deeplinks
   */ async initializeModal(e) {
        if (!this.modal) {
            nt.debug("Initializing WalletConnect modal...");
            try {
                this.modal = new ZP({
                    projectId: e,
                    // Configure which chains to show (XRPL)
                    chains: [
                        "xrpl:0",
                        "xrpl:1"
                    ],
                    // mainnet, testnet
                    // Theme configuration
                    themeMode: this.options.themeMode || "dark",
                    themeVariables: {
                        // Maximum z-index to ensure WalletConnect modal appears on top of custom modal
                        // Custom modal uses z-index: 9999, WC modal uses max possible value
                        "--wcm-z-index": "2147483647"
                    },
                    // Enable wallet explorer with 300+ wallets
                    enableExplorer: !0,
                    // Optionally promote specific wallets (if XRPL wallets are in WC registry)
                    explorerRecommendedWalletIds: void 0
                }), nt.debug("WalletConnect modal initialized successfully");
            } catch (t) {
                throw nt.error("Failed to initialize WalletConnect modal:", t), t;
            }
        }
    }
    /**
   * Pre-initialize WalletConnect by starting a connection session early
   * This generates the QR code URI before the user clicks WalletConnect
   * Based on ConnectKit's eager initialization pattern
   */ async preInitialize(e, t) {
        const n = e || this.options.projectId;
        if (!n) {
            nt.warn("Cannot pre-initialize without project ID");
            return;
        }
        if (this.pendingConnection) {
            nt.debug("Already has pending connection, skipping pre-init");
            return;
        }
        nt.debug("Pre-initializing connection session...");
        try {
            this.client || (this.initializationPromise || (this.initializationPromise = Ha.init({
                projectId: n,
                metadata: this.options.metadata || {
                    name: On.NAME,
                    description: On.DESCRIPTION,
                    url: ("TURBOPACK compile-time value", "undefined") < "u" ? window.location.origin : On.DEFAULT_URL,
                    icons: [
                        On.DEFAULT_ICON
                    ]
                }
            })), this.client = await this.initializationPromise, nt.debug("SignClient initialized"));
            const s = this.resolveNetwork(t), i = {
                [aa.KEY]: {
                    chains: [
                        s.walletConnectId || `xrpl:${s.id}`
                    ],
                    methods: [
                        "xrpl_signTransaction",
                        "xrpl_signTransactionFor",
                        "xrpl_signMessage"
                    ],
                    events: aa.EVENTS
                }
            }, { uri: o, approval: a } = await this.client.connect({
                requiredNamespaces: i
            });
            if (!o) throw new Error("Failed to generate WalletConnect URI during pre-initialization");
            this.pendingConnection = {
                uri: o,
                approval: a
            }, nt.debug("QR code URI pre-generated:", o.substring(0, a0.URI_PREVIEW_LENGTH) + "..."), this.options.onQRCode && (nt.debug("Calling onQRCode callback during pre-init"), this.options.onQRCode(o));
        } catch (s) {
            nt.error("Pre-initialization failed:", s), this.initializationPromise = null, this.pendingConnection = null;
        }
    }
    /**
   * Connect to WalletConnect
   */ async connect(e) {
        var a;
        const t = (e == null ? void 0 : e.projectId) || this.options.projectId;
        if (!t) throw ge.connectionFailed(this.name, new Error("WalletConnect project ID is required. Get one from https://cloud.walletconnect.com or https://dashboard.reown.com"));
        const n = (e == null ? void 0 : e.onQRCode) || this.options.onQRCode, s = this.options.useModal ?? !1, i = this.options.modalMode ?? "mobile-only", o = s && (i === "always" || i === "mobile-only" && tU());
        try {
            const u = this.resolveNetwork(e == null ? void 0 : e.network);
            this.client || (this.initializationPromise ? (nt.debug("Using pre-initialized SignClient"), this.client = await this.initializationPromise) : (nt.debug("Initializing SignClient"), this.client = await Ha.init({
                projectId: t,
                metadata: this.options.metadata || {
                    name: On.NAME,
                    description: On.DESCRIPTION,
                    url: ("TURBOPACK compile-time value", "undefined") < "u" ? window.location.origin : On.DEFAULT_URL,
                    icons: [
                        On.DEFAULT_ICON
                    ]
                }
            })));
            const c = {
                [aa.KEY]: {
                    chains: [
                        u.walletConnectId || `xrpl:${u.id}`
                    ],
                    methods: [
                        "xrpl_signTransaction",
                        "xrpl_signTransactionFor",
                        "xrpl_signMessage"
                    ],
                    events: aa.EVENTS
                }
            };
            let l;
            if (o) {
                nt.debug("Using WalletConnect modal for connection (mobile deeplink mode)"), await this.initializeModal(t);
                const { uri: g, approval: p } = await this.client.connect({
                    requiredNamespaces: c
                });
                g && this.modal && (this.modal.openModal({
                    uri: g
                }), nt.debug("WalletConnect modal opened with URI")), l = await p(), this.modal && (this.modal.closeModal(), nt.debug("WalletConnect modal closed"));
            } else {
                nt.debug("Using custom QR code for connection (desktop mode)");
                let g, p;
                if (this.pendingConnection) nt.debug("Using pre-generated connection"), g = this.pendingConnection.uri, p = this.pendingConnection.approval, n && (nt.debug("Calling onQRCode callback with pre-generated URI"), n(g));
                else {
                    nt.debug("No pre-generated connection, creating now");
                    const m = await this.client.connect({
                        requiredNamespaces: c
                    });
                    if (!m.uri) throw new Error("Failed to generate WalletConnect URI");
                    g = m.uri, p = m.approval, nt.debug("Generated URI:", g.substring(0, a0.URI_PREVIEW_LENGTH) + "..."), n && (nt.debug("Calling onQRCode callback"), n(g));
                }
                l = await p();
            }
            this.session = l;
            const d = ((a = this.session.namespaces.xrpl) == null ? void 0 : a.accounts) || [];
            if (d.length === 0) throw new Error("No accounts returned from WalletConnect session");
            const f = d[0].split(":")[eU.ADDRESS_INDEX];
            return this.currentAccount = {
                address: f,
                network: u
            }, this.setupEventListeners(), this.currentAccount;
        } catch (u) {
            throw this.modal && this.modal.closeModal(), ge.connectionFailed(this.name, u);
        }
    }
    /**
   * Disconnect from WalletConnect
   */ async disconnect() {
        if (!(!this.client || !this.session)) try {
            await this.client.disconnect({
                topic: this.session.topic,
                reason: JP.USER_DISCONNECTED
            }), this.cleanup();
        } catch  {
            this.cleanup();
        }
    }
    /**
   * Get current account
   */ async getAccount() {
        return this.currentAccount;
    }
    /**
   * Get current network
   */ async getNetwork() {
        if (!this.currentAccount) throw ge.notConnected();
        return this.currentAccount.network;
    }
    /**
   * Sign and optionally submit a transaction using xrpl_signTransaction method
   * @param transaction - The transaction to sign
   * @param submit - Whether to submit to the ledger (default: true)
   */ async signAndSubmit(e, t = !0) {
        if (!this.client || !this.session || !this.currentAccount) throw ge.notConnected();
        try {
            const n = {
                ...e,
                Account: e.Account || this.currentAccount.address
            }, i = (await this.client.request({
                topic: this.session.topic,
                chainId: this.currentAccount.network.walletConnectId || `xrpl:${this.currentAccount.network.id}`,
                request: {
                    method: "xrpl_signTransaction",
                    params: {
                        tx_json: n,
                        autofill: !0,
                        submit: t
                    }
                }
            })).tx_json;
            return {
                hash: i.hash || "",
                tx_blob: i.TxnSignature
            };
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("reject") ? ge.signRejected() : ge.signFailed(n);
        }
    }
    /**
   * Sign a message - NOT SUPPORTED
   * WalletConnect does not currently support message signing for XRPL
   */ async signMessage(e) {
        throw ge.unsupportedMethod("Message signing is not supported via WalletConnect. Please use Xaman, Crossmark, or GemWallet for signing messages.");
    }
    /**
   * Resolve network configuration
   */ resolveNetwork(e) {
        if (!e) return Hr.mainnet;
        if (typeof e == "string") {
            const t = Hr[e];
            if (!t) throw ge.unknown(`Unknown network: ${e}`);
            return t;
        }
        return e;
    }
    /**
   * Setup event listeners for session
   */ setupEventListeners() {
        this.client && (this.client.on("session_delete", ()=>{
            this.cleanup();
        }), this.client.on("session_expire", ()=>{
            this.cleanup();
        }));
    }
    /**
   * Cleanup adapter state
   */ cleanup() {
        this.modal && (this.modal.closeModal(), this.modal = null), this.client = null, this.session = null, this.currentAccount = null, this.initializationPromise = null, this.pendingConnection = null;
    }
    /**
   * Get deep link URI for mobile
   */ getDeepLinkURI(e) {
        return this.options.onDeepLink ? this.options.onDeepLink(e) : e;
    }
}
const nU = {}, iU = {}, Z1 = (r, e)=>{
    iU[r] = e;
}, te = (r)=>{
    class e extends Error {
        constructor(s, i, o){
            super(s || r, o);
            S(this, "cause");
            if (Object.setPrototypeOf(this, e.prototype), this.name = r, i) for(const a in i)this[a] = i[a];
            if (o && sU(o) && "cause" in o && !this.cause) {
                const a = o.cause;
                this.cause = a, "stack" in a && (this.stack = this.stack + `
CAUSE: ` + a.stack);
            }
        }
    }
    return nU[r] = e, e;
};
function sU(r) {
    return typeof r == "object";
}
te("AccountNameRequired");
te("AccountNotSupported");
te("AccountAwaitingSendPendingOperations");
te("AmountRequired");
te("BluetoothRequired");
te("BtcUnmatchedApp");
te("CantOpenDevice");
te("CashAddrNotSupported");
te("ClaimRewardsFeesWarning");
te("CurrencyNotSupported");
te("DeviceAppVerifyNotSupported");
te("DeviceGenuineSocketEarlyClose");
te("DeviceNotGenuine");
te("DeviceOnDashboardExpected");
te("DeviceOnDashboardUnexpected");
te("DeviceInOSUExpected");
te("DeviceHalted");
te("DeviceNameInvalid");
te("DeviceSocketFail");
te("DeviceSocketNoBulkStatus");
te("DeviceSocketNoBulkStatus");
te("UnresponsiveDeviceError");
const J1 = te("DisconnectedDevice"), eb = te("DisconnectedDeviceDuringOperation");
te("DeviceExtractOnboardingStateError");
te("DeviceOnboardingStatePollingError");
te("EnpointConfig");
te("EthAppPleaseEnableContractData");
te("CeloAppPleaseEnableContractData");
te("FeeEstimationFailed");
te("FirmwareNotRecognized");
te("HardResetFail");
te("InvalidXRPTag");
te("InvalidAddress");
te("InvalidNonce");
te("InvalidAddressBecauseDestinationIsAlsoSource");
te("LatestMCUInstalledError");
te("LatestFirmwareVersionRequired");
te("UnknownMCU");
te("LedgerAPIError");
te("LedgerAPIErrorWithMessage");
te("LedgerAPINotAvailable");
te("ManagerAppAlreadyInstalled");
te("ManagerAppRelyOnBTC");
te("ManagerAppDepInstallRequired");
te("ManagerAppDepUninstallRequired");
te("ManagerDeviceLocked");
te("ManagerFirmwareNotEnoughSpace");
te("ManagerNotEnoughSpace");
te("ManagerUninstallBTCDep");
te("NetworkDown");
te("NetworkError");
te("NoAddressesFound");
te("NotEnoughBalance");
te("NotEnoughBalanceFees");
te("NotEnoughBalanceSwap");
te("NotEnoughBalanceToDelegate");
te("UnstakeNotEnoughStakedBalanceLeft");
te("RestakeNotEnoughStakedBalanceLeft");
te("NotEnoughToRestake");
te("NotEnoughToUnstake");
te("NotEnoughBalanceInParentAccount");
te("NotEnoughSpendableBalance");
te("NotEnoughBalanceBecauseDestinationNotCreated");
te("NotEnoughToStake");
te("NoAccessToCamera");
te("NotEnoughGas");
te("NotEnoughGasSwap");
te("TronEmptyAccount");
te("MaybeKeepTronAccountAlive");
te("NotSupportedLegacyAddress");
te("GasLessThanEstimate");
te("PriorityFeeTooLow");
te("PriorityFeeTooHigh");
te("PriorityFeeHigherThanMaxFee");
te("MaxFeeTooLow");
te("PasswordsDontMatch");
te("PasswordIncorrect");
te("RecommendSubAccountsToEmpty");
te("RecommendUndelegation");
te("TimeoutTagged");
te("UnexpectedBootloader");
te("MCUNotGenuineToDashboard");
te("RecipientRequired");
te("UnavailableTezosOriginatedAccountReceive");
te("UnavailableTezosOriginatedAccountSend");
te("UpdateFetchFileFail");
te("UpdateIncorrectHash");
te("UpdateIncorrectSig");
te("UpdateYourApp");
te("UserRefusedDeviceNameChange");
te("UserRefusedAddress");
te("UserRefusedFirmwareUpdate");
te("UserRefusedAllowManager");
te("UserRefusedOnDevice");
te("PinNotSet");
te("ExpertModeRequired");
const pd = te("TransportOpenUserCancelled"), c0 = te("TransportInterfaceNotAvailable"), oU = te("TransportRaceCondition"), aU = te("TransportWebUSBGestureRequired");
te("TransactionHasBeenValidatedError");
te("TransportExchangeTimeoutError");
te("DeviceShouldStayInApp");
te("WebsocketConnectionError");
te("WebsocketConnectionFailed");
te("WrongDeviceForAccount");
te("WrongDeviceForAccountPayout");
te("MissingSwapPayloadParamaters");
te("WrongDeviceForAccountRefund");
te("WrongAppForCurrency");
te("ETHAddressNonEIP");
te("CantScanQRCode");
te("FeeNotLoaded");
te("FeeNotLoadedSwap");
te("FeeRequired");
te("FeeTooHigh");
te("PendingOperation");
te("SyncError");
te("PairingFailed");
te("PeerRemovedPairing");
te("GenuineCheckFailed");
te("LedgerAPI4xx");
te("LedgerAPI5xx");
te("FirmwareOrAppUpdateRequired");
te("ReplacementTransactionUnderpriced");
te("OpReturnSizeLimit");
te("DustLimit");
te("HederaInsufficientFundsForAssociation");
te("HederaRecipientTokenAssociationRequired");
te("HederaRecipientTokenAssociationUnverified");
te("LanguageNotFound");
te("NoDBPathGiven");
te("DBWrongPassword");
te("DBNotReset");
te("SequenceNumberError");
te("DisabledTransactionBroadcastError");
var u0;
(function(r) {
    r.Unknown = "Unknown", r.LocationServicesDisabled = "LocationServicesDisabled", r.LocationServicesUnauthorized = "LocationServicesUnauthorized", r.BluetoothScanStartFailed = "BluetoothScanStartFailed";
})(u0 || (u0 = {}));
class Gr extends Error {
    constructor(t, n){
        const s = "TransportError";
        super(t || s);
        S(this, "id");
        this.name = s, this.message = t, this.stack = new Error(t).stack, this.id = n;
    }
}
Z1("TransportError", (r)=>new Gr(r.message, r.id));
const ns = {
    ACCESS_CONDITION_NOT_FULFILLED: 38916,
    ALGORITHM_NOT_SUPPORTED: 38020,
    CLA_NOT_SUPPORTED: 28160,
    CODE_BLOCKED: 38976,
    CODE_NOT_INITIALIZED: 38914,
    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
    CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
    CONTRADICTION_INVALIDATION: 38928,
    CONTRADICTION_SECRET_CODE_STATUS: 38920,
    DEVICE_IN_RECOVERY_MODE: 26159,
    CUSTOM_IMAGE_EMPTY: 26158,
    FILE_ALREADY_EXISTS: 27273,
    FILE_NOT_FOUND: 37892,
    GP_AUTH_FAILED: 25344,
    HALTED: 28586,
    INCONSISTENT_FILE: 37896,
    INCORRECT_DATA: 27264,
    INCORRECT_LENGTH: 26368,
    INCORRECT_P1_P2: 27392,
    INS_NOT_SUPPORTED: 27904,
    DEVICE_NOT_ONBOARDED: 27911,
    DEVICE_NOT_ONBOARDED_2: 26129,
    INVALID_KCV: 38021,
    INVALID_OFFSET: 37890,
    LICENSING: 28482,
    LOCKED_DEVICE: 21781,
    MAX_VALUE_REACHED: 38992,
    MEMORY_PROBLEM: 37440,
    MISSING_CRITICAL_PARAMETER: 26624,
    NO_EF_SELECTED: 37888,
    NOT_ENOUGH_MEMORY_SPACE: 27268,
    OK: 36864,
    PIN_REMAINING_ATTEMPTS: 25536,
    REFERENCED_DATA_NOT_FOUND: 27272,
    SECURITY_STATUS_NOT_SATISFIED: 27010,
    TECHNICAL_PROBLEM: 28416,
    UNKNOWN_APDU: 27906,
    USER_REFUSED_ON_DEVICE: 21761,
    NOT_ENOUGH_SPACE: 20738,
    APP_NOT_FOUND_OR_INVALID_CONTEXT: 20771,
    INVALID_APP_NAME_LENGTH: 26378,
    GEN_AES_KEY_FAILED: 21529,
    INTERNAL_CRYPTO_OPERATION_FAILED: 21530,
    INTERNAL_COMPUTE_AES_CMAC_FAILED: 21531,
    ENCRYPT_APP_STORAGE_FAILED: 21532,
    INVALID_BACKUP_STATE: 26178,
    PIN_NOT_SET: 21762,
    INVALID_BACKUP_LENGTH: 26419,
    INVALID_RESTORE_STATE: 26179,
    INVALID_CHUNK_LENGTH: 26420,
    INVALID_BACKUP_HEADER: 26698,
    // Not documented:
    TRUSTCHAIN_WRONG_SEED: 45063
};
function cU(r) {
    switch(r){
        case 26368:
            return "Incorrect length";
        case 26624:
            return "Missing critical parameter";
        case 27010:
            return "Security not satisfied (dongle locked or have invalid access rights)";
        case 27013:
            return "Condition of use not satisfied (denied by the user?)";
        case 27264:
            return "Invalid data received";
        case 27392:
            return "Invalid parameter received";
        case 21781:
            return "Locked device";
    }
    if (28416 <= r && r <= 28671) return "Internal error, please report";
}
class hs extends Error {
    /**
   * @param statusCode The error status code coming from a Transport implementation
   * @param options containing:
   *  - canBeMappedToChildError: enable the mapping of TransportStatusError to an error extending/inheriting from it
   *  . Ex: LockedDeviceError. Default to true.
   */ constructor(t, { canBeMappedToChildError: n = !0 } = {}){
        const s = Object.keys(ns).find((u)=>ns[u] === t) || "UNKNOWN_ERROR", i = cU(t) || s, o = t.toString(16), a = `Ledger device: ${i} (0x${o})`;
        super(a);
        S(this, "statusCode");
        S(this, "statusText");
        if (this.name = "TransportStatusError", this.statusCode = t, this.statusText = s, Object.setPrototypeOf(this, hs.prototype), n && t === ns.LOCKED_DEVICE) return new gh(a);
    }
}
class gh extends hs {
    constructor(e){
        super(ns.LOCKED_DEVICE, {
            canBeMappedToChildError: !1
        }), e && (this.message = e), this.name = "LockedDeviceError", Object.setPrototypeOf(this, gh.prototype);
    }
}
Z1("TransportStatusError", (r)=>new hs(r.statusCode));
let tb = 0;
const Pn = [], Ka = (r, e, t)=>{
    const n = {
        type: r,
        id: String(++tb),
        date: /* @__PURE__ */ new Date()
    };
    e && (n.message = e), rb(n);
}, uU = ({ type: r, message: e, data: t, context: n })=>{
    const s = {
        type: r,
        id: String(++tb),
        date: /* @__PURE__ */ new Date()
    };
    e && (s.message = e), t && (s.data = t), n && (s.context = n), rb(s);
};
class io {
    constructor(e, t){
        S(this, "type");
        S(this, "context");
        this.type = e, this.context = t;
    }
    trace(e, t) {
        uU({
            type: this.type,
            message: e,
            data: t,
            context: this.context
        });
    }
    getContext() {
        return this.context;
    }
    setContext(e) {
        this.context = e;
    }
    updateContext(e) {
        this.context = {
            ...this.context,
            ...e
        };
    }
    getType() {
        return this.type;
    }
    setType(e) {
        this.type = e;
    }
    /**
   * Create a new instance of the LocalTracer with an updated `type`
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   */ withType(e) {
        return new io(e, this.context);
    }
    /**
   * Create a new instance of the LocalTracer with a new `context`
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   *
   * @param context A TraceContext, that can undefined to reset the context
   */ withContext(e) {
        return new io(this.type, e);
    }
    /**
   * Create a new instance of the LocalTracer with an updated `context`,
   * on which an additional context is merged with the existing one.
   *
   * It does not mutate the calling instance, but returns a new LocalTracer,
   * following a simple builder pattern.
   */ withUpdatedContext(e) {
        return new io(this.type, {
            ...this.context,
            ...e
        });
    }
}
const lU = (r)=>(Pn.push(r), ()=>{
        const e = Pn.indexOf(r);
        e !== -1 && (Pn[e] = Pn[Pn.length - 1], Pn.pop());
    });
function rb(r) {
    for(let e = 0; e < Pn.length; e++)try {
        Pn[e](r);
    } catch (t) {
        console.error(t);
    }
}
("TURBOPACK compile-time value", "undefined") < "u" && (window.__ledgerLogsListen = lU);
const dU = "transport";
class Un {
    constructor({ context: e, logType: t } = {}){
        S(this, "exchangeTimeout", 3e4);
        S(this, "unresponsiveTimeout", 15e3);
        S(this, "deviceModel", null);
        S(this, "tracer");
        S(this, "_events", new Md());
        /**
     * Send data to the device using the higher level API.
     *
     * @param {number} cla - The instruction class for the command.
     * @param {number} ins - The instruction code for the command.
     * @param {number} p1 - The first parameter for the instruction.
     * @param {number} p2 - The second parameter for the instruction.
     * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.
     * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].
     * @param {Object} options - Contains optional options for the exchange function
     *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists
     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
     */ S(this, "send", async (e, t, n, s, i = ye.Buffer.alloc(0), o = [
            ns.OK
        ], { abortTimeoutMs: a } = {})=>{
            const u = this.tracer.withUpdatedContext({
                function: "send"
            });
            if (i.length >= 256) throw u.trace("data.length exceeded 256 bytes limit", {
                dataLength: i.length
            }), new Gr("data.length exceed 256 bytes limit. Got: " + i.length, "DataLengthTooBig");
            u.trace("Starting an exchange", {
                abortTimeoutMs: a
            });
            const c = await this.exchange(// The size of the data is added in 1 byte just before `data`
            ye.Buffer.concat([
                ye.Buffer.from([
                    e,
                    t,
                    n,
                    s
                ]),
                ye.Buffer.from([
                    i.length
                ]),
                i
            ]), {
                abortTimeoutMs: a
            });
            u.trace("Received response from exchange");
            const l = c.readUInt16BE(c.length - 2);
            if (!o.some((d)=>d === l)) throw new hs(l);
            return c;
        });
        // Blocks other exchange to happen concurrently
        S(this, "exchangeBusyPromise");
        S(this, "_appAPIlock", null);
        this.tracer = new io(t ?? dU, e);
    }
    /**
   * Send data to the device using a low level API.
   * It's recommended to use the "send" method for a higher level API.
   * @param {Buffer} apdu - The data to send.
   * @param {Object} options - Contains optional options for the exchange function
   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists
   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.
   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
   */ exchange(e, { abortTimeoutMs: t } = {}) {
        throw new Error("exchange not implemented");
    }
    /**
   * Send apdus in batch to the device using a low level API.
   * The default implementation is to call exchange for each apdu.
   * @param {Array<Buffer>} apdus - array of apdus to send.
   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.
   * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop sending apdus.
   */ exchangeBulk(e, t) {
        let n = !1;
        const s = ()=>{
            n = !0;
        };
        return (async ()=>{
            if (!n) for (const o of e){
                const a = await this.exchange(o);
                if (n) return;
                const u = a.readUInt16BE(a.length - 2);
                if (u !== ns.OK) throw new hs(u);
                t.next(a);
            }
        })().then(()=>!n && t.complete(), (o)=>!n && t.error(o)), {
            unsubscribe: s
        };
    }
    /**
   * Set the "scramble key" for the next data exchanges with the device.
   * Each app can have a different scramble key and it is set internally during instantiation.
   * @param {string} key - The scramble key to set.
   * deprecated This method is no longer needed for modern transports and should be migrated away from.
   * no @ before deprecated as it breaks documentationjs on version 14.0.2
   * https://github.com/documentationjs/documentation/issues/1596
   */ setScrambleKey(e) {}
    /**
   * Close the connection with the device.
   *
   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,
   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.
   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.
   *
   * @returns {Promise<void>} A promise that resolves when the transport is closed.
   */ close() {
        return Promise.resolve();
    }
    /**
   * Listen for an event on the transport instance.
   * Transport implementations may have specific events. Common events include:
   * "disconnect" : triggered when the transport is disconnected.
   * @param {string} eventName - The name of the event to listen for.
   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.
   */ on(e, t) {
        this._events.on(e, t);
    }
    /**
   * Stop listening to an event on an instance of transport.
   */ off(e, t) {
        this._events.removeListener(e, t);
    }
    emit(e, ...t) {
        this._events.emit(e, ...t);
    }
    /**
   * Enable or not logs of the binary exchange
   */ setDebugMode() {
        console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
    }
    /**
   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
   */ setExchangeTimeout(e) {
        this.exchangeTimeout = e;
    }
    /**
   * Define the delay before emitting "unresponsive" on an exchange that does not respond
   */ setExchangeUnresponsiveTimeout(e) {
        this.unresponsiveTimeout = e;
    }
    /**
   * create() allows to open the first descriptor available or
   * throw if there is none or if timeout is reached.
   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
   * @example
  TransportFoo.create().then(transport => ...)
   */ static create(e = 3e3, t) {
        return new Promise((n, s)=>{
            let i = !1;
            const o = this.listen({
                next: (u)=>{
                    i = !0, o && o.unsubscribe(), a && clearTimeout(a), this.open(u.descriptor, e).then(n, s);
                },
                error: (u)=>{
                    a && clearTimeout(a), s(u);
                },
                complete: ()=>{
                    a && clearTimeout(a), i || s(new Gr(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
                }
            }), a = t ? setTimeout(()=>{
                o.unsubscribe(), s(new Gr(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
            }, t) : null;
        });
    }
    /**
   * Wrapper to make an exchange "atomic" (blocking any other exchange)
   *
   * It also handles "unresponsiveness" by emitting "unresponsive" and "responsive" events.
   *
   * @param f The exchange job, using the transport to run
   * @returns a Promise resolving with the output of the given job
   */ async exchangeAtomicImpl(e) {
        const t = this.tracer.withUpdatedContext({
            function: "exchangeAtomicImpl",
            unresponsiveTimeout: this.unresponsiveTimeout
        });
        if (this.exchangeBusyPromise) throw t.trace("Atomic exchange is already busy"), new oU("An action was already pending on the Ledger device. Please deny or reconnect.");
        let n;
        const s = new Promise((a)=>{
            n = a;
        });
        this.exchangeBusyPromise = s;
        let i = !1;
        const o = setTimeout(()=>{
            t.trace('Timeout reached, emitting Transport event "unresponsive"', {
                unresponsiveTimeout: this.unresponsiveTimeout
            }), i = !0, this.emit("unresponsive");
        }, this.unresponsiveTimeout);
        try {
            const a = await e();
            return i && (t.trace("Device was unresponsive, emitting responsive"), this.emit("responsive")), a;
        } finally{
            t.trace("Finalize, clearing busy guard"), clearTimeout(o), n && n(), this.exchangeBusyPromise = null;
        }
    }
    decorateAppAPIMethods(e, t, n) {
        for (const s of t)e[s] = this.decorateAppAPIMethod(s, e[s], e, n);
    }
    decorateAppAPIMethod(e, t, n, s) {
        return async (...i)=>{
            const { _appAPIlock: o } = this;
            if (o) return Promise.reject(new Gr("Ledger Device is busy (lock " + o + ")", "TransportLocked"));
            try {
                return this._appAPIlock = e, this.setScrambleKey(s), await t.apply(n, i);
            } finally{
                this._appAPIlock = null;
            }
        };
    }
    /**
   * Sets the context used by the logging/tracing mechanism
   *
   * Useful when re-using (cached) the same Transport instance,
   * but with a new tracing context.
   *
   * @param context A TraceContext, that can undefined to reset the context
   */ setTraceContext(e) {
        this.tracer = this.tracer.withContext(e);
    }
    /**
   * Updates the context used by the logging/tracing mechanism
   *
   * The update only overrides the key-value that are already defined in the current context.
   *
   * @param contextToAdd A TraceContext that will be added to the current context
   */ updateTraceContext(e) {
        this.tracer.updateContext(e);
    }
    /**
   * Gets the tracing context of the transport instance
   */ getTraceContext() {
        return this.tracer.getContext();
    }
}
/**
 * Check if the transport is supported on the current platform/browser.
 * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.
 */ S(Un, "isSupported"), /**
 * List all available descriptors for the transport.
 * For a better granularity, checkout `listen()`.
 *
 * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.
 * @example
 * TransportFoo.list().then(descriptors => ...)
 */ S(Un, "list"), /**
 * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.
 * A DescriptorEvent is an object containing a "descriptor" and a "type" field. The "type" field can be "add" or "remove", and the "descriptor" field can be passed to the "open" method.
 * The "listen" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.
 * @param {Observer<DescriptorEvent<any>>} observer - An object with "next", "error", and "complete" functions, following the observer pattern.
 * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop listening to descriptors.
 * @example
const sub = TransportFoo.listen({
next: e => {
  if (e.type==="add") {
    sub.unsubscribe();
    const transport = await TransportFoo.open(e.descriptor);
    ...
  }
},
error: error => {},
complete: () => {}
})
 */ S(Un, "listen"), /**
 * Attempt to create a Transport instance with a specific descriptor.
 * @param {any} descriptor - The descriptor to open the transport with.
 * @param {number} timeout - An optional timeout for the transport connection.
 * @param {TraceContext} context Optional tracing/log context
 * @returns {Promise<Transport>} A promise that resolves with a Transport instance.
 * @example
TransportFoo.open(descriptor).then(transport => ...)
 */ S(Un, "open"), S(Un, "ErrorMessage_ListenTimeout", "No Ledger device found (timeout)"), S(Un, "ErrorMessage_NoDeviceFound", "No Ledger device found");
const l0 = 5;
function hU(r) {
    const e = ye.Buffer.alloc(2);
    return e.writeUInt16BE(r, 0), e;
}
const fU = {
    data: ye.Buffer.alloc(0),
    dataLength: 0,
    sequence: 0
}, nb = (r, e)=>({
        /**
   * Frames/encodes an APDU message into HID USB packets/frames
   *
   * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]
   * @returns an array of HID USB frames ready to be sent
   */ makeBlocks (t) {
            let n = ye.Buffer.concat([
                hU(t.length),
                t
            ]);
            const s = e - 5, i = Math.ceil(n.length / s);
            n = ye.Buffer.concat([
                n,
                ye.Buffer.alloc(i * s - n.length + 1).fill(0)
            ]);
            const o = [];
            for(let a = 0; a < i; a++){
                const u = ye.Buffer.alloc(5);
                u.writeUInt16BE(r, 0), u.writeUInt8(l0, 2), u.writeUInt16BE(a, 3);
                const c = n.slice(a * s, (a + 1) * s);
                o.push(ye.Buffer.concat([
                    u,
                    c
                ]));
            }
            return o;
        },
        /**
   * Reduces HID USB packets/frames to one response.
   *
   * @param acc The value resulting from (accumulating) the previous call of reduceResponse.
   *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.
   * @param chunk Current chunk to reduce into accumulator
   * @returns An accumulator value updated with the current chunk
   */ reduceResponse (t, n) {
            let { data: s, dataLength: i, sequence: o } = t || fU;
            if (n.readUInt16BE(0) !== r) throw new Gr("Invalid channel", "InvalidChannel");
            if (n.readUInt8(2) !== l0) throw new Gr("Invalid tag", "InvalidTag");
            if (n.readUInt16BE(3) !== o) throw new Gr("Invalid sequence", "InvalidSequence");
            t || (i = n.readUInt16BE(5)), o++;
            const a = n.slice(t ? 5 : 7);
            return s = ye.Buffer.concat([
                s,
                a
            ]), s.length > i && (s = s.slice(0, i)), {
                data: s,
                dataLength: i,
                sequence: o
            };
        },
        /**
   * Returns the response message that has been reduced from the HID USB frames
   *
   * @param acc The accumulator
   * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the
   *   accumulator is incorrect (message length is not valid)
   */ getReducedResult (t) {
            if (t && t.dataLength === t.data.length) return t.data;
        }
    });
var gd = {
    exports: {}
};
const pU = "2.0.0", ib = 256, gU = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991, yU = 16, wU = ib - 6, mU = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
];
var Kc = {
    MAX_LENGTH: ib,
    MAX_SAFE_COMPONENT_LENGTH: yU,
    MAX_SAFE_BUILD_LENGTH: wU,
    MAX_SAFE_INTEGER: gU,
    RELEASE_TYPES: mU,
    SEMVER_SPEC_VERSION: pU,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
};
const bU = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...r)=>console.error("SEMVER", ...r) : ()=>{};
var Xc = bU;
(function(r, e) {
    const { MAX_SAFE_COMPONENT_LENGTH: t, MAX_SAFE_BUILD_LENGTH: n, MAX_LENGTH: s } = Kc, i = Xc;
    e = r.exports = {};
    const o = e.re = [], a = e.safeRe = [], u = e.src = [], c = e.safeSrc = [], l = e.t = {};
    let d = 0;
    const h = "[a-zA-Z0-9-]", f = [
        [
            "\\s",
            1
        ],
        [
            "\\d",
            s
        ],
        [
            h,
            n
        ]
    ], g = (m)=>{
        for (const [x, _] of f)m = m.split(`${x}*`).join(`${x}{0,${_}}`).split(`${x}+`).join(`${x}{1,${_}}`);
        return m;
    }, p = (m, x, _)=>{
        const v = g(x), N = d++;
        i(m, N, x), l[m] = N, u[N] = x, c[N] = v, o[N] = new RegExp(x, _ ? "g" : void 0), a[N] = new RegExp(v, _ ? "g" : void 0);
    };
    p("NUMERICIDENTIFIER", "0|[1-9]\\d*"), p("NUMERICIDENTIFIERLOOSE", "\\d+"), p("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${h}*`), p("MAINVERSION", `(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})`), p("MAINVERSIONLOOSE", `(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})`), p("PRERELEASEIDENTIFIER", `(?:${u[l.NONNUMERICIDENTIFIER]}|${u[l.NUMERICIDENTIFIER]})`), p("PRERELEASEIDENTIFIERLOOSE", `(?:${u[l.NONNUMERICIDENTIFIER]}|${u[l.NUMERICIDENTIFIERLOOSE]})`), p("PRERELEASE", `(?:-(${u[l.PRERELEASEIDENTIFIER]}(?:\\.${u[l.PRERELEASEIDENTIFIER]})*))`), p("PRERELEASELOOSE", `(?:-?(${u[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${u[l.PRERELEASEIDENTIFIERLOOSE]})*))`), p("BUILDIDENTIFIER", `${h}+`), p("BUILD", `(?:\\+(${u[l.BUILDIDENTIFIER]}(?:\\.${u[l.BUILDIDENTIFIER]})*))`), p("FULLPLAIN", `v?${u[l.MAINVERSION]}${u[l.PRERELEASE]}?${u[l.BUILD]}?`), p("FULL", `^${u[l.FULLPLAIN]}$`), p("LOOSEPLAIN", `[v=\\s]*${u[l.MAINVERSIONLOOSE]}${u[l.PRERELEASELOOSE]}?${u[l.BUILD]}?`), p("LOOSE", `^${u[l.LOOSEPLAIN]}$`), p("GTLT", "((?:<|>)?=?)"), p("XRANGEIDENTIFIERLOOSE", `${u[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), p("XRANGEIDENTIFIER", `${u[l.NUMERICIDENTIFIER]}|x|X|\\*`), p("XRANGEPLAIN", `[v=\\s]*(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:${u[l.PRERELEASE]})?${u[l.BUILD]}?)?)?`), p("XRANGEPLAINLOOSE", `[v=\\s]*(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:${u[l.PRERELEASELOOSE]})?${u[l.BUILD]}?)?)?`), p("XRANGE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAIN]}$`), p("XRANGELOOSE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAINLOOSE]}$`), p("COERCEPLAIN", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?`), p("COERCE", `${u[l.COERCEPLAIN]}(?:$|[^\\d])`), p("COERCEFULL", u[l.COERCEPLAIN] + `(?:${u[l.PRERELEASE]})?(?:${u[l.BUILD]})?(?:$|[^\\d])`), p("COERCERTL", u[l.COERCE], !0), p("COERCERTLFULL", u[l.COERCEFULL], !0), p("LONETILDE", "(?:~>?)"), p("TILDETRIM", `(\\s*)${u[l.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", p("TILDE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAIN]}$`), p("TILDELOOSE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAINLOOSE]}$`), p("LONECARET", "(?:\\^)"), p("CARETTRIM", `(\\s*)${u[l.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", p("CARET", `^${u[l.LONECARET]}${u[l.XRANGEPLAIN]}$`), p("CARETLOOSE", `^${u[l.LONECARET]}${u[l.XRANGEPLAINLOOSE]}$`), p("COMPARATORLOOSE", `^${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]})$|^$`), p("COMPARATOR", `^${u[l.GTLT]}\\s*(${u[l.FULLPLAIN]})$|^$`), p("COMPARATORTRIM", `(\\s*)${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]}|${u[l.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", p("HYPHENRANGE", `^\\s*(${u[l.XRANGEPLAIN]})\\s+-\\s+(${u[l.XRANGEPLAIN]})\\s*$`), p("HYPHENRANGELOOSE", `^\\s*(${u[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${u[l.XRANGEPLAINLOOSE]})\\s*$`), p("STAR", "(<|>)?=?\\s*\\*"), p("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), p("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(gd, gd.exports);
var _o = gd.exports;
const vU = Object.freeze({
    loose: !0
}), EU = Object.freeze({}), MU = (r)=>r ? typeof r != "object" ? vU : r : EU;
var yh = MU;
const d0 = /^[0-9]+$/, sb = (r, e)=>{
    if (typeof r == "number" && typeof e == "number") return r === e ? 0 : r < e ? -1 : 1;
    const t = d0.test(r), n = d0.test(e);
    return t && n && (r = +r, e = +e), r === e ? 0 : t && !n ? -1 : n && !t ? 1 : r < e ? -1 : 1;
}, NU = (r, e)=>sb(e, r);
var ob = {
    compareIdentifiers: sb,
    rcompareIdentifiers: NU
};
const ca = Xc, { MAX_LENGTH: h0, MAX_SAFE_INTEGER: ua } = Kc, { safeRe: la, t: da } = _o, xU = yh, { compareIdentifiers: al } = ob;
let IU = class Fr {
    constructor(e, t){
        if (t = xU(t), e instanceof Fr) {
            if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease) return e;
            e = e.version;
        } else if (typeof e != "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
        if (e.length > h0) throw new TypeError(`version is longer than ${h0} characters`);
        ca("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease;
        const n = e.trim().match(t.loose ? la[da.LOOSE] : la[da.FULL]);
        if (!n) throw new TypeError(`Invalid Version: ${e}`);
        if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > ua || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > ua || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > ua || this.patch < 0) throw new TypeError("Invalid patch version");
        n[4] ? this.prerelease = n[4].split(".").map((s)=>{
            if (/^[0-9]+$/.test(s)) {
                const i = +s;
                if (i >= 0 && i < ua) return i;
            }
            return s;
        }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
    }
    format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
        return this.version;
    }
    compare(e) {
        if (ca("SemVer.compare", this.version, this.options, e), !(e instanceof Fr)) {
            if (typeof e == "string" && e === this.version) return 0;
            e = new Fr(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
    }
    compareMain(e) {
        return e instanceof Fr || (e = new Fr(e, this.options)), this.major < e.major ? -1 : this.major > e.major ? 1 : this.minor < e.minor ? -1 : this.minor > e.minor ? 1 : this.patch < e.patch ? -1 : this.patch > e.patch ? 1 : 0;
    }
    comparePre(e) {
        if (e instanceof Fr || (e = new Fr(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t = 0;
        do {
            const n = this.prerelease[t], s = e.prerelease[t];
            if (ca("prerelease compare", t, n, s), n === void 0 && s === void 0) return 0;
            if (s === void 0) return 1;
            if (n === void 0) return -1;
            if (n === s) continue;
            return al(n, s);
        }while (++t)
    }
    compareBuild(e) {
        e instanceof Fr || (e = new Fr(e, this.options));
        let t = 0;
        do {
            const n = this.build[t], s = e.build[t];
            if (ca("build compare", t, n, s), n === void 0 && s === void 0) return 0;
            if (s === void 0) return 1;
            if (n === void 0) return -1;
            if (n === s) continue;
            return al(n, s);
        }while (++t)
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(e, t, n) {
        if (e.startsWith("pre")) {
            if (!t && n === !1) throw new Error("invalid increment argument: identifier is empty");
            if (t) {
                const s = `-${t}`.match(this.options.loose ? la[da.PRERELEASELOOSE] : la[da.PRERELEASE]);
                if (!s || s[1] !== t) throw new Error(`invalid identifier: ${t}`);
            }
        }
        switch(e){
            case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t, n);
                break;
            case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t, n);
                break;
            case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t, n), this.inc("pre", t, n);
                break;
            case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", t, n), this.inc("pre", t, n);
                break;
            case "release":
                if (this.prerelease.length === 0) throw new Error(`version ${this.raw} is not a prerelease`);
                this.prerelease.length = 0;
                break;
            case "major":
                (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case "minor":
                (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
            case "pre":
                {
                    const s = Number(n) ? 1 : 0;
                    if (this.prerelease.length === 0) this.prerelease = [
                        s
                    ];
                    else {
                        let i = this.prerelease.length;
                        for(; --i >= 0;)typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
                        if (i === -1) {
                            if (t === this.prerelease.join(".") && n === !1) throw new Error("invalid increment argument: identifier already exists");
                            this.prerelease.push(s);
                        }
                    }
                    if (t) {
                        let i = [
                            t,
                            s
                        ];
                        n === !1 && (i = [
                            t
                        ]), al(this.prerelease[0], t) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = i) : this.prerelease = i;
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${e}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
};
var Qt = IU;
const f0 = Qt, TU = (r, e, t = !1)=>{
    if (r instanceof f0) return r;
    try {
        return new f0(r, e);
    } catch (n) {
        if (!t) return null;
        throw n;
    }
};
var ms = TU;
const DU = ms, _U = (r, e)=>{
    const t = DU(r, e);
    return t ? t.version : null;
};
var AU = _U;
const SU = ms, OU = (r, e)=>{
    const t = SU(r.trim().replace(/^[=v]+/, ""), e);
    return t ? t.version : null;
};
var jU = OU;
const p0 = Qt, CU = (r, e, t, n, s)=>{
    typeof t == "string" && (s = n, n = t, t = void 0);
    try {
        return new p0(r instanceof p0 ? r.version : r, t).inc(e, n, s).version;
    } catch  {
        return null;
    }
};
var LU = CU;
const g0 = ms, kU = (r, e)=>{
    const t = g0(r, null, !0), n = g0(e, null, !0), s = t.compare(n);
    if (s === 0) return null;
    const i = s > 0, o = i ? t : n, a = i ? n : t, u = !!o.prerelease.length;
    if (!!a.prerelease.length && !u) {
        if (!a.patch && !a.minor) return "major";
        if (a.compareMain(o) === 0) return a.minor && !a.patch ? "minor" : "patch";
    }
    const l = u ? "pre" : "";
    return t.major !== n.major ? l + "major" : t.minor !== n.minor ? l + "minor" : t.patch !== n.patch ? l + "patch" : "prerelease";
};
var zU = kU;
const PU = Qt, UU = (r, e)=>new PU(r, e).major;
var RU = UU;
const $U = Qt, BU = (r, e)=>new $U(r, e).minor;
var FU = BU;
const qU = Qt, QU = (r, e)=>new qU(r, e).patch;
var VU = QU;
const YU = ms, GU = (r, e)=>{
    const t = YU(r, e);
    return t && t.prerelease.length ? t.prerelease : null;
};
var HU = GU;
const y0 = Qt, WU = (r, e, t)=>new y0(r, t).compare(new y0(e, t));
var Or = WU;
const KU = Or, XU = (r, e, t)=>KU(e, r, t);
var ZU = XU;
const JU = Or, e6 = (r, e)=>JU(r, e, !0);
var t6 = e6;
const w0 = Qt, r6 = (r, e, t)=>{
    const n = new w0(r, t), s = new w0(e, t);
    return n.compare(s) || n.compareBuild(s);
};
var wh = r6;
const n6 = wh, i6 = (r, e)=>r.sort((t, n)=>n6(t, n, e));
var s6 = i6;
const o6 = wh, a6 = (r, e)=>r.sort((t, n)=>o6(n, t, e));
var c6 = a6;
const u6 = Or, l6 = (r, e, t)=>u6(r, e, t) > 0;
var Zc = l6;
const d6 = Or, h6 = (r, e, t)=>d6(r, e, t) < 0;
var mh = h6;
const f6 = Or, p6 = (r, e, t)=>f6(r, e, t) === 0;
var ab = p6;
const g6 = Or, y6 = (r, e, t)=>g6(r, e, t) !== 0;
var cb = y6;
const w6 = Or, m6 = (r, e, t)=>w6(r, e, t) >= 0;
var bh = m6;
const b6 = Or, v6 = (r, e, t)=>b6(r, e, t) <= 0;
var vh = v6;
const E6 = ab, M6 = cb, N6 = Zc, x6 = bh, I6 = mh, T6 = vh, D6 = (r, e, t, n)=>{
    switch(e){
        case "===":
            return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r === t;
        case "!==":
            return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r !== t;
        case "":
        case "=":
        case "==":
            return E6(r, t, n);
        case "!=":
            return M6(r, t, n);
        case ">":
            return N6(r, t, n);
        case ">=":
            return x6(r, t, n);
        case "<":
            return I6(r, t, n);
        case "<=":
            return T6(r, t, n);
        default:
            throw new TypeError(`Invalid operator: ${e}`);
    }
};
var ub = D6;
const _6 = Qt, A6 = ms, { safeRe: ha, t: fa } = _o, S6 = (r, e)=>{
    if (r instanceof _6) return r;
    if (typeof r == "number" && (r = String(r)), typeof r != "string") return null;
    e = e || {};
    let t = null;
    if (!e.rtl) t = r.match(e.includePrerelease ? ha[fa.COERCEFULL] : ha[fa.COERCE]);
    else {
        const u = e.includePrerelease ? ha[fa.COERCERTLFULL] : ha[fa.COERCERTL];
        let c;
        for(; (c = u.exec(r)) && (!t || t.index + t[0].length !== r.length);)(!t || c.index + c[0].length !== t.index + t[0].length) && (t = c), u.lastIndex = c.index + c[1].length + c[2].length;
        u.lastIndex = -1;
    }
    if (t === null) return null;
    const n = t[2], s = t[3] || "0", i = t[4] || "0", o = e.includePrerelease && t[5] ? `-${t[5]}` : "", a = e.includePrerelease && t[6] ? `+${t[6]}` : "";
    return A6(`${n}.${s}.${i}${o}${a}`, e);
};
var O6 = S6;
class j6 {
    constructor(){
        this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(e) {
        const t = this.map.get(e);
        if (t !== void 0) return this.map.delete(e), this.map.set(e, t), t;
    }
    delete(e) {
        return this.map.delete(e);
    }
    set(e, t) {
        if (!this.delete(e) && t !== void 0) {
            if (this.map.size >= this.max) {
                const s = this.map.keys().next().value;
                this.delete(s);
            }
            this.map.set(e, t);
        }
        return this;
    }
}
var C6 = j6, cl, m0;
function jr() {
    if (m0) return cl;
    m0 = 1;
    const r = /\s+/g;
    class e {
        constructor(T, I){
            if (I = s(I), T instanceof e) return T.loose === !!I.loose && T.includePrerelease === !!I.includePrerelease ? T : new e(T.raw, I);
            if (T instanceof i) return this.raw = T.value, this.set = [
                [
                    T
                ]
            ], this.formatted = void 0, this;
            if (this.options = I, this.loose = !!I.loose, this.includePrerelease = !!I.includePrerelease, this.raw = T.trim().replace(r, " "), this.set = this.raw.split("||").map((y)=>this.parseRange(y.trim())).filter((y)=>y.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
                const y = this.set[0];
                if (this.set = this.set.filter((w)=>!p(w[0])), this.set.length === 0) this.set = [
                    y
                ];
                else if (this.set.length > 1) {
                    for (const w of this.set)if (w.length === 1 && m(w[0])) {
                        this.set = [
                            w
                        ];
                        break;
                    }
                }
            }
            this.formatted = void 0;
        }
        get range() {
            if (this.formatted === void 0) {
                this.formatted = "";
                for(let T = 0; T < this.set.length; T++){
                    T > 0 && (this.formatted += "||");
                    const I = this.set[T];
                    for(let y = 0; y < I.length; y++)y > 0 && (this.formatted += " "), this.formatted += I[y].toString().trim();
                }
            }
            return this.formatted;
        }
        format() {
            return this.range;
        }
        toString() {
            return this.range;
        }
        parseRange(T) {
            const y = ((this.options.includePrerelease && f) | (this.options.loose && g)) + ":" + T, w = n.get(y);
            if (w) return w;
            const M = this.options.loose, D = M ? u[c.HYPHENRANGELOOSE] : u[c.HYPHENRANGE];
            T = T.replace(D, H(this.options.includePrerelease)), o("hyphen replace", T), T = T.replace(u[c.COMPARATORTRIM], l), o("comparator trim", T), T = T.replace(u[c.TILDETRIM], d), o("tilde trim", T), T = T.replace(u[c.CARETTRIM], h), o("caret trim", T);
            let A = T.split(" ").map((K)=>_(K, this.options)).join(" ").split(/\s+/).map((K)=>F(K, this.options));
            M && (A = A.filter((K)=>(o("loose invalid filter", K, this.options), !!K.match(u[c.COMPARATORLOOSE])))), o("range list", A);
            const L = /* @__PURE__ */ new Map(), V = A.map((K)=>new i(K, this.options));
            for (const K of V){
                if (p(K)) return [
                    K
                ];
                L.set(K.value, K);
            }
            L.size > 1 && L.has("") && L.delete("");
            const Y = [
                ...L.values()
            ];
            return n.set(y, Y), Y;
        }
        intersects(T, I) {
            if (!(T instanceof e)) throw new TypeError("a Range is required");
            return this.set.some((y)=>x(y, I) && T.set.some((w)=>x(w, I) && y.every((M)=>w.every((D)=>M.intersects(D, I)))));
        }
        // if ANY of the sets match ALL of its comparators, then pass
        test(T) {
            if (!T) return !1;
            if (typeof T == "string") try {
                T = new a(T, this.options);
            } catch  {
                return !1;
            }
            for(let I = 0; I < this.set.length; I++)if (B(this.set[I], T, this.options)) return !0;
            return !1;
        }
    }
    cl = e;
    const t = C6, n = new t(), s = yh, i = Jc(), o = Xc, a = Qt, { safeRe: u, t: c, comparatorTrimReplace: l, tildeTrimReplace: d, caretTrimReplace: h } = _o, { FLAG_INCLUDE_PRERELEASE: f, FLAG_LOOSE: g } = Kc, p = (C)=>C.value === "<0.0.0-0", m = (C)=>C.value === "", x = (C, T)=>{
        let I = !0;
        const y = C.slice();
        let w = y.pop();
        for(; I && y.length;)I = y.every((M)=>w.intersects(M, T)), w = y.pop();
        return I;
    }, _ = (C, T)=>(C = C.replace(u[c.BUILD], ""), o("comp", C, T), C = z(C, T), o("caret", C), C = N(C, T), o("tildes", C), C = U(C, T), o("xrange", C), C = G(C, T), o("stars", C), C), v = (C)=>!C || C.toLowerCase() === "x" || C === "*", N = (C, T)=>C.trim().split(/\s+/).map((I)=>O(I, T)).join(" "), O = (C, T)=>{
        const I = T.loose ? u[c.TILDELOOSE] : u[c.TILDE];
        return C.replace(I, (y, w, M, D, A)=>{
            o("tilde", C, y, w, M, D, A);
            let L;
            return v(w) ? L = "" : v(M) ? L = `>=${w}.0.0 <${+w + 1}.0.0-0` : v(D) ? L = `>=${w}.${M}.0 <${w}.${+M + 1}.0-0` : A ? (o("replaceTilde pr", A), L = `>=${w}.${M}.${D}-${A} <${w}.${+M + 1}.0-0`) : L = `>=${w}.${M}.${D} <${w}.${+M + 1}.0-0`, o("tilde return", L), L;
        });
    }, z = (C, T)=>C.trim().split(/\s+/).map((I)=>P(I, T)).join(" "), P = (C, T)=>{
        o("caret", C, T);
        const I = T.loose ? u[c.CARETLOOSE] : u[c.CARET], y = T.includePrerelease ? "-0" : "";
        return C.replace(I, (w, M, D, A, L)=>{
            o("caret", C, w, M, D, A, L);
            let V;
            return v(M) ? V = "" : v(D) ? V = `>=${M}.0.0${y} <${+M + 1}.0.0-0` : v(A) ? M === "0" ? V = `>=${M}.${D}.0${y} <${M}.${+D + 1}.0-0` : V = `>=${M}.${D}.0${y} <${+M + 1}.0.0-0` : L ? (o("replaceCaret pr", L), M === "0" ? D === "0" ? V = `>=${M}.${D}.${A}-${L} <${M}.${D}.${+A + 1}-0` : V = `>=${M}.${D}.${A}-${L} <${M}.${+D + 1}.0-0` : V = `>=${M}.${D}.${A}-${L} <${+M + 1}.0.0-0`) : (o("no pr"), M === "0" ? D === "0" ? V = `>=${M}.${D}.${A}${y} <${M}.${D}.${+A + 1}-0` : V = `>=${M}.${D}.${A}${y} <${M}.${+D + 1}.0-0` : V = `>=${M}.${D}.${A} <${+M + 1}.0.0-0`), o("caret return", V), V;
        });
    }, U = (C, T)=>(o("replaceXRanges", C, T), C.split(/\s+/).map((I)=>R(I, T)).join(" ")), R = (C, T)=>{
        C = C.trim();
        const I = T.loose ? u[c.XRANGELOOSE] : u[c.XRANGE];
        return C.replace(I, (y, w, M, D, A, L)=>{
            o("xRange", C, y, w, M, D, A, L);
            const V = v(M), Y = V || v(D), K = Y || v(A), J = K;
            return w === "=" && J && (w = ""), L = T.includePrerelease ? "-0" : "", V ? w === ">" || w === "<" ? y = "<0.0.0-0" : y = "*" : w && J ? (Y && (D = 0), A = 0, w === ">" ? (w = ">=", Y ? (M = +M + 1, D = 0, A = 0) : (D = +D + 1, A = 0)) : w === "<=" && (w = "<", Y ? M = +M + 1 : D = +D + 1), w === "<" && (L = "-0"), y = `${w + M}.${D}.${A}${L}`) : Y ? y = `>=${M}.0.0${L} <${+M + 1}.0.0-0` : K && (y = `>=${M}.${D}.0${L} <${M}.${+D + 1}.0-0`), o("xRange return", y), y;
        });
    }, G = (C, T)=>(o("replaceStars", C, T), C.trim().replace(u[c.STAR], "")), F = (C, T)=>(o("replaceGTE0", C, T), C.trim().replace(u[T.includePrerelease ? c.GTE0PRE : c.GTE0], "")), H = (C)=>(T, I, y, w, M, D, A, L, V, Y, K, J)=>(v(y) ? I = "" : v(w) ? I = `>=${y}.0.0${C ? "-0" : ""}` : v(M) ? I = `>=${y}.${w}.0${C ? "-0" : ""}` : D ? I = `>=${I}` : I = `>=${I}${C ? "-0" : ""}`, v(V) ? L = "" : v(Y) ? L = `<${+V + 1}.0.0-0` : v(K) ? L = `<${V}.${+Y + 1}.0-0` : J ? L = `<=${V}.${Y}.${K}-${J}` : C ? L = `<${V}.${Y}.${+K + 1}-0` : L = `<=${L}`, `${I} ${L}`.trim()), B = (C, T, I)=>{
        for(let y = 0; y < C.length; y++)if (!C[y].test(T)) return !1;
        if (T.prerelease.length && !I.includePrerelease) {
            for(let y = 0; y < C.length; y++)if (o(C[y].semver), C[y].semver !== i.ANY && C[y].semver.prerelease.length > 0) {
                const w = C[y].semver;
                if (w.major === T.major && w.minor === T.minor && w.patch === T.patch) return !0;
            }
            return !1;
        }
        return !0;
    };
    return cl;
}
var ul, b0;
function Jc() {
    if (b0) return ul;
    b0 = 1;
    const r = Symbol("SemVer ANY");
    class e {
        static get ANY() {
            return r;
        }
        constructor(l, d){
            if (d = t(d), l instanceof e) {
                if (l.loose === !!d.loose) return l;
                l = l.value;
            }
            l = l.trim().split(/\s+/).join(" "), o("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === r ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
        }
        parse(l) {
            const d = this.options.loose ? n[s.COMPARATORLOOSE] : n[s.COMPARATOR], h = l.match(d);
            if (!h) throw new TypeError(`Invalid comparator: ${l}`);
            this.operator = h[1] !== void 0 ? h[1] : "", this.operator === "=" && (this.operator = ""), h[2] ? this.semver = new a(h[2], this.options.loose) : this.semver = r;
        }
        toString() {
            return this.value;
        }
        test(l) {
            if (o("Comparator.test", l, this.options.loose), this.semver === r || l === r) return !0;
            if (typeof l == "string") try {
                l = new a(l, this.options);
            } catch  {
                return !1;
            }
            return i(l, this.operator, this.semver, this.options);
        }
        intersects(l, d) {
            if (!(l instanceof e)) throw new TypeError("a Comparator is required");
            return this.operator === "" ? this.value === "" ? !0 : new u(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new u(this.value, d).test(l.semver) : (d = t(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || i(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || i(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
        }
    }
    ul = e;
    const t = yh, { safeRe: n, t: s } = _o, i = ub, o = Xc, a = Qt, u = jr();
    return ul;
}
const L6 = jr(), k6 = (r, e, t)=>{
    try {
        e = new L6(e, t);
    } catch  {
        return !1;
    }
    return e.test(r);
};
var eu = k6;
const z6 = jr(), P6 = (r, e)=>new z6(r, e).set.map((t)=>t.map((n)=>n.value).join(" ").trim().split(" "));
var U6 = P6;
const R6 = Qt, $6 = jr(), B6 = (r, e, t)=>{
    let n = null, s = null, i = null;
    try {
        i = new $6(e, t);
    } catch  {
        return null;
    }
    return r.forEach((o)=>{
        i.test(o) && (!n || s.compare(o) === -1) && (n = o, s = new R6(n, t));
    }), n;
};
var F6 = B6;
const q6 = Qt, Q6 = jr(), V6 = (r, e, t)=>{
    let n = null, s = null, i = null;
    try {
        i = new Q6(e, t);
    } catch  {
        return null;
    }
    return r.forEach((o)=>{
        i.test(o) && (!n || s.compare(o) === 1) && (n = o, s = new q6(n, t));
    }), n;
};
var Y6 = V6;
const ll = Qt, G6 = jr(), v0 = Zc, H6 = (r, e)=>{
    r = new G6(r, e);
    let t = new ll("0.0.0");
    if (r.test(t) || (t = new ll("0.0.0-0"), r.test(t))) return t;
    t = null;
    for(let n = 0; n < r.set.length; ++n){
        const s = r.set[n];
        let i = null;
        s.forEach((o)=>{
            const a = new ll(o.semver.version);
            switch(o.operator){
                case ">":
                    a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
                case "":
                case ">=":
                    (!i || v0(a, i)) && (i = a);
                    break;
                case "<":
                case "<=":
                    break;
                default:
                    throw new Error(`Unexpected operation: ${o.operator}`);
            }
        }), i && (!t || v0(t, i)) && (t = i);
    }
    return t && r.test(t) ? t : null;
};
var W6 = H6;
const K6 = jr(), X6 = (r, e)=>{
    try {
        return new K6(r, e).range || "*";
    } catch  {
        return null;
    }
};
var Z6 = X6;
const J6 = Qt, lb = Jc(), { ANY: e8 } = lb, t8 = jr(), r8 = eu, E0 = Zc, M0 = mh, n8 = vh, i8 = bh, s8 = (r, e, t, n)=>{
    r = new J6(r, n), e = new t8(e, n);
    let s, i, o, a, u;
    switch(t){
        case ">":
            s = E0, i = n8, o = M0, a = ">", u = ">=";
            break;
        case "<":
            s = M0, i = i8, o = E0, a = "<", u = "<=";
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (r8(r, e, n)) return !1;
    for(let c = 0; c < e.set.length; ++c){
        const l = e.set[c];
        let d = null, h = null;
        if (l.forEach((f)=>{
            f.semver === e8 && (f = new lb(">=0.0.0")), d = d || f, h = h || f, s(f.semver, d.semver, n) ? d = f : o(f.semver, h.semver, n) && (h = f);
        }), d.operator === a || d.operator === u || (!h.operator || h.operator === a) && i(r, h.semver)) return !1;
        if (h.operator === u && o(r, h.semver)) return !1;
    }
    return !0;
};
var Eh = s8;
const o8 = Eh, a8 = (r, e, t)=>o8(r, e, ">", t);
var c8 = a8;
const u8 = Eh, l8 = (r, e, t)=>u8(r, e, "<", t);
var d8 = l8;
const N0 = jr(), h8 = (r, e, t)=>(r = new N0(r, t), e = new N0(e, t), r.intersects(e, t));
var f8 = h8;
const p8 = eu, g8 = Or;
var y8 = (r, e, t)=>{
    const n = [];
    let s = null, i = null;
    const o = r.sort((l, d)=>g8(l, d, t));
    for (const l of o)p8(l, e, t) ? (i = l, s || (s = l)) : (i && n.push([
        s,
        i
    ]), i = null, s = null);
    s && n.push([
        s,
        null
    ]);
    const a = [];
    for (const [l, d] of n)l === d ? a.push(l) : !d && l === o[0] ? a.push("*") : d ? l === o[0] ? a.push(`<=${d}`) : a.push(`${l} - ${d}`) : a.push(`>=${l}`);
    const u = a.join(" || "), c = typeof e.raw == "string" ? e.raw : String(e);
    return u.length < c.length ? u : e;
};
const x0 = jr(), Mh = Jc(), { ANY: dl } = Mh, Ys = eu, Nh = Or, w8 = (r, e, t = {})=>{
    if (r === e) return !0;
    r = new x0(r, t), e = new x0(e, t);
    let n = !1;
    e: for (const s of r.set){
        for (const i of e.set){
            const o = b8(s, i, t);
            if (n = n || o !== null, o) continue e;
        }
        if (n) return !1;
    }
    return !0;
}, m8 = [
    new Mh(">=0.0.0-0")
], I0 = [
    new Mh(">=0.0.0")
], b8 = (r, e, t)=>{
    if (r === e) return !0;
    if (r.length === 1 && r[0].semver === dl) {
        if (e.length === 1 && e[0].semver === dl) return !0;
        t.includePrerelease ? r = m8 : r = I0;
    }
    if (e.length === 1 && e[0].semver === dl) {
        if (t.includePrerelease) return !0;
        e = I0;
    }
    const n = /* @__PURE__ */ new Set();
    let s, i;
    for (const f of r)f.operator === ">" || f.operator === ">=" ? s = T0(s, f, t) : f.operator === "<" || f.operator === "<=" ? i = D0(i, f, t) : n.add(f.semver);
    if (n.size > 1) return null;
    let o;
    if (s && i) {
        if (o = Nh(s.semver, i.semver, t), o > 0) return null;
        if (o === 0 && (s.operator !== ">=" || i.operator !== "<=")) return null;
    }
    for (const f of n){
        if (s && !Ys(f, String(s), t) || i && !Ys(f, String(i), t)) return null;
        for (const g of e)if (!Ys(f, String(g), t)) return !1;
        return !0;
    }
    let a, u, c, l, d = i && !t.includePrerelease && i.semver.prerelease.length ? i.semver : !1, h = s && !t.includePrerelease && s.semver.prerelease.length ? s.semver : !1;
    d && d.prerelease.length === 1 && i.operator === "<" && d.prerelease[0] === 0 && (d = !1);
    for (const f of e){
        if (l = l || f.operator === ">" || f.operator === ">=", c = c || f.operator === "<" || f.operator === "<=", s) {
            if (h && f.semver.prerelease && f.semver.prerelease.length && f.semver.major === h.major && f.semver.minor === h.minor && f.semver.patch === h.patch && (h = !1), f.operator === ">" || f.operator === ">=") {
                if (a = T0(s, f, t), a === f && a !== s) return !1;
            } else if (s.operator === ">=" && !Ys(s.semver, String(f), t)) return !1;
        }
        if (i) {
            if (d && f.semver.prerelease && f.semver.prerelease.length && f.semver.major === d.major && f.semver.minor === d.minor && f.semver.patch === d.patch && (d = !1), f.operator === "<" || f.operator === "<=") {
                if (u = D0(i, f, t), u === f && u !== i) return !1;
            } else if (i.operator === "<=" && !Ys(i.semver, String(f), t)) return !1;
        }
        if (!f.operator && (i || s) && o !== 0) return !1;
    }
    return !(s && c && !i && o !== 0 || i && l && !s && o !== 0 || h || d);
}, T0 = (r, e, t)=>{
    if (!r) return e;
    const n = Nh(r.semver, e.semver, t);
    return n > 0 ? r : n < 0 || e.operator === ">" && r.operator === ">=" ? e : r;
}, D0 = (r, e, t)=>{
    if (!r) return e;
    const n = Nh(r.semver, e.semver, t);
    return n < 0 ? r : n > 0 || e.operator === "<" && r.operator === "<=" ? e : r;
};
var v8 = w8;
const hl = _o, _0 = Kc, E8 = Qt, A0 = ob, M8 = ms, N8 = AU, x8 = jU, I8 = LU, T8 = zU, D8 = RU, _8 = FU, A8 = VU, S8 = HU, O8 = Or, j8 = ZU, C8 = t6, L8 = wh, k8 = s6, z8 = c6, P8 = Zc, U8 = mh, R8 = ab, $8 = cb, B8 = bh, F8 = vh, q8 = ub, Q8 = O6, V8 = Jc(), Y8 = jr(), G8 = eu, H8 = U6, W8 = F6, K8 = Y6, X8 = W6, Z8 = Z6, J8 = Eh, eR = c8, tR = d8, rR = f8, nR = y8, iR = v8;
var sR = {
    parse: M8,
    valid: N8,
    clean: x8,
    inc: I8,
    diff: T8,
    major: D8,
    minor: _8,
    patch: A8,
    prerelease: S8,
    compare: O8,
    rcompare: j8,
    compareLoose: C8,
    compareBuild: L8,
    sort: k8,
    rsort: z8,
    gt: P8,
    lt: U8,
    eq: R8,
    neq: $8,
    gte: B8,
    lte: F8,
    cmp: q8,
    coerce: Q8,
    Comparator: V8,
    Range: Y8,
    satisfies: G8,
    toComparators: H8,
    maxSatisfying: W8,
    minSatisfying: K8,
    minVersion: X8,
    validRange: Z8,
    outside: J8,
    gtr: eR,
    ltr: tR,
    intersects: rR,
    simplifyRange: nR,
    subset: iR,
    SemVer: E8,
    re: hl.re,
    src: hl.src,
    tokens: hl.t,
    SEMVER_SPEC_VERSION: _0.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: _0.RELEASE_TYPES,
    compareIdentifiers: A0.compareIdentifiers,
    rcompareIdentifiers: A0.rcompareIdentifiers
};
const S0 = /* @__PURE__ */ Di(sR);
var tt;
(function(r) {
    r.blue = "blue", r.nanoS = "nanoS", r.nanoSP = "nanoSP", r.nanoX = "nanoX", r.stax = "stax", r.europa = "europa", r.apex = "apex";
})(tt || (tt = {}));
const yd = {
    [tt.blue]: {
        id: tt.blue,
        productName: "LedgerBlue",
        productIdMM: 0,
        legacyUsbProductId: 0,
        usbOnly: !0,
        memorySize: 480 * 1024,
        masks: [
            822083584,
            822149120
        ],
        getBlockSize: (r)=>4 * 1024
    },
    [tt.nanoS]: {
        id: tt.nanoS,
        productName: "LedgerNanoS",
        productIdMM: 16,
        legacyUsbProductId: 1,
        usbOnly: !0,
        memorySize: 320 * 1024,
        masks: [
            823132160
        ],
        getBlockSize: (r)=>S0.lt(S0.coerce(r) ?? "", "2.0.0") ? 4 * 1024 : 2 * 1024
    },
    [tt.nanoX]: {
        id: tt.nanoX,
        productName: "LedgerNanoX",
        productIdMM: 64,
        legacyUsbProductId: 4,
        usbOnly: !1,
        memorySize: 2 * 1024 * 1024,
        masks: [
            855638016
        ],
        getBlockSize: (r)=>4 * 1024,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-0004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572"
            }
        ]
    },
    [tt.nanoSP]: {
        id: tt.nanoSP,
        productName: "Ledger Nano S Plus",
        productIdMM: 80,
        legacyUsbProductId: 5,
        usbOnly: !0,
        memorySize: 1533 * 1024,
        masks: [
            856686592
        ],
        getBlockSize: (r)=>32
    },
    [tt.apex]: {
        id: tt.apex,
        productName: "Ledger Apex",
        productIdMM: 128,
        legacyUsbProductId: 8,
        usbOnly: !1,
        memorySize: 1533 * 1024,
        masks: [
            859832320
        ],
        getBlockSize: (r)=>32,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-8004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-8004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-8004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-8004-0003-4c6564676572"
            }
        ]
    },
    [tt.stax]: {
        id: tt.stax,
        productName: "LedgerStax",
        productIdMM: 96,
        legacyUsbProductId: 6,
        usbOnly: !1,
        memorySize: 1533 * 1024,
        masks: [
            857735168
        ],
        getBlockSize: (r)=>32,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-6004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-6004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-6004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572"
            }
        ]
    },
    [tt.europa]: {
        id: tt.europa,
        productName: "LedgerFlex",
        productIdMM: 112,
        legacyUsbProductId: 7,
        usbOnly: !1,
        memorySize: 1533 * 1024,
        masks: [
            858783744
        ],
        getBlockSize: (r)=>32,
        bluetoothSpec: [
            {
                serviceUuid: "13d63400-2c97-3004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-3004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-3004-0002-4c6564676572",
                writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572"
            }
        ]
    }
};
tt.blue, tt.nanoS, tt.nanoSP, tt.nanoX, tt.stax, tt.europa;
const O0 = Object.values(yd), tu = 11415, Xa = (r)=>{
    const e = O0.find((s)=>s.legacyUsbProductId === r);
    if (e) return e;
    const t = r >> 8;
    return O0.find((s)=>s.productIdMM === t);
}, oR = [], j0 = {};
for(const r in yd){
    const e = yd[r], { bluetoothSpec: t } = e;
    if (t) for(let n = 0; n < t.length; n++){
        const s = t[n];
        oR.push(s.serviceUuid), j0[s.serviceUuid] = j0[s.serviceUuid.replace(/-/g, "")] = {
            deviceModel: e,
            ...s
        };
    }
}
const aR = [
    {
        vendorId: tu
    }
], cR = ()=>Promise.resolve(!!(window.navigator && window.navigator.hid)), Za = ()=>{
    const { hid: r } = navigator;
    if (!r) throw new Gr("navigator.hid is not supported", "HIDNotSupported");
    return r;
};
async function db() {
    const r = await Za().requestDevice({
        filters: aR
    });
    return Array.isArray(r) ? r : [
        r
    ];
}
async function wd() {
    return (await Za().getDevices()).filter((e)=>e.vendorId === tu);
}
async function uR() {
    const r = await wd();
    return r.length > 0 ? r[0] : (await db())[0];
}
const Rn = class Rn extends Un {
    constructor(t){
        super();
        S(this, "device");
        S(this, "deviceModel");
        S(this, "channel", Math.floor(Math.random() * 65535));
        S(this, "packetSize", 64);
        S(this, "inputs", []);
        S(this, "inputCallback");
        S(this, "read", ()=>this.inputs.length ? Promise.resolve(this.inputs.shift()) : new Promise((t)=>{
                this.inputCallback = t;
            }));
        S(this, "onInputReport", (t)=>{
            const n = ye.Buffer.from(t.data.buffer);
            this.inputCallback ? (this.inputCallback(n), this.inputCallback = null) : this.inputs.push(n);
        });
        S(this, "_disconnectEmitted", !1);
        S(this, "_emitDisconnect", (t)=>{
            this._disconnectEmitted || (this._disconnectEmitted = !0, this.emit("disconnect", t));
        });
        /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */ S(this, "exchange", async (t)=>await this.exchangeAtomicImpl(async ()=>{
                const { channel: s, packetSize: i } = this;
                Ka("apdu", "=> " + t.toString("hex"));
                const o = nb(s, i), a = o.makeBlocks(t);
                for(let l = 0; l < a.length; l++)await this.device.sendReport(0, a[l]);
                let u, c;
                for(; !(u = o.getReducedResult(c));)try {
                    const l = await this.read();
                    c = o.reduceResponse(c, l);
                } catch (l) {
                    if (l instanceof Gr && l.id === "InvalidChannel") continue;
                    throw l;
                }
                return Ka("apdu", "<= " + u.toString("hex")), u;
            }).catch((s)=>{
                throw s && s.message && s.message.includes("write") ? (this._emitDisconnect(s), new eb(s.message)) : s;
            }));
        this.device = t, this.deviceModel = typeof t.productId == "number" ? Xa(t.productId) : void 0, t.addEventListener("inputreport", this.onInputReport);
    }
    /**
   * Similar to create() except it will always display the device permission (even if some devices are already accepted).
   */ static async request() {
        const [t] = await db();
        return Rn.open(t);
    }
    /**
   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
   */ static async openConnected() {
        const t = await wd();
        return t.length === 0 ? null : Rn.open(t[0]);
    }
    /**
   * Create a Ledger transport with a HIDDevice
   */ static async open(t) {
        await t.open();
        const n = new Rn(t), s = (i)=>{
            t === i.device && (Za().removeEventListener("disconnect", s), n._emitDisconnect(new J1()));
        };
        return Za().addEventListener("disconnect", s), n;
    }
    /**
   * Release the transport device
   */ async close() {
        await this.exchangeBusyPromise, this.device.removeEventListener("inputreport", this.onInputReport), await this.device.close();
    }
    setScrambleKey() {}
};
/**
 * Check if WebUSB transport is supported.
 */ S(Rn, "isSupported", cR), /**
 * List the WebUSB devices that was previously authorized by the user.
 */ S(Rn, "list", wd), /**
 * Actively listen to WebUSB devices and emit ONE device
 * that was either accepted before, if not it will trigger the native permission UI.
 *
 * Important: it must be called in the context of a UI click!
 */ S(Rn, "listen", (t)=>{
    let n = !1;
    uR().then((i)=>{
        if (!i) t.error(new pd("Access denied to use Ledger device"));
        else if (!n) {
            const o = typeof i.productId == "number" ? Xa(i.productId) : void 0;
            t.next({
                type: "add",
                descriptor: i,
                deviceModel: o
            }), t.complete();
        }
    }, (i)=>{
        t.error(new pd(i.message));
    });
    function s() {
        n = !0;
    }
    return {
        unsubscribe: s
    };
});
let Ja = Rn;
const lR = [
    {
        vendorId: tu
    }
];
async function hb() {
    return await navigator.usb.requestDevice({
        filters: lR
    });
}
async function md() {
    return (await navigator.usb.getDevices()).filter((e)=>e.vendorId === tu);
}
async function dR() {
    const r = await md();
    return r.length > 0 ? r[0] : hb();
}
const hR = ()=>Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices == "function"), fR = 1, C0 = 3, $n = class $n extends Un {
    constructor(t, n){
        super();
        S(this, "device");
        S(this, "deviceModel");
        S(this, "channel", Math.floor(Math.random() * 65535));
        S(this, "packetSize", 64);
        S(this, "interfaceNumber");
        S(this, "_disconnectEmitted", !1);
        S(this, "_emitDisconnect", (t)=>{
            this._disconnectEmitted || (this._disconnectEmitted = !0, this.emit("disconnect", t));
        });
        this.device = t, this.interfaceNumber = n, this.deviceModel = Xa(t.productId);
    }
    /**
   * Similar to create() except it will always display the device permission (even if some devices are already accepted).
   */ static async request() {
        const t = await hb();
        return $n.open(t);
    }
    /**
   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
   */ static async openConnected() {
        const t = await md();
        return t.length === 0 ? null : $n.open(t[0]);
    }
    /**
   * Create a Ledger transport with a USBDevice
   */ static async open(t) {
        await t.open(), t.configuration === null && await t.selectConfiguration(fR), await L0(t);
        const n = t.configurations[0].interfaces.find(({ alternates: a })=>a.some((u)=>u.interfaceClass === 255));
        if (!n) throw new c0("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
        const s = n.interfaceNumber;
        try {
            await t.claimInterface(s);
        } catch (a) {
            throw await t.close(), new c0(a.message);
        }
        const i = new $n(t, s), o = (a)=>{
            t === a.device && (navigator.usb.removeEventListener("disconnect", o), i._emitDisconnect(new J1()));
        };
        return navigator.usb.addEventListener("disconnect", o), i;
    }
    /**
   * Release the transport device
   */ async close() {
        await this.exchangeBusyPromise, await this.device.releaseInterface(this.interfaceNumber), await L0(this.device), await this.device.close();
    }
    /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */ async exchange(t) {
        return await this.exchangeAtomicImpl(async ()=>{
            const { channel: s, packetSize: i } = this;
            Ka("apdu", "=> " + t.toString("hex"));
            const o = nb(s, i), a = o.makeBlocks(t);
            for(let l = 0; l < a.length; l++)await this.device.transferOut(C0, a[l]);
            let u, c;
            for(; !(u = o.getReducedResult(c));){
                const l = await this.device.transferIn(C0, i), d = ye.Buffer.from(l.data.buffer);
                c = o.reduceResponse(c, d);
            }
            return Ka("apdu", "<= " + u.toString("hex")), u;
        }).catch((s)=>{
            throw s && s.message && s.message.includes("disconnected") ? (this._emitDisconnect(s), new eb(s.message)) : s;
        });
    }
    setScrambleKey() {}
};
/**
 * Check if WebUSB transport is supported.
 */ S($n, "isSupported", hR), /**
 * List the WebUSB devices that was previously authorized by the user.
 */ S($n, "list", md), /**
 * Actively listen to WebUSB devices and emit ONE device
 * that was either accepted before, if not it will trigger the native permission UI.
 *
 * Important: it must be called in the context of a UI click!
 */ S($n, "listen", (t)=>{
    let n = !1;
    dR().then((i)=>{
        if (!n) {
            const o = Xa(i.productId);
            t.next({
                type: "add",
                descriptor: i,
                deviceModel: o
            }), t.complete();
        }
    }, (i)=>{
        window.DOMException && i instanceof window.DOMException && i.code === 18 ? t.error(new aU(i.message)) : t.error(new pd(i.message));
    });
    function s() {
        n = !0;
    }
    return {
        unsubscribe: s
    };
});
let ec = $n;
async function L0(r) {
    try {
        await r.reset();
    } catch (e) {
        console.warn(e);
    }
}
const tc = 2147483648;
var vr = function(r) {
    if (!Array.isArray(r)) throw new Error("Input must be an Array");
    if (r.length === 0) throw new Error("Path must contain at least one level");
    for(var e = 0; e < r.length; e++)if (typeof r[e] != "number") throw new Error("Path element is not a number");
    this.path = r;
};
vr.validatePathArray = function(r) {
    try {
        return vr.fromPathArray(r), !0;
    } catch  {
        return !1;
    }
};
vr.validateString = function(r, e) {
    try {
        return vr.fromString(r, e), !0;
    } catch  {
        return !1;
    }
};
vr.fromPathArray = function(r) {
    return new vr(r);
};
vr.fromString = function(r, e) {
    if (/^m\//i.test(r)) r = r.slice(2);
    else if (e) throw new Error("Root element is required");
    for(var t = r.split("/"), n = new Array(t.length), s = 0; s < t.length; s++){
        var i = /(\d+)([hH\']?)/.exec(t[s]);
        if (i === null) throw new Error("Invalid input");
        if (n[s] = parseInt(i[1], 10), n[s] >= tc) throw new Error("Invalid child index");
        if (i[2] === "h" || i[2] === "H" || i[2] === "'") n[s] += tc;
        else if (i[2].length != 0) throw new Error("Invalid modifier");
    }
    return new vr(n);
};
vr.prototype.toPathArray = function() {
    return this.path;
};
vr.prototype.toString = function(r, e) {
    for(var t = new Array(this.path.length), n = 0; n < this.path.length; n++){
        var s = this.path[n];
        s & tc ? t[n] = (s & ~tc) + (e ? "h" : "'") : t[n] = s;
    }
    return (r ? "" : "m/") + t.join("/");
};
vr.prototype.inspect = function() {
    return "BIPPath <" + this.toString() + ">";
};
var pR = vr;
const k0 = /* @__PURE__ */ Di(pR);
class fl {
    constructor(e, t = "XRP"){
        S(this, "transport");
        this.transport = e, e.decorateAppAPIMethods(this, [
            "getAddress",
            "signTransaction",
            "getAppConfiguration"
        ], t);
    }
    /**
   * get XRP address for a given BIP 32 path.
   *
   * @param path a path in BIP 32 format
   * @param display optionally enable or not the display
   * @param chainCode optionally enable or not the chainCode request
   * @param ed25519 optionally enable or not the ed25519 curve (secp256k1 is default)
   * @return an object with a publicKey, address and (optionally) chainCode
   * @example
   * const result = await xrp.getAddress("44'/144'/0'/0/0");
   * const { publicKey, address } = result;
   */ async getAddress(e, t, n, s) {
        const i = k0.fromString(e).toPathArray(), o = s ? 128 : 64, a = 224, u = 2, c = t ? 1 : 0, l = o | (n ? 1 : 0), d = ye.Buffer.alloc(1 + i.length * 4);
        d.writeInt8(i.length, 0), i.forEach((p, m)=>{
            d.writeUInt32BE(p, 1 + m * 4);
        });
        const h = await this.transport.send(a, u, c, l, d), f = h[0], g = h[1 + f];
        return {
            publicKey: h.slice(1, 1 + f).toString("hex"),
            address: h.slice(1 + f + 1, 1 + f + 1 + g).toString("ascii"),
            chainCode: n ? h.slice(1 + f + 1 + g, 1 + f + 1 + g + 32).toString("hex") : void 0
        };
    }
    /**
   * sign a XRP transaction with a given BIP 32 path
   *
   * The rawTxHex parameter is the serialized transaction blob represented as
   * hex.
   *
   * @param path a path in BIP 32 format
   * @param rawTxHex a raw hex string representing a serialized transaction blob.
   *        This parameter can be encoded using [ripple-binary-codec](https://www.npmjs.com/package/ripple-binary-codec).
   *        See https://xrpl.org/serialization.html for more documentation on the serialization format.
   * @param ed25519 optionally enable or not the ed25519 curve (secp256k1 is default)
   * @return a signature as hex string
   * @example
   * const signature = await xrp.signTransaction("44'/144'/0'/0/0", "12000022800000002400000002614000000001315D3468400000000000000C73210324E5F600B52BB3D9246D49C4AB1722BA7F32B7A3E4F9F2B8A1A28B9118CC36C48114F31B152151B6F42C1D61FE4139D34B424C8647D183142ECFC1831F6E979C6DA907E88B1CAD602DB59E2F");
   */ async signTransaction(e, t, n) {
        const s = k0.fromString(e).toPathArray(), i = ye.Buffer.from(t, "hex"), o = n ? 128 : 64, a = [];
        let u = 0;
        for(; u !== i.length;){
            const l = u === 0, d = l ? 149 - s.length * 4 : 150, h = u + d < i.length, f = h ? d : i.length - u, g = {
                cla: 224,
                ins: 4,
                p1: (l ? 0 : 1) | (h ? 128 : 0),
                p2: o,
                data: l ? ye.Buffer.alloc(1 + s.length * 4 + f) : ye.Buffer.alloc(f)
            };
            l ? (g.data.writeInt8(s.length, 0), s.forEach((p, m)=>{
                g.data.writeUInt32BE(p, 1 + m * 4);
            }), i.copy(g.data, 1 + s.length * 4, u, u + f)) : i.copy(g.data, 0, u, u + f), a.push(g), u += f;
        }
        let c = ye.Buffer.alloc(0);
        for (const l of a)c = await this.transport.send(l.cla, l.ins, l.p1, l.p2, l.data);
        return c.slice(0, c.length - 2).toString("hex");
    }
    /**
   * get the version of the XRP app installed on the hardware device
   *
   * @return an object with a version
   * @example
   * const result = await xrp.getAppConfiguration();
   *
   * {
   *   "version": "1.0.3"
   * }
   */ async getAppConfiguration() {
        const e = await this.transport.send(224, 6, 0, 0);
        return {
            version: "" + e[1] + "." + e[2] + "." + e[3]
        };
    }
}
var pa = {
    NOT_CONNECTED: "Please connect your Ledger device via USB",
    LOCKED: "Please unlock your Ledger device by entering your PIN",
    APP_NOT_OPEN: "Please open the XRP application on your Ledger device"
};
function Xs(r) {
    if (r && typeof r == "object") {
        const e = r;
        if ("statusCode" in e) switch(e.statusCode){
            case 26628:
                return {
                    state: "LOCKED",
                    message: pa.LOCKED
                };
            case 28160:
            case 25873:
            case 25871:
                return {
                    state: "APP_NOT_OPEN",
                    message: pa.APP_NOT_OPEN
                };
            case 27013:
                return {
                    state: "READY",
                    message: "Transaction rejected on Ledger device"
                };
        }
        if ("message" in e && typeof e.message == "string") {
            const t = e.message.toLowerCase();
            if (t.includes("no device") || t.includes("not found") || t.includes("cannot open device") || t.includes("disconnected")) return {
                state: "NOT_CONNECTED",
                message: pa.NOT_CONNECTED
            };
            if (t.includes("locked")) return {
                state: "LOCKED",
                message: pa.LOCKED
            };
            if (t.includes("rejected") || t.includes("denied")) return {
                state: "READY",
                message: "Operation rejected on Ledger device"
            };
        }
    }
    return {
        state: "UNKNOWN",
        message: r instanceof Error ? r.message : "Unknown Ledger error"
    };
}
function pl() {
    const r = typeof navigator < "u" && "hid" in navigator, e = typeof navigator < "u" && "usb" in navigator;
    return !r && !e ? {
        supported: !1,
        webHID: !1,
        webUSB: !1,
        message: "Your browser does not support WebHID or WebUSB. Please use Chrome, Edge, or Opera."
    } : {
        supported: !0,
        webHID: r,
        webUSB: e
    };
}
function z0(r) {
    const { state: e, message: t } = Xs(r);
    switch(e){
        case "NOT_CONNECTED":
            return `${t}

Make sure your Ledger is connected via USB and try again.`;
        case "LOCKED":
            return `${t}

Enter your PIN on the Ledger device to unlock it.`;
        case "APP_NOT_OPEN":
            return `${t}

Navigate to the XRP app on your Ledger and open it.`;
        default:
            return t;
    }
}
var gR = 6e4, yR = class {
    constructor(r = {}){
        if (this.id = "ledger", this.name = "Ledger", this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTAgMGgyOHYyOEgweiIvPjxwYXRoIGZpbGw9IiNmZmYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjY1IDQuNEg0LjRWOWgxLjFWNS41bDYuMTUtLjA0VjQuNFptLjA1IDUuOTV2Ny4yNWg0LjZ2LTEuMWgtMy41bC0uMDQtNi4xNUgxMS43Wk00LjQgMjMuNmg3LjI1di0xLjA2TDUuNSAyMi41VjE5SDQuNHY0LjZaTTE2LjM1IDQuNGg3LjI1VjloLTEuMVY1LjVsLTYuMTUtLjA0VjQuNFptNy4yNSAxOS4yaC03LjI1di0xLjA2bDYuMTUtLjA0VjE5aDEuMXY0LjZaIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=", this.url = "https://www.ledger.com", this.transport = null, this.xrpApp = null, this.currentAccount = null, r.derivationPath) this.derivationPath = r.derivationPath;
        else {
            const e = r.accountIndex ?? 0;
            this.derivationPath = `44'/144'/${e}'/0/0`;
        }
        this.timeout = r.timeout || gR, this.preferWebHID = r.preferWebHID !== !1;
    }
    /**
   * Check if Ledger is available (browser supports WebHID/WebUSB)
   */ async isAvailable() {
        return pl().supported;
    }
    /**
   * Get the current device state
   */ async getDeviceState() {
        try {
            const r = await this.createTransport();
            return await new fl(r).getAddress(this.derivationPath, !1, !1), await r.close(), "READY";
        } catch (r) {
            const { state: e } = Xs(r);
            return e;
        }
    }
    /**
   * Connect to Ledger device
   */ async connect(r) {
        try {
            const e = pl();
            if (!e.supported) throw ge.unknown(e.message || "Browser does not support Ledger");
            r != null && r.derivationPath && typeof r.derivationPath == "string" ? this.derivationPath = r.derivationPath : (r == null ? void 0 : r.accountIndex) !== void 0 && typeof r.accountIndex == "number" && (this.derivationPath = `44'/144'/${r.accountIndex}'/0/0`);
            const t = this.resolveNetwork(r == null ? void 0 : r.network);
            this.transport = await this.createTransport(), this.xrpApp = new fl(this.transport);
            const n = await this.withTimeout(this.xrpApp.getAddress(this.derivationPath, !1, !1), "Connection timeout. Please check your Ledger device.");
            if (!n || !n.address) throw new Error("Failed to get address from Ledger device");
            const { address: s, publicKey: i } = n;
            return this.currentAccount = {
                address: s,
                publicKey: i,
                network: t
            }, this.currentAccount;
        } catch (e) {
            await this.cleanup();
            const { state: t, message: n } = Xs(e);
            throw t === "NOT_CONNECTED" ? ge.notInstalled("Ledger device not found. Please connect your Ledger via USB.") : t === "LOCKED" ? ge.connectionFailed(this.name, new Error("Ledger is locked. Please unlock your Ledger by entering your PIN.")) : t === "APP_NOT_OPEN" ? ge.connectionFailed(this.name, new Error("XRP app is not open. Please open the XRP application on your Ledger device.")) : ge.connectionFailed(this.name, new Error(n || e.message));
        }
    }
    /**
   * Disconnect from Ledger
   */ async disconnect() {
        await this.cleanup(), this.currentAccount = null;
    }
    /**
   * Get current account
   */ async getAccount() {
        return this.currentAccount;
    }
    /**
   * Get current network
   */ async getNetwork() {
        if (!this.currentAccount) throw ge.notConnected();
        return this.currentAccount.network;
    }
    /**
   * Sign and optionally submit a transaction
   */ async signAndSubmit(r, e = !0) {
        if (!this.currentAccount) throw ge.notConnected();
        if (!this.xrpApp) throw ge.unknown("Ledger XRP app not initialized");
        try {
            const t = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xrpl$40$3$2e$1$2e$0$2f$node_modules$2f$xrpl$2f$dist$2f$npm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Client"](this.currentAccount.network.wss);
            await t.connect();
            try {
                const n = {
                    ...r,
                    Account: r.Account || this.currentAccount.address
                }, i = {
                    ...await t.autofill(n)
                };
                delete i.TxnSignature, delete i.Signers, i.SigningPubKey === "" ? i.SigningPubKey = "" : i.SigningPubKey = this.currentAccount.publicKey.toUpperCase();
                const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xrpl$40$3$2e$1$2e$0$2f$node_modules$2f$xrpl$2f$dist$2f$npm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])(i).toUpperCase(), u = await this.withTimeout(this.xrpApp.signTransaction(this.derivationPath, a), "Signing timeout. Please confirm the transaction on your Ledger device.");
                if (!u) throw new Error("Failed to sign transaction with Ledger");
                const c = {
                    ...i,
                    TxnSignature: u.toUpperCase()
                }, l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xrpl$40$3$2e$1$2e$0$2f$node_modules$2f$xrpl$2f$dist$2f$npm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])(c);
                if (!e) return await t.disconnect(), {
                    hash: "",
                    tx_blob: l
                };
                const d = await t.submitAndWait(l);
                return await t.disconnect(), {
                    hash: d.result.hash || "",
                    id: d.result.hash || "",
                    tx_blob: l
                };
            } catch (n) {
                throw await t.disconnect(), n;
            }
        } catch (t) {
            const { state: n, message: s } = Xs(t);
            throw n === "READY" && s.includes("rejected") ? ge.signRejected() : ge.signFailed(new Error(z0(t)));
        }
    }
    /**
   * Sign a message
   */ async signMessage(r) {
        if (!this.currentAccount) throw ge.notConnected();
        if (!this.xrpApp) throw ge.unknown("Ledger XRP app not initialized");
        try {
            const e = typeof r == "string" ? r : new TextDecoder().decode(r), t = Array.from(new TextEncoder().encode(e)).map((s)=>s.toString(16).padStart(2, "0")).join(""), n = await this.withTimeout(this.xrpApp.signTransaction(this.derivationPath, t), "Signing timeout. Please confirm the message on your Ledger device.");
            if (!n) throw new Error("Failed to sign message with Ledger");
            return {
                message: e,
                signature: n,
                publicKey: this.currentAccount.publicKey || ""
            };
        } catch (e) {
            throw ge.signFailed(new Error(z0(e)));
        }
    }
    /**
   * Get multiple accounts from Ledger device
   * Useful for account selection UI
   *
   * @param count Number of accounts to retrieve (default: 5)
   * @param startIndex Starting account index (default: 0)
   * @returns Array of account addresses with their derivation paths
   *
   * @example
   * ```typescript
   * const accounts = await ledgerAdapter.getAccounts(5, 0);
   * // Returns accounts at paths 44'/144'/0'/0/0 through 44'/144'/4'/0/0
   * ```
   */ async getAccounts(r = 5, e = 0) {
        try {
            const t = !this.transport;
            if (this.transport || (this.transport = await this.createTransport(), this.xrpApp = new fl(this.transport)), !this.xrpApp) throw new Error("Failed to initialize Ledger XRP app");
            const n = [];
            let s = null;
            for(let i = 0; i < r; i++){
                const o = e + i, a = `44'/144'/${o}'/0/0`;
                try {
                    const u = await this.withTimeout(this.xrpApp.getAddress(a, !1, !1), "Timeout retrieving account information");
                    n.push({
                        address: u.address,
                        publicKey: u.publicKey,
                        path: a,
                        index: o
                    });
                } catch (u) {
                    s = u, console.warn(`Failed to get account at index ${o}:`, u);
                }
            }
            if (t && await this.cleanup(), n.length === 0 && s) throw Xs(s);
            return n;
        } catch (t) {
            throw ge.unknown(`Failed to retrieve accounts: ${t.message}`);
        }
    }
    /**
   * Create transport (WebHID or WebUSB)
   */ async createTransport() {
        const r = pl();
        if (this.preferWebHID && r.webHID) try {
            return await Ja.create();
        } catch (e) {
            console.warn("WebHID transport failed, trying WebUSB:", e);
        }
        if (r.webUSB) try {
            return await ec.create();
        } catch (e) {
            throw e;
        }
        if (!this.preferWebHID && r.webUSB) try {
            return await ec.create();
        } catch (e) {
            console.warn("WebUSB transport failed, trying WebHID:", e);
        }
        if (r.webHID) return await Ja.create();
        throw new Error("No compatible transport available");
    }
    /**
   * Clean up transport connection
   */ async cleanup() {
        if (this.transport) {
            try {
                await this.transport.close();
            } catch (r) {
                console.warn("Error closing Ledger transport:", r);
            }
            this.transport = null;
        }
        this.xrpApp = null;
    }
    /**
   * Resolve network configuration
   */ resolveNetwork(r) {
        if (!r) return Hr.mainnet;
        if (typeof r == "string") {
            const e = Hr[r];
            if (!e) throw ge.unknown(`Unknown network: ${r}`);
            return e;
        }
        return r;
    }
    /**
   * Wrap promise with timeout
   */ async withTimeout(r, e) {
        return Promise.race([
            r,
            new Promise((t, n)=>setTimeout(()=>n(new Error(e)), this.timeout))
        ]);
    }
};
const w$ = {
    Xaman: Mv,
    Crossmark: xv,
    GemWallet: KM,
    WalletConnect: rU,
    Ledger: yR
};
;
}),
];

//# sourceMappingURL=89617_xrpl-connect_index-BGRwxDxq_mjs_65add390._.js.map